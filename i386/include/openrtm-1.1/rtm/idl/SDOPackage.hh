// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __SDOPackage_hh__
#define __SDOPackage_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_SDOPackage
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_SDOPackage
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_SDOPackage
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE SDOPackage

_CORBA_MODULE_BEG

#ifndef __SDOPackage_mSDO__
#define __SDOPackage_mSDO__

  class SDO;
  class _objref_SDO;
  class _impl_SDO;
  
  typedef _objref_SDO* SDO_ptr;
  typedef SDO_ptr SDORef;

  class SDO_Helper {
  public:
    typedef SDO_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SDO, SDO_Helper> SDO_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SDO,SDO_Helper > SDO_out;

#endif

#ifndef __SDOPackage_mSDOService__
#define __SDOPackage_mSDOService__

  class SDOService;
  class _objref_SDOService;
  class _impl_SDOService;
  
  typedef _objref_SDOService* SDOService_ptr;
  typedef SDOService_ptr SDOServiceRef;

  class SDOService_Helper {
  public:
    typedef SDOService_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SDOService, SDOService_Helper> SDOService_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SDOService,SDOService_Helper > SDOService_out;

#endif

#ifndef __SDOPackage_mSDOSystemElement__
#define __SDOPackage_mSDOSystemElement__

  class SDOSystemElement;
  class _objref_SDOSystemElement;
  class _impl_SDOSystemElement;
  
  typedef _objref_SDOSystemElement* SDOSystemElement_ptr;
  typedef SDOSystemElement_ptr SDOSystemElementRef;

  class SDOSystemElement_Helper {
  public:
    typedef SDOSystemElement_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SDOSystemElement, SDOSystemElement_Helper> SDOSystemElement_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SDOSystemElement,SDOSystemElement_Helper > SDOSystemElement_out;

#endif

#ifndef __SDOPackage_mConfiguration__
#define __SDOPackage_mConfiguration__

  class Configuration;
  class _objref_Configuration;
  class _impl_Configuration;
  
  typedef _objref_Configuration* Configuration_ptr;
  typedef Configuration_ptr ConfigurationRef;

  class Configuration_Helper {
  public:
    typedef Configuration_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Configuration, Configuration_Helper> Configuration_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Configuration,Configuration_Helper > Configuration_out;

#endif

#ifndef __SDOPackage_mMonitoring__
#define __SDOPackage_mMonitoring__

  class Monitoring;
  class _objref_Monitoring;
  class _impl_Monitoring;
  
  typedef _objref_Monitoring* Monitoring_ptr;
  typedef Monitoring_ptr MonitoringRef;

  class Monitoring_Helper {
  public:
    typedef Monitoring_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Monitoring, Monitoring_Helper> Monitoring_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Monitoring,Monitoring_Helper > Monitoring_out;

#endif

#ifndef __SDOPackage_mOrganization__
#define __SDOPackage_mOrganization__

  class Organization;
  class _objref_Organization;
  class _impl_Organization;
  
  typedef _objref_Organization* Organization_ptr;
  typedef Organization_ptr OrganizationRef;

  class Organization_Helper {
  public:
    typedef Organization_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Organization, Organization_Helper> Organization_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Organization,Organization_Helper > Organization_out;

#endif

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringList;

  class StringList_var;

  class StringList : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringList_var _var_type;
    inline StringList() {}
    inline StringList(const StringList& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringList& operator = (const StringList& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringList_out;

  class StringList_var {
  public:
    inline StringList_var() : _pd_seq(0) {}
    inline StringList_var(StringList* _s) : _pd_seq(_s) {}
    inline StringList_var(const StringList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new StringList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~StringList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline StringList_var& operator = (StringList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringList_var& operator = (const StringList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new StringList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringList* operator -> () { return _pd_seq; }
    inline const StringList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringList& () const { return *_pd_seq; }
#else
    inline operator const StringList& () const { return *_pd_seq; }
    inline operator StringList& () { return *_pd_seq; }
#endif
      
    inline const StringList& in() const { return *_pd_seq; }
    inline StringList&       inout()    { return *_pd_seq; }
    inline StringList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringList* _retn() { StringList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringList_out;
    
  private:
    StringList* _pd_seq;
  };

  class StringList_out {
  public:
    inline StringList_out(StringList*& _s) : _data(_s) { _data = 0; }
    inline StringList_out(StringList_var& _s)
      : _data(_s._pd_seq) { _s = (StringList*) 0; }
    inline StringList_out(const StringList_out& _s) : _data(_s._data) {}
    inline StringList_out& operator = (const StringList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringList_out& operator = (StringList* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringList*&()  { return _data; }
    inline StringList*& ptr()       { return _data; }
    inline StringList* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringList*& _data;

  private:
    StringList_out();
    StringList_out& operator=(const StringList_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SDOList;

  class SDOList_var;

  class SDOList : public _CORBA_Unbounded_Sequence_ObjRef< _objref_SDO, _CORBA_ObjRef_Element< _objref_SDO, SDO_Helper> , SDO_Helper >  {
  public:
    typedef SDOList_var _var_type;
    inline SDOList() {}
    inline SDOList(const SDOList& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_SDO, _CORBA_ObjRef_Element< _objref_SDO, SDO_Helper> , SDO_Helper > (_s) {}

    inline SDOList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_SDO, _CORBA_ObjRef_Element< _objref_SDO, SDO_Helper> , SDO_Helper > (_max) {}
    inline SDOList(_CORBA_ULong _max, _CORBA_ULong _len, SDO_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_SDO, _CORBA_ObjRef_Element< _objref_SDO, SDO_Helper> , SDO_Helper > (_max, _len, _val, _rel) {}

  

    inline SDOList& operator = (const SDOList& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_SDO, _CORBA_ObjRef_Element< _objref_SDO, SDO_Helper> , SDO_Helper > ::operator=(_s);
      return *this;
    }
  };

  class SDOList_out;

  class SDOList_var {
  public:
    inline SDOList_var() : _pd_seq(0) {}
    inline SDOList_var(SDOList* _s) : _pd_seq(_s) {}
    inline SDOList_var(const SDOList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new SDOList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~SDOList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline SDOList_var& operator = (SDOList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline SDOList_var& operator = (const SDOList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new SDOList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_SDO, SDO_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline SDOList* operator -> () { return _pd_seq; }
    inline const SDOList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator SDOList& () const { return *_pd_seq; }
#else
    inline operator const SDOList& () const { return *_pd_seq; }
    inline operator SDOList& () { return *_pd_seq; }
#endif
      
    inline const SDOList& in() const { return *_pd_seq; }
    inline SDOList&       inout()    { return *_pd_seq; }
    inline SDOList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline SDOList* _retn() { SDOList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class SDOList_out;
    
  private:
    SDOList* _pd_seq;
  };

  class SDOList_out {
  public:
    inline SDOList_out(SDOList*& _s) : _data(_s) { _data = 0; }
    inline SDOList_out(SDOList_var& _s)
      : _data(_s._pd_seq) { _s = (SDOList*) 0; }
    inline SDOList_out(const SDOList_out& _s) : _data(_s._data) {}
    inline SDOList_out& operator = (const SDOList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline SDOList_out& operator = (SDOList* _s) {
      _data = _s;
      return *this;
    }
    inline operator SDOList*&()  { return _data; }
    inline SDOList*& ptr()       { return _data; }
    inline SDOList* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_SDO, SDO_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    SDOList*& _data;

  private:
    SDOList_out();
    SDOList_out& operator=(const SDOList_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OrganizationList;

  class OrganizationList_var;

  class OrganizationList : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Organization, _CORBA_ObjRef_Element< _objref_Organization, Organization_Helper> , Organization_Helper >  {
  public:
    typedef OrganizationList_var _var_type;
    inline OrganizationList() {}
    inline OrganizationList(const OrganizationList& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Organization, _CORBA_ObjRef_Element< _objref_Organization, Organization_Helper> , Organization_Helper > (_s) {}

    inline OrganizationList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Organization, _CORBA_ObjRef_Element< _objref_Organization, Organization_Helper> , Organization_Helper > (_max) {}
    inline OrganizationList(_CORBA_ULong _max, _CORBA_ULong _len, Organization_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Organization, _CORBA_ObjRef_Element< _objref_Organization, Organization_Helper> , Organization_Helper > (_max, _len, _val, _rel) {}

  

    inline OrganizationList& operator = (const OrganizationList& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_Organization, _CORBA_ObjRef_Element< _objref_Organization, Organization_Helper> , Organization_Helper > ::operator=(_s);
      return *this;
    }
  };

  class OrganizationList_out;

  class OrganizationList_var {
  public:
    inline OrganizationList_var() : _pd_seq(0) {}
    inline OrganizationList_var(OrganizationList* _s) : _pd_seq(_s) {}
    inline OrganizationList_var(const OrganizationList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new OrganizationList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~OrganizationList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline OrganizationList_var& operator = (OrganizationList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline OrganizationList_var& operator = (const OrganizationList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new OrganizationList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_Organization, Organization_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline OrganizationList* operator -> () { return _pd_seq; }
    inline const OrganizationList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator OrganizationList& () const { return *_pd_seq; }
#else
    inline operator const OrganizationList& () const { return *_pd_seq; }
    inline operator OrganizationList& () { return *_pd_seq; }
#endif
      
    inline const OrganizationList& in() const { return *_pd_seq; }
    inline OrganizationList&       inout()    { return *_pd_seq; }
    inline OrganizationList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline OrganizationList* _retn() { OrganizationList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class OrganizationList_out;
    
  private:
    OrganizationList* _pd_seq;
  };

  class OrganizationList_out {
  public:
    inline OrganizationList_out(OrganizationList*& _s) : _data(_s) { _data = 0; }
    inline OrganizationList_out(OrganizationList_var& _s)
      : _data(_s._pd_seq) { _s = (OrganizationList*) 0; }
    inline OrganizationList_out(const OrganizationList_out& _s) : _data(_s._data) {}
    inline OrganizationList_out& operator = (const OrganizationList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline OrganizationList_out& operator = (OrganizationList* _s) {
      _data = _s;
      return *this;
    }
    inline operator OrganizationList*&()  { return _data; }
    inline OrganizationList*& ptr()       { return _data; }
    inline OrganizationList* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_Organization, Organization_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    OrganizationList*& _data;

  private:
    OrganizationList_out();
    OrganizationList_out& operator=(const OrganizationList_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UniqueIdentifier;

  typedef char* UniqueIdentifier;
  typedef ::CORBA::String_var UniqueIdentifier_var;
  typedef ::CORBA::String_out UniqueIdentifier_out;

  struct NameValue {
    typedef _CORBA_ConstrType_Variable_Var<NameValue> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::Any value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef NameValue::_var_type NameValue_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< NameValue,NameValue_var > NameValue_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NameValue;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NVList;

  class NVList_var;

  class NVList : public _CORBA_Unbounded_Sequence< NameValue >  {
  public:
    typedef NVList_var _var_type;
    inline NVList() {}
    inline NVList(const NVList& _s)
      : _CORBA_Unbounded_Sequence< NameValue > (_s) {}

    inline NVList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< NameValue > (_max) {}
    inline NVList(_CORBA_ULong _max, _CORBA_ULong _len, NameValue* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< NameValue > (_max, _len, _val, _rel) {}

  

    inline NVList& operator = (const NVList& _s) {
      _CORBA_Unbounded_Sequence< NameValue > ::operator=(_s);
      return *this;
    }
  };

  class NVList_out;

  class NVList_var {
  public:
    inline NVList_var() : _pd_seq(0) {}
    inline NVList_var(NVList* _s) : _pd_seq(_s) {}
    inline NVList_var(const NVList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new NVList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~NVList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline NVList_var& operator = (NVList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline NVList_var& operator = (const NVList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new NVList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline NameValue& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline NVList* operator -> () { return _pd_seq; }
    inline const NVList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator NVList& () const { return *_pd_seq; }
#else
    inline operator const NVList& () const { return *_pd_seq; }
    inline operator NVList& () { return *_pd_seq; }
#endif
      
    inline const NVList& in() const { return *_pd_seq; }
    inline NVList&       inout()    { return *_pd_seq; }
    inline NVList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline NVList* _retn() { NVList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class NVList_out;
    
  private:
    NVList* _pd_seq;
  };

  class NVList_out {
  public:
    inline NVList_out(NVList*& _s) : _data(_s) { _data = 0; }
    inline NVList_out(NVList_var& _s)
      : _data(_s._pd_seq) { _s = (NVList*) 0; }
    inline NVList_out(const NVList_out& _s) : _data(_s._data) {}
    inline NVList_out& operator = (const NVList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline NVList_out& operator = (NVList* _s) {
      _data = _s;
      return *this;
    }
    inline operator NVList*&()  { return _data; }
    inline NVList*& ptr()       { return _data; }
    inline NVList* operator->() { return _data; }

    inline NameValue& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    NVList*& _data;

  private:
    NVList_out();
    NVList_out& operator=(const NVList_var&);
  };

  enum NumericType { SHORT_TYPE, LONG_TYPE, FLOAT_TYPE, DOUBLE_TYPE /*, __max_NumericType=0xffffffff */ };
  typedef NumericType& NumericType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NumericType;

  class Numeric {
  public:

    typedef _CORBA_ConstrType_Fix_Var<Numeric> _var_type;

    

    Numeric(): _pd__initialised(0) {
      
    }
    
    Numeric(const Numeric& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case SHORT_TYPE: short_value(_value._pd_short_value); break;

        case LONG_TYPE: long_value(_value._pd_long_value); break;

        case FLOAT_TYPE: float_value(_value._pd_float_value); break;

        case DOUBLE_TYPE: double_value(_value._pd_double_value); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
    }

    ~Numeric() {}

    Numeric& operator=(const Numeric& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case SHORT_TYPE: short_value(_value._pd_short_value); break;

        case LONG_TYPE: long_value(_value._pd_long_value); break;

        case FLOAT_TYPE: float_value(_value._pd_float_value); break;

        case DOUBLE_TYPE: double_value(_value._pd_double_value); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
      return *this;
    }

    NumericType _d() const { return _pd__d;}
    void _d(NumericType _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case SHORT_TYPE: goto fail;
        case LONG_TYPE: goto fail;
        case FLOAT_TYPE: goto fail;
        case DOUBLE_TYPE: goto fail;
        default: goto fail;

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    

    ::CORBA::Short short_value () const { return _pd_short_value; }
    void short_value (::CORBA::Short  _value) {
      _pd__initialised = 1;
      _pd__d = SHORT_TYPE;
      _pd__default = 0;
      _pd_short_value = _value;
    }

    ::CORBA::Long long_value () const { return _pd_long_value; }
    void long_value (::CORBA::Long  _value) {
      _pd__initialised = 1;
      _pd__d = LONG_TYPE;
      _pd__default = 0;
      _pd_long_value = _value;
    }

    ::CORBA::Float float_value () const { return _pd_float_value; }
    void float_value (::CORBA::Float  _value) {
      _pd__initialised = 1;
      _pd__d = FLOAT_TYPE;
      _pd__default = 0;
      _pd_float_value = _value;
    }

    ::CORBA::Double double_value () const { return _pd_double_value; }
    void double_value (::CORBA::Double  _value) {
      _pd__initialised = 1;
      _pd__d = DOUBLE_TYPE;
      _pd__default = 0;
      _pd_double_value = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    NumericType _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    union {
      ::CORBA::Short _pd_short_value;

      ::CORBA::Long _pd_long_value;


#ifndef USING_PROXY_FLOAT
        ::CORBA::Float _pd_float_value;
#endif


#ifndef USING_PROXY_FLOAT
        ::CORBA::Double _pd_double_value;
#endif


    };

  
    
#ifdef USING_PROXY_FLOAT
      ::CORBA::Float _pd_float_value;
#endif


#ifdef USING_PROXY_FLOAT
      ::CORBA::Double _pd_double_value;
#endif

  
  };

  typedef Numeric::_var_type Numeric_var;

  typedef Numeric& Numeric_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Numeric;

  struct EnumerationType {
    typedef _CORBA_ConstrType_Variable_Var<EnumerationType> _var_type;

    
    StringList enumerated_values;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EnumerationType::_var_type EnumerationType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< EnumerationType,EnumerationType_var > EnumerationType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EnumerationType;

  struct RangeType {
    typedef _CORBA_ConstrType_Fix_Var<RangeType> _var_type;

    
    Numeric min;

    Numeric max;

    ::CORBA::Boolean min_inclusive;

    ::CORBA::Boolean max_inclusive;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RangeType::_var_type RangeType_var;

  typedef RangeType& RangeType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RangeType;

  struct IntervalType {
    typedef _CORBA_ConstrType_Fix_Var<IntervalType> _var_type;

    
    Numeric min;

    Numeric max;

    ::CORBA::Boolean min_inclusive;

    ::CORBA::Boolean max_inclusive;

    Numeric step;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef IntervalType::_var_type IntervalType_var;

  typedef IntervalType& IntervalType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IntervalType;

  enum ComplexDataType { ENUMERATION, RANGE, INTERVAL /*, __max_ComplexDataType=0xffffffff */ };
  typedef ComplexDataType& ComplexDataType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComplexDataType;

  class AllowedValues {
  public:

    typedef _CORBA_ConstrType_Variable_Var<AllowedValues> _var_type;

    

    AllowedValues(): _pd__initialised(0) {
      
    }
    
    AllowedValues(const AllowedValues& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ENUMERATION: allowed_enum(_value._pd_allowed_enum); break;

        case INTERVAL: allowed_interval(_value._pd_allowed_interval); break;

        case RANGE: allowed_range(_value._pd_allowed_range); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
    }

    ~AllowedValues() {}

    AllowedValues& operator=(const AllowedValues& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ENUMERATION: allowed_enum(_value._pd_allowed_enum); break;

        case INTERVAL: allowed_interval(_value._pd_allowed_interval); break;

        case RANGE: allowed_range(_value._pd_allowed_range); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
      return *this;
    }

    ComplexDataType _d() const { return _pd__d;}
    void _d(ComplexDataType _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case ENUMERATION: goto fail;
        case INTERVAL: goto fail;
        case RANGE: goto fail;
        default: goto fail;

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    

    const EnumerationType &allowed_enum () const { return _pd_allowed_enum; }
    EnumerationType &allowed_enum () { return _pd_allowed_enum; }
    void allowed_enum (const EnumerationType& _value) {
      _pd__initialised = 1;
      _pd__d = ENUMERATION;
      _pd__default = 0;
      _pd_allowed_enum = _value;
    }

    const IntervalType &allowed_interval () const { return _pd_allowed_interval; }
    IntervalType &allowed_interval () { return _pd_allowed_interval; }
    void allowed_interval (const IntervalType& _value) {
      _pd__initialised = 1;
      _pd__d = INTERVAL;
      _pd__default = 0;
      _pd_allowed_interval = _value;
    }

    const RangeType &allowed_range () const { return _pd_allowed_range; }
    RangeType &allowed_range () { return _pd_allowed_range; }
    void allowed_range (const RangeType& _value) {
      _pd__initialised = 1;
      _pd__d = RANGE;
      _pd__default = 0;
      _pd_allowed_range = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    ComplexDataType _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    
    EnumerationType _pd_allowed_enum;

    IntervalType _pd_allowed_interval;

    RangeType _pd_allowed_range;

  
  };

  typedef AllowedValues::_var_type AllowedValues_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< AllowedValues,AllowedValues_var > AllowedValues_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllowedValues;

  struct Parameter {
    typedef _CORBA_ConstrType_Variable_Var<Parameter> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::TypeCode_member type;

    AllowedValues allowed_values;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Parameter::_var_type Parameter_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Parameter,Parameter_var > Parameter_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Parameter;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ParameterList;

  class ParameterList_var;

  class ParameterList : public _CORBA_Unbounded_Sequence< Parameter >  {
  public:
    typedef ParameterList_var _var_type;
    inline ParameterList() {}
    inline ParameterList(const ParameterList& _s)
      : _CORBA_Unbounded_Sequence< Parameter > (_s) {}

    inline ParameterList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Parameter > (_max) {}
    inline ParameterList(_CORBA_ULong _max, _CORBA_ULong _len, Parameter* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Parameter > (_max, _len, _val, _rel) {}

  

    inline ParameterList& operator = (const ParameterList& _s) {
      _CORBA_Unbounded_Sequence< Parameter > ::operator=(_s);
      return *this;
    }
  };

  class ParameterList_out;

  class ParameterList_var {
  public:
    inline ParameterList_var() : _pd_seq(0) {}
    inline ParameterList_var(ParameterList* _s) : _pd_seq(_s) {}
    inline ParameterList_var(const ParameterList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ParameterList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ParameterList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ParameterList_var& operator = (ParameterList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ParameterList_var& operator = (const ParameterList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ParameterList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Parameter& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ParameterList* operator -> () { return _pd_seq; }
    inline const ParameterList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ParameterList& () const { return *_pd_seq; }
#else
    inline operator const ParameterList& () const { return *_pd_seq; }
    inline operator ParameterList& () { return *_pd_seq; }
#endif
      
    inline const ParameterList& in() const { return *_pd_seq; }
    inline ParameterList&       inout()    { return *_pd_seq; }
    inline ParameterList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ParameterList* _retn() { ParameterList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ParameterList_out;
    
  private:
    ParameterList* _pd_seq;
  };

  class ParameterList_out {
  public:
    inline ParameterList_out(ParameterList*& _s) : _data(_s) { _data = 0; }
    inline ParameterList_out(ParameterList_var& _s)
      : _data(_s._pd_seq) { _s = (ParameterList*) 0; }
    inline ParameterList_out(const ParameterList_out& _s) : _data(_s._data) {}
    inline ParameterList_out& operator = (const ParameterList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ParameterList_out& operator = (ParameterList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ParameterList*&()  { return _data; }
    inline ParameterList*& ptr()       { return _data; }
    inline ParameterList* operator->() { return _data; }

    inline Parameter& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ParameterList*& _data;

  private:
    ParameterList_out();
    ParameterList_out& operator=(const ParameterList_var&);
  };

  struct OrganizationProperty {
    typedef _CORBA_ConstrType_Variable_Var<OrganizationProperty> _var_type;

    
    NVList properties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef OrganizationProperty::_var_type OrganizationProperty_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< OrganizationProperty,OrganizationProperty_var > OrganizationProperty_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OrganizationProperty;

  enum DependencyType { OWN, OWNED, NO_DEPENDENCY /*, __max_DependencyType=0xffffffff */ };
  typedef DependencyType& DependencyType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DependencyType;

  struct DeviceProfile {
    typedef _CORBA_ConstrType_Variable_Var<DeviceProfile> _var_type;

    
    ::CORBA::String_member device_type;

    ::CORBA::String_member manufacturer;

    ::CORBA::String_member model;

    ::CORBA::String_member version;

    NVList properties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DeviceProfile::_var_type DeviceProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< DeviceProfile,DeviceProfile_var > DeviceProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceProfile;

  struct ServiceProfile {
    typedef _CORBA_ConstrType_Variable_Var<ServiceProfile> _var_type;

    
    ::CORBA::String_member id;

    ::CORBA::String_member interface_type;

    NVList properties;

    _CORBA_ObjRef_Member< _objref_SDOService, SDOService_Helper>  service;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServiceProfile::_var_type ServiceProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServiceProfile,ServiceProfile_var > ServiceProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ServiceProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ServiceProfileList;

  class ServiceProfileList_var;

  class ServiceProfileList : public _CORBA_Unbounded_Sequence< ServiceProfile >  {
  public:
    typedef ServiceProfileList_var _var_type;
    inline ServiceProfileList() {}
    inline ServiceProfileList(const ServiceProfileList& _s)
      : _CORBA_Unbounded_Sequence< ServiceProfile > (_s) {}

    inline ServiceProfileList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ServiceProfile > (_max) {}
    inline ServiceProfileList(_CORBA_ULong _max, _CORBA_ULong _len, ServiceProfile* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ServiceProfile > (_max, _len, _val, _rel) {}

  

    inline ServiceProfileList& operator = (const ServiceProfileList& _s) {
      _CORBA_Unbounded_Sequence< ServiceProfile > ::operator=(_s);
      return *this;
    }
  };

  class ServiceProfileList_out;

  class ServiceProfileList_var {
  public:
    inline ServiceProfileList_var() : _pd_seq(0) {}
    inline ServiceProfileList_var(ServiceProfileList* _s) : _pd_seq(_s) {}
    inline ServiceProfileList_var(const ServiceProfileList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ServiceProfileList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ServiceProfileList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ServiceProfileList_var& operator = (ServiceProfileList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ServiceProfileList_var& operator = (const ServiceProfileList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ServiceProfileList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ServiceProfile& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ServiceProfileList* operator -> () { return _pd_seq; }
    inline const ServiceProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ServiceProfileList& () const { return *_pd_seq; }
#else
    inline operator const ServiceProfileList& () const { return *_pd_seq; }
    inline operator ServiceProfileList& () { return *_pd_seq; }
#endif
      
    inline const ServiceProfileList& in() const { return *_pd_seq; }
    inline ServiceProfileList&       inout()    { return *_pd_seq; }
    inline ServiceProfileList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ServiceProfileList* _retn() { ServiceProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ServiceProfileList_out;
    
  private:
    ServiceProfileList* _pd_seq;
  };

  class ServiceProfileList_out {
  public:
    inline ServiceProfileList_out(ServiceProfileList*& _s) : _data(_s) { _data = 0; }
    inline ServiceProfileList_out(ServiceProfileList_var& _s)
      : _data(_s._pd_seq) { _s = (ServiceProfileList*) 0; }
    inline ServiceProfileList_out(const ServiceProfileList_out& _s) : _data(_s._data) {}
    inline ServiceProfileList_out& operator = (const ServiceProfileList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ServiceProfileList_out& operator = (ServiceProfileList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ServiceProfileList*&()  { return _data; }
    inline ServiceProfileList*& ptr()       { return _data; }
    inline ServiceProfileList* operator->() { return _data; }

    inline ServiceProfile& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ServiceProfileList*& _data;

  private:
    ServiceProfileList_out();
    ServiceProfileList_out& operator=(const ServiceProfileList_var&);
  };

  struct ConfigurationSet {
    typedef _CORBA_ConstrType_Variable_Var<ConfigurationSet> _var_type;

    
    ::CORBA::String_member id;

    ::CORBA::String_member description;

    NVList configuration_data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ConfigurationSet::_var_type ConfigurationSet_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ConfigurationSet,ConfigurationSet_var > ConfigurationSet_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConfigurationSet;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConfigurationSetList;

  class ConfigurationSetList_var;

  class ConfigurationSetList : public _CORBA_Unbounded_Sequence< ConfigurationSet >  {
  public:
    typedef ConfigurationSetList_var _var_type;
    inline ConfigurationSetList() {}
    inline ConfigurationSetList(const ConfigurationSetList& _s)
      : _CORBA_Unbounded_Sequence< ConfigurationSet > (_s) {}

    inline ConfigurationSetList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ConfigurationSet > (_max) {}
    inline ConfigurationSetList(_CORBA_ULong _max, _CORBA_ULong _len, ConfigurationSet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ConfigurationSet > (_max, _len, _val, _rel) {}

  

    inline ConfigurationSetList& operator = (const ConfigurationSetList& _s) {
      _CORBA_Unbounded_Sequence< ConfigurationSet > ::operator=(_s);
      return *this;
    }
  };

  class ConfigurationSetList_out;

  class ConfigurationSetList_var {
  public:
    inline ConfigurationSetList_var() : _pd_seq(0) {}
    inline ConfigurationSetList_var(ConfigurationSetList* _s) : _pd_seq(_s) {}
    inline ConfigurationSetList_var(const ConfigurationSetList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ConfigurationSetList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ConfigurationSetList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ConfigurationSetList_var& operator = (ConfigurationSetList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ConfigurationSetList_var& operator = (const ConfigurationSetList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ConfigurationSetList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ConfigurationSet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ConfigurationSetList* operator -> () { return _pd_seq; }
    inline const ConfigurationSetList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ConfigurationSetList& () const { return *_pd_seq; }
#else
    inline operator const ConfigurationSetList& () const { return *_pd_seq; }
    inline operator ConfigurationSetList& () { return *_pd_seq; }
#endif
      
    inline const ConfigurationSetList& in() const { return *_pd_seq; }
    inline ConfigurationSetList&       inout()    { return *_pd_seq; }
    inline ConfigurationSetList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ConfigurationSetList* _retn() { ConfigurationSetList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ConfigurationSetList_out;
    
  private:
    ConfigurationSetList* _pd_seq;
  };

  class ConfigurationSetList_out {
  public:
    inline ConfigurationSetList_out(ConfigurationSetList*& _s) : _data(_s) { _data = 0; }
    inline ConfigurationSetList_out(ConfigurationSetList_var& _s)
      : _data(_s._pd_seq) { _s = (ConfigurationSetList*) 0; }
    inline ConfigurationSetList_out(const ConfigurationSetList_out& _s) : _data(_s._data) {}
    inline ConfigurationSetList_out& operator = (const ConfigurationSetList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ConfigurationSetList_out& operator = (ConfigurationSetList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ConfigurationSetList*&()  { return _data; }
    inline ConfigurationSetList*& ptr()       { return _data; }
    inline ConfigurationSetList* operator->() { return _data; }

    inline ConfigurationSet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ConfigurationSetList*& _data;

  private:
    ConfigurationSetList_out();
    ConfigurationSetList_out& operator=(const ConfigurationSetList_var&);
  };

  class NotAvailable : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member description;

  

    inline NotAvailable() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    NotAvailable(const NotAvailable&);
    NotAvailable(const char* i_description);
    NotAvailable& operator=(const NotAvailable&);
    virtual ~NotAvailable();
    virtual void _raise() const;
    static NotAvailable* _downcast(::CORBA::Exception*);
    static const NotAvailable* _downcast(const ::CORBA::Exception*);
    static inline NotAvailable* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NotAvailable;

  class InterfaceNotImplemented : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member description;

  

    inline InterfaceNotImplemented() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InterfaceNotImplemented(const InterfaceNotImplemented&);
    InterfaceNotImplemented(const char* i_description);
    InterfaceNotImplemented& operator=(const InterfaceNotImplemented&);
    virtual ~InterfaceNotImplemented();
    virtual void _raise() const;
    static InterfaceNotImplemented* _downcast(::CORBA::Exception*);
    static const InterfaceNotImplemented* _downcast(const ::CORBA::Exception*);
    static inline InterfaceNotImplemented* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InterfaceNotImplemented;

  class InvalidParameter : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member description;

  

    inline InvalidParameter() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidParameter(const InvalidParameter&);
    InvalidParameter(const char* i_description);
    InvalidParameter& operator=(const InvalidParameter&);
    virtual ~InvalidParameter();
    virtual void _raise() const;
    static InvalidParameter* _downcast(::CORBA::Exception*);
    static const InvalidParameter* _downcast(const ::CORBA::Exception*);
    static inline InvalidParameter* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidParameter;

  class InternalError : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member description;

  

    inline InternalError() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InternalError(const InternalError&);
    InternalError(const char* i_description);
    InternalError& operator=(const InternalError&);
    virtual ~InternalError();
    virtual void _raise() const;
    static InternalError* _downcast(::CORBA::Exception*);
    static const InternalError* _downcast(const ::CORBA::Exception*);
    static inline InternalError* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InternalError;

#ifndef __SDOPackage_mSDOSystemElement__
#define __SDOPackage_mSDOSystemElement__

  class SDOSystemElement;
  class _objref_SDOSystemElement;
  class _impl_SDOSystemElement;
  
  typedef _objref_SDOSystemElement* SDOSystemElement_ptr;
  typedef SDOSystemElement_ptr SDOSystemElementRef;

  class SDOSystemElement_Helper {
  public:
    typedef SDOSystemElement_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SDOSystemElement, SDOSystemElement_Helper> SDOSystemElement_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SDOSystemElement,SDOSystemElement_Helper > SDOSystemElement_out;

#endif

  // interface SDOSystemElement
  class SDOSystemElement {
  public:
    // Declarations for this interface type.
    typedef SDOSystemElement_ptr _ptr_type;
    typedef SDOSystemElement_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SDOSystemElement :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    OrganizationList* get_owned_organizations();

    inline _objref_SDOSystemElement()  { _PR_setobj(0); }  // nil
    _objref_SDOSystemElement(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SDOSystemElement();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SDOSystemElement(const _objref_SDOSystemElement&);
    _objref_SDOSystemElement& operator = (const _objref_SDOSystemElement&);
    // not implemented

    friend class SDOSystemElement;
  };

  class _pof_SDOSystemElement : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SDOSystemElement() : _OMNI_NS(proxyObjectFactory)(SDOSystemElement::_PD_repoId) {}
    virtual ~_pof_SDOSystemElement();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SDOSystemElement :
    public virtual omniServant
  {
  public:
    virtual ~_impl_SDOSystemElement();

    virtual OrganizationList* get_owned_organizations() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SDOSystemElement;

#ifndef __SDOPackage_mSDO__
#define __SDOPackage_mSDO__

  class SDO;
  class _objref_SDO;
  class _impl_SDO;
  
  typedef _objref_SDO* SDO_ptr;
  typedef SDO_ptr SDORef;

  class SDO_Helper {
  public:
    typedef SDO_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SDO, SDO_Helper> SDO_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SDO,SDO_Helper > SDO_out;

#endif

  // interface SDO
  class SDO {
  public:
    // Declarations for this interface type.
    typedef SDO_ptr _ptr_type;
    typedef SDO_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SDO :
    public virtual _objref_SDOSystemElement
  {
  public:
    char* get_sdo_id();
    char* get_sdo_type();
    DeviceProfile* get_device_profile();
    ServiceProfileList* get_service_profiles();
    ServiceProfile* get_service_profile(const char* id);
    SDOService_ptr get_sdo_service(const char* id);
    Configuration_ptr get_configuration();
    Monitoring_ptr get_monitoring();
    OrganizationList* get_organizations();
    NVList* get_status_list();
    ::CORBA::Any* get_status(const char* nme);

    inline _objref_SDO()  { _PR_setobj(0); }  // nil
    _objref_SDO(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SDO();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SDO(const _objref_SDO&);
    _objref_SDO& operator = (const _objref_SDO&);
    // not implemented

    friend class SDO;
  };

  class _pof_SDO : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SDO() : _OMNI_NS(proxyObjectFactory)(SDO::_PD_repoId) {}
    virtual ~_pof_SDO();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SDO :
    public virtual _impl_SDOSystemElement
  {
  public:
    virtual ~_impl_SDO();

    virtual char* get_sdo_id() = 0;
    virtual char* get_sdo_type() = 0;
    virtual DeviceProfile* get_device_profile() = 0;
    virtual ServiceProfileList* get_service_profiles() = 0;
    virtual ServiceProfile* get_service_profile(const char* id) = 0;
    virtual SDOService_ptr get_sdo_service(const char* id) = 0;
    virtual Configuration_ptr get_configuration() = 0;
    virtual Monitoring_ptr get_monitoring() = 0;
    virtual OrganizationList* get_organizations() = 0;
    virtual NVList* get_status_list() = 0;
    virtual ::CORBA::Any* get_status(const char* nme) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SDO;

#ifndef __SDOPackage_mConfiguration__
#define __SDOPackage_mConfiguration__

  class Configuration;
  class _objref_Configuration;
  class _impl_Configuration;
  
  typedef _objref_Configuration* Configuration_ptr;
  typedef Configuration_ptr ConfigurationRef;

  class Configuration_Helper {
  public:
    typedef Configuration_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Configuration, Configuration_Helper> Configuration_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Configuration,Configuration_Helper > Configuration_out;

#endif

  // interface Configuration
  class Configuration {
  public:
    // Declarations for this interface type.
    typedef Configuration_ptr _ptr_type;
    typedef Configuration_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Configuration :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean set_device_profile(const ::SDOPackage::DeviceProfile& dProfile);
    ::CORBA::Boolean add_service_profile(const ::SDOPackage::ServiceProfile& sProfile);
    ::CORBA::Boolean add_organization(::SDOPackage::Organization_ptr organization_object);
    ::CORBA::Boolean remove_service_profile(const char* id);
    ::CORBA::Boolean remove_organization(const char* organization_id);
    ParameterList* get_configuration_parameters();
    NVList* get_configuration_parameter_values();
    ::CORBA::Any* get_configuration_parameter_value(const char* name);
    ::CORBA::Boolean set_configuration_parameter(const char* name, const ::CORBA::Any& value);
    ConfigurationSetList* get_configuration_sets();
    ConfigurationSet* get_configuration_set(const char* config_id);
    ::CORBA::Boolean set_configuration_set_values(const ::SDOPackage::ConfigurationSet& configuration_set);
    ConfigurationSet* get_active_configuration_set();
    ::CORBA::Boolean add_configuration_set(const ::SDOPackage::ConfigurationSet& configuration_set);
    ::CORBA::Boolean remove_configuration_set(const char* config_id);
    ::CORBA::Boolean activate_configuration_set(const char* config_id);

    inline _objref_Configuration()  { _PR_setobj(0); }  // nil
    _objref_Configuration(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Configuration();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Configuration(const _objref_Configuration&);
    _objref_Configuration& operator = (const _objref_Configuration&);
    // not implemented

    friend class Configuration;
  };

  class _pof_Configuration : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Configuration() : _OMNI_NS(proxyObjectFactory)(Configuration::_PD_repoId) {}
    virtual ~_pof_Configuration();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Configuration :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Configuration();

    virtual ::CORBA::Boolean set_device_profile(const ::SDOPackage::DeviceProfile& dProfile) = 0;
    virtual ::CORBA::Boolean add_service_profile(const ::SDOPackage::ServiceProfile& sProfile) = 0;
    virtual ::CORBA::Boolean add_organization(::SDOPackage::Organization_ptr organization_object) = 0;
    virtual ::CORBA::Boolean remove_service_profile(const char* id) = 0;
    virtual ::CORBA::Boolean remove_organization(const char* organization_id) = 0;
    virtual ParameterList* get_configuration_parameters() = 0;
    virtual NVList* get_configuration_parameter_values() = 0;
    virtual ::CORBA::Any* get_configuration_parameter_value(const char* name) = 0;
    virtual ::CORBA::Boolean set_configuration_parameter(const char* name, const ::CORBA::Any& value) = 0;
    virtual ConfigurationSetList* get_configuration_sets() = 0;
    virtual ConfigurationSet* get_configuration_set(const char* config_id) = 0;
    virtual ::CORBA::Boolean set_configuration_set_values(const ::SDOPackage::ConfigurationSet& configuration_set) = 0;
    virtual ConfigurationSet* get_active_configuration_set() = 0;
    virtual ::CORBA::Boolean add_configuration_set(const ::SDOPackage::ConfigurationSet& configuration_set) = 0;
    virtual ::CORBA::Boolean remove_configuration_set(const char* config_id) = 0;
    virtual ::CORBA::Boolean activate_configuration_set(const char* config_id) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Configuration;

#ifndef __SDOPackage_mMonitoring__
#define __SDOPackage_mMonitoring__

  class Monitoring;
  class _objref_Monitoring;
  class _impl_Monitoring;
  
  typedef _objref_Monitoring* Monitoring_ptr;
  typedef Monitoring_ptr MonitoringRef;

  class Monitoring_Helper {
  public:
    typedef Monitoring_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Monitoring, Monitoring_Helper> Monitoring_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Monitoring,Monitoring_Helper > Monitoring_out;

#endif

  // interface Monitoring
  class Monitoring {
  public:
    // Declarations for this interface type.
    typedef Monitoring_ptr _ptr_type;
    typedef Monitoring_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Monitoring :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    

    inline _objref_Monitoring()  { _PR_setobj(0); }  // nil
    _objref_Monitoring(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Monitoring();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Monitoring(const _objref_Monitoring&);
    _objref_Monitoring& operator = (const _objref_Monitoring&);
    // not implemented

    friend class Monitoring;
  };

  class _pof_Monitoring : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Monitoring() : _OMNI_NS(proxyObjectFactory)(Monitoring::_PD_repoId) {}
    virtual ~_pof_Monitoring();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Monitoring :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Monitoring();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Monitoring;

#ifndef __SDOPackage_mSDOService__
#define __SDOPackage_mSDOService__

  class SDOService;
  class _objref_SDOService;
  class _impl_SDOService;
  
  typedef _objref_SDOService* SDOService_ptr;
  typedef SDOService_ptr SDOServiceRef;

  class SDOService_Helper {
  public:
    typedef SDOService_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SDOService, SDOService_Helper> SDOService_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SDOService,SDOService_Helper > SDOService_out;

#endif

  // interface SDOService
  class SDOService {
  public:
    // Declarations for this interface type.
    typedef SDOService_ptr _ptr_type;
    typedef SDOService_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SDOService :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    

    inline _objref_SDOService()  { _PR_setobj(0); }  // nil
    _objref_SDOService(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SDOService();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SDOService(const _objref_SDOService&);
    _objref_SDOService& operator = (const _objref_SDOService&);
    // not implemented

    friend class SDOService;
  };

  class _pof_SDOService : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SDOService() : _OMNI_NS(proxyObjectFactory)(SDOService::_PD_repoId) {}
    virtual ~_pof_SDOService();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SDOService :
    public virtual omniServant
  {
  public:
    virtual ~_impl_SDOService();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SDOService;

#ifndef __SDOPackage_mOrganization__
#define __SDOPackage_mOrganization__

  class Organization;
  class _objref_Organization;
  class _impl_Organization;
  
  typedef _objref_Organization* Organization_ptr;
  typedef Organization_ptr OrganizationRef;

  class Organization_Helper {
  public:
    typedef Organization_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Organization, Organization_Helper> Organization_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Organization,Organization_Helper > Organization_out;

#endif

  // interface Organization
  class Organization {
  public:
    // Declarations for this interface type.
    typedef Organization_ptr _ptr_type;
    typedef Organization_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Organization :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    char* get_organization_id();
    OrganizationProperty* get_organization_property();
    ::CORBA::Any* get_organization_property_value(const char* name);
    ::CORBA::Boolean add_organization_property(const ::SDOPackage::OrganizationProperty& organization_property);
    ::CORBA::Boolean set_organization_property_value(const char* name, const ::CORBA::Any& value);
    ::CORBA::Boolean remove_organization_property(const char* name);
    SDOSystemElement_ptr get_owner();
    ::CORBA::Boolean set_owner(::SDOPackage::SDOSystemElement_ptr sdo);
    SDOList* get_members();
    ::CORBA::Boolean set_members(const ::SDOPackage::SDOList& sdos);
    ::CORBA::Boolean add_members(const ::SDOPackage::SDOList& sdo_list);
    ::CORBA::Boolean remove_member(const char* id);
    DependencyType get_dependency();
    ::CORBA::Boolean set_dependency(::SDOPackage::DependencyType dependency);

    inline _objref_Organization()  { _PR_setobj(0); }  // nil
    _objref_Organization(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Organization();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Organization(const _objref_Organization&);
    _objref_Organization& operator = (const _objref_Organization&);
    // not implemented

    friend class Organization;
  };

  class _pof_Organization : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Organization() : _OMNI_NS(proxyObjectFactory)(Organization::_PD_repoId) {}
    virtual ~_pof_Organization();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Organization :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Organization();

    virtual char* get_organization_id() = 0;
    virtual OrganizationProperty* get_organization_property() = 0;
    virtual ::CORBA::Any* get_organization_property_value(const char* name) = 0;
    virtual ::CORBA::Boolean add_organization_property(const ::SDOPackage::OrganizationProperty& organization_property) = 0;
    virtual ::CORBA::Boolean set_organization_property_value(const char* name, const ::CORBA::Any& value) = 0;
    virtual ::CORBA::Boolean remove_organization_property(const char* name) = 0;
    virtual SDOSystemElement_ptr get_owner() = 0;
    virtual ::CORBA::Boolean set_owner(::SDOPackage::SDOSystemElement_ptr sdo) = 0;
    virtual SDOList* get_members() = 0;
    virtual ::CORBA::Boolean set_members(const ::SDOPackage::SDOList& sdos) = 0;
    virtual ::CORBA::Boolean add_members(const ::SDOPackage::SDOList& sdo_list) = 0;
    virtual ::CORBA::Boolean remove_member(const char* id) = 0;
    virtual DependencyType get_dependency() = 0;
    virtual ::CORBA::Boolean set_dependency(::SDOPackage::DependencyType dependency) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Organization;

_CORBA_MODULE_END



_CORBA_MODULE POA_SDOPackage
_CORBA_MODULE_BEG

  class SDOSystemElement :
    public virtual SDOPackage::_impl_SDOSystemElement,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~SDOSystemElement();

    inline ::SDOPackage::SDOSystemElement_ptr _this() {
      return (::SDOPackage::SDOSystemElement_ptr) _do_this(::SDOPackage::SDOSystemElement::_PD_repoId);
    }
  };

  class SDO :
    public virtual SDOPackage::_impl_SDO,
    public virtual SDOSystemElement
  {
  public:
    virtual ~SDO();

    inline ::SDOPackage::SDO_ptr _this() {
      return (::SDOPackage::SDO_ptr) _do_this(::SDOPackage::SDO::_PD_repoId);
    }
  };

  class Configuration :
    public virtual SDOPackage::_impl_Configuration,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Configuration();

    inline ::SDOPackage::Configuration_ptr _this() {
      return (::SDOPackage::Configuration_ptr) _do_this(::SDOPackage::Configuration::_PD_repoId);
    }
  };

  class Monitoring :
    public virtual SDOPackage::_impl_Monitoring,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Monitoring();

    inline ::SDOPackage::Monitoring_ptr _this() {
      return (::SDOPackage::Monitoring_ptr) _do_this(::SDOPackage::Monitoring::_PD_repoId);
    }
  };

  class SDOService :
    public virtual SDOPackage::_impl_SDOService,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~SDOService();

    inline ::SDOPackage::SDOService_ptr _this() {
      return (::SDOPackage::SDOService_ptr) _do_this(::SDOPackage::SDOService::_PD_repoId);
    }
  };

  class Organization :
    public virtual SDOPackage::_impl_Organization,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Organization();

    inline ::SDOPackage::Organization_ptr _this() {
      return (::SDOPackage::Organization_ptr) _do_this(::SDOPackage::Organization::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_SDOPackage
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const SDOPackage::StringList& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::StringList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::StringList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::StringList*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::SDOList& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::SDOList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDOList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::SDOList*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::OrganizationList& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::OrganizationList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::OrganizationList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::OrganizationList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::NameValue& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::NameValue* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::NameValue*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::NameValue*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::NVList& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::NVList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::NVList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::NVList*& _sp);

inline void operator >>=(SDOPackage::NumericType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (SDOPackage::NumericType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= SDOPackage::DOUBLE_TYPE) {
    _e = (SDOPackage::NumericType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, SDOPackage::NumericType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::NumericType& _s);

void operator<<=(::CORBA::Any& _a, const SDOPackage::Numeric& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::Numeric* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::Numeric*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Numeric*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::EnumerationType& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::EnumerationType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::EnumerationType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::EnumerationType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::RangeType& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::RangeType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::RangeType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::RangeType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::IntervalType& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::IntervalType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::IntervalType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::IntervalType*& _sp);

inline void operator >>=(SDOPackage::ComplexDataType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (SDOPackage::ComplexDataType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= SDOPackage::INTERVAL) {
    _e = (SDOPackage::ComplexDataType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, SDOPackage::ComplexDataType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ComplexDataType& _s);

void operator<<=(::CORBA::Any& _a, const SDOPackage::AllowedValues& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::AllowedValues* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::AllowedValues*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::AllowedValues*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::Parameter& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::Parameter* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Parameter*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::Parameter*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::ParameterList& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::ParameterList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ParameterList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ParameterList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::OrganizationProperty& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::OrganizationProperty* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::OrganizationProperty*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::OrganizationProperty*& _sp);

inline void operator >>=(SDOPackage::DependencyType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (SDOPackage::DependencyType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= SDOPackage::NO_DEPENDENCY) {
    _e = (SDOPackage::DependencyType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, SDOPackage::DependencyType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::DependencyType& _s);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::DeviceProfile& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::DeviceProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::DeviceProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::DeviceProfile*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::ServiceProfile& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::ServiceProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ServiceProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ServiceProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::ServiceProfileList& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::ServiceProfileList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ServiceProfileList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ServiceProfileList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const SDOPackage::ConfigurationSet& _s);
extern void operator<<=(::CORBA::Any& _a, SDOPackage::ConfigurationSet* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ConfigurationSet*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ConfigurationSet*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::ConfigurationSetList& _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::ConfigurationSetList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ConfigurationSetList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ConfigurationSetList*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::NotAvailable& _s);
void operator<<=(::CORBA::Any& _a, const SDOPackage::NotAvailable* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::NotAvailable*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::InterfaceNotImplemented& _s);
void operator<<=(::CORBA::Any& _a, const SDOPackage::InterfaceNotImplemented* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::InterfaceNotImplemented*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::InvalidParameter& _s);
void operator<<=(::CORBA::Any& _a, const SDOPackage::InvalidParameter* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::InvalidParameter*& _sp);

void operator<<=(::CORBA::Any& _a, const SDOPackage::InternalError& _s);
void operator<<=(::CORBA::Any& _a, const SDOPackage::InternalError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::InternalError*& _sp);

void operator<<=(::CORBA::Any& _a, SDOPackage::SDOSystemElement_ptr _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::SDOSystemElement_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDOSystemElement_ptr& _s);

void operator<<=(::CORBA::Any& _a, SDOPackage::SDO_ptr _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::SDO_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDO_ptr& _s);

void operator<<=(::CORBA::Any& _a, SDOPackage::Configuration_ptr _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::Configuration_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Configuration_ptr& _s);

void operator<<=(::CORBA::Any& _a, SDOPackage::Monitoring_ptr _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::Monitoring_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Monitoring_ptr& _s);

void operator<<=(::CORBA::Any& _a, SDOPackage::SDOService_ptr _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::SDOService_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDOService_ptr& _s);

void operator<<=(::CORBA::Any& _a, SDOPackage::Organization_ptr _s);
void operator<<=(::CORBA::Any& _a, SDOPackage::Organization_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Organization_ptr& _s);



inline void
SDOPackage::SDOSystemElement::_marshalObjRef(::SDOPackage::SDOSystemElement_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
SDOPackage::SDO::_marshalObjRef(::SDOPackage::SDO_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
SDOPackage::Configuration::_marshalObjRef(::SDOPackage::Configuration_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
SDOPackage::Monitoring::_marshalObjRef(::SDOPackage::Monitoring_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
SDOPackage::SDOService::_marshalObjRef(::SDOPackage::SDOService_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
SDOPackage::Organization::_marshalObjRef(::SDOPackage::Organization_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_SDOPackage
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_SDOPackage
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_SDOPackage
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_SDOPackage
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_SDOPackage
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_SDOPackage
#endif

#endif  // __SDOPackage_hh__

