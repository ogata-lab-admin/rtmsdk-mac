// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "InterfaceDataTypes.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_RTC_mTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"nsec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTime
#  undef _0RL_tc_RTC_mTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Time:1.0", "Time", _0RL_structmember_RTC_mTime, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mActArrayActuatorPos[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"index", CORBA::TypeCode::PR_ushort_tc()},
  {"position", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mActArrayActuatorPos
#  undef _0RL_tc_RTC_mActArrayActuatorPos
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayActuatorPos = CORBA::TypeCode::PR_struct_tc("IDL:RTC/ActArrayActuatorPos:1.0", "ActArrayActuatorPos", _0RL_structmember_RTC_mActArrayActuatorPos, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorPos = _0RL_tc_RTC_mActArrayActuatorPos;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayActuatorPos = _0RL_tc_RTC_mActArrayActuatorPos;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mActArrayActuatorSpeed[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"index", CORBA::TypeCode::PR_ushort_tc()},
  {"speed", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mActArrayActuatorSpeed
#  undef _0RL_tc_RTC_mActArrayActuatorSpeed
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayActuatorSpeed = CORBA::TypeCode::PR_struct_tc("IDL:RTC/ActArrayActuatorSpeed:1.0", "ActArrayActuatorSpeed", _0RL_structmember_RTC_mActArrayActuatorSpeed, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorSpeed = _0RL_tc_RTC_mActArrayActuatorSpeed;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayActuatorSpeed = _0RL_tc_RTC_mActArrayActuatorSpeed;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mActArrayActuatorCurrent[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"index", CORBA::TypeCode::PR_ushort_tc()},
  {"current", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mActArrayActuatorCurrent
#  undef _0RL_tc_RTC_mActArrayActuatorCurrent
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayActuatorCurrent = CORBA::TypeCode::PR_struct_tc("IDL:RTC/ActArrayActuatorCurrent:1.0", "ActArrayActuatorCurrent", _0RL_structmember_RTC_mActArrayActuatorCurrent, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorCurrent = _0RL_tc_RTC_mActArrayActuatorCurrent;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayActuatorCurrent = _0RL_tc_RTC_mActArrayActuatorCurrent;
#endif


static const char* _0RL_enumMember_RTC_mActArrayActuatorStatus[] = { "ACTUATOR_STATUS_IDLE", "ACTUATOR_STATUS_MOVING", "ACTUATOR_STATUS_BRAKED", "ACTUATOR_STATUS_STALLED" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayActuatorStatus = CORBA::TypeCode::PR_enum_tc("IDL:RTC/ActArrayActuatorStatus:1.0", "ActArrayActuatorStatus", _0RL_enumMember_RTC_mActArrayActuatorStatus, 4, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorStatus = _0RL_tc_RTC_mActArrayActuatorStatus;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayActuatorStatus = _0RL_tc_RTC_mActArrayActuatorStatus;
#endif

static CORBA::PR_structMember _0RL_structmember_RTC_mActuator[] = {
  {"position", CORBA::TypeCode::PR_double_tc()},
  {"speed", CORBA::TypeCode::PR_double_tc()},
  {"accel", CORBA::TypeCode::PR_double_tc()},
  {"current", CORBA::TypeCode::PR_double_tc()},
  {"status", _0RL_tc_RTC_mActArrayActuatorStatus}
};

#ifdef _0RL_tc_RTC_mActuator
#  undef _0RL_tc_RTC_mActuator
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActuator = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Actuator:1.0", "Actuator", _0RL_structmember_RTC_mActuator, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Actuator = _0RL_tc_RTC_mActuator;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Actuator = _0RL_tc_RTC_mActuator;
#endif






static CORBA::TypeCode_ptr _0RL_tc_RTC_mActuatorList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/ActuatorList:1.0", "ActuatorList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mActuator, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActuatorList = _0RL_tc_RTC_mActuatorList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActuatorList = _0RL_tc_RTC_mActuatorList;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mActArrayState[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"actuators", _0RL_tc_RTC_mActuatorList}
};

#ifdef _0RL_tc_RTC_mActArrayState
#  undef _0RL_tc_RTC_mActArrayState
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayState = CORBA::TypeCode::PR_struct_tc("IDL:RTC/ActArrayState:1.0", "ActArrayState", _0RL_structmember_RTC_mActArrayState, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayState = _0RL_tc_RTC_mActArrayState;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayState = _0RL_tc_RTC_mActArrayState;
#endif


static const char* _0RL_enumMember_RTC_mActArrayActuatorType[] = { "ACTARRAY_ACTUATORTYPE_LINEAR", "ACTARRAY_ACTUATORTYPE_ROTARY" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayActuatorType = CORBA::TypeCode::PR_enum_tc("IDL:RTC/ActArrayActuatorType:1.0", "ActArrayActuatorType", _0RL_enumMember_RTC_mActArrayActuatorType, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorType = _0RL_tc_RTC_mActArrayActuatorType;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayActuatorType = _0RL_tc_RTC_mActArrayActuatorType;
#endif

static CORBA::PR_structMember _0RL_structmember_RTC_mOrientation3D[] = {
  {"r", CORBA::TypeCode::PR_double_tc()},
  {"p", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mOrientation3D
#  undef _0RL_tc_RTC_mOrientation3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOrientation3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Orientation3D:1.0", "Orientation3D", _0RL_structmember_RTC_mOrientation3D, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mVector3D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVector3D
#  undef _0RL_tc_RTC_mVector3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVector3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Vector3D:1.0", "Vector3D", _0RL_structmember_RTC_mVector3D, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mActArrayActuatorGeometry[] = {
  {"type", _0RL_tc_RTC_mActArrayActuatorType},
  {"length", CORBA::TypeCode::PR_double_tc()},
  {"orientation", _0RL_tc_RTC_mOrientation3D},
  {"axis", _0RL_tc_RTC_mVector3D},
  {"minRange", CORBA::TypeCode::PR_double_tc()},
  {"centre", CORBA::TypeCode::PR_double_tc()},
  {"maxRange", CORBA::TypeCode::PR_double_tc()},
  {"homePosition", CORBA::TypeCode::PR_double_tc()},
  {"hasBrakes", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_RTC_mActArrayActuatorGeometry
#  undef _0RL_tc_RTC_mActArrayActuatorGeometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayActuatorGeometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/ActArrayActuatorGeometry:1.0", "ActArrayActuatorGeometry", _0RL_structmember_RTC_mActArrayActuatorGeometry, 9, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorGeometry = _0RL_tc_RTC_mActArrayActuatorGeometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayActuatorGeometry = _0RL_tc_RTC_mActArrayActuatorGeometry;
#endif














static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayActuatorGeometryList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/ActArrayActuatorGeometryList:1.0", "ActArrayActuatorGeometryList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mActArrayActuatorGeometry, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorGeometryList = _0RL_tc_RTC_mActArrayActuatorGeometryList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayActuatorGeometryList = _0RL_tc_RTC_mActArrayActuatorGeometryList;
#endif

static CORBA::PR_structMember _0RL_structmember_RTC_mPoint3D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPoint3D
#  undef _0RL_tc_RTC_mPoint3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoint3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Point3D:1.0", "Point3D", _0RL_structmember_RTC_mPoint3D, 3, &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_RTC_mPose3D[] = {
  {"position", _0RL_tc_RTC_mPoint3D},
  {"orientation", _0RL_tc_RTC_mOrientation3D}
};

#ifdef _0RL_tc_RTC_mPose3D
#  undef _0RL_tc_RTC_mPose3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPose3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Pose3D:1.0", "Pose3D", _0RL_structmember_RTC_mPose3D, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mSize3D[] = {
  {"l", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()},
  {"h", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mSize3D
#  undef _0RL_tc_RTC_mSize3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mSize3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Size3D:1.0", "Size3D", _0RL_structmember_RTC_mSize3D, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mGeometry3D[] = {
  {"pose", _0RL_tc_RTC_mPose3D},
  {"size", _0RL_tc_RTC_mSize3D}
};

#ifdef _0RL_tc_RTC_mGeometry3D
#  undef _0RL_tc_RTC_mGeometry3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGeometry3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Geometry3D:1.0", "Geometry3D", _0RL_structmember_RTC_mGeometry3D, 2, &_0RL_tcTrack);




static CORBA::PR_structMember _0RL_structmember_RTC_mActArrayGeometry[] = {
  {"arrayGeometry", _0RL_tc_RTC_mGeometry3D},
  {"actuatorGeometry", _0RL_tc_RTC_mActArrayActuatorGeometryList}
};

#ifdef _0RL_tc_RTC_mActArrayGeometry
#  undef _0RL_tc_RTC_mActArrayGeometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mActArrayGeometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/ActArrayGeometry:1.0", "ActArrayGeometry", _0RL_structmember_RTC_mActArrayGeometry, 2, &_0RL_tcTrack);









#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ActArrayGeometry = _0RL_tc_RTC_mActArrayGeometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ActArrayGeometry = _0RL_tc_RTC_mActArrayGeometry;
#endif






static CORBA::PR_structMember _0RL_structmember_RTC_mBumperGeometry[] = {
  {"pose", _0RL_tc_RTC_mPose3D},
  {"size", _0RL_tc_RTC_mSize3D},
  {"roc", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mBumperGeometry
#  undef _0RL_tc_RTC_mBumperGeometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mBumperGeometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/BumperGeometry:1.0", "BumperGeometry", _0RL_structmember_RTC_mBumperGeometry, 3, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_BumperGeometry = _0RL_tc_RTC_mBumperGeometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_BumperGeometry = _0RL_tc_RTC_mBumperGeometry;
#endif






















static CORBA::TypeCode_ptr _0RL_tc_RTC_mBumperGeometryList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/BumperGeometryList:1.0", "BumperGeometryList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mBumperGeometry, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_BumperGeometryList = _0RL_tc_RTC_mBumperGeometryList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_BumperGeometryList = _0RL_tc_RTC_mBumperGeometryList;
#endif











static CORBA::PR_structMember _0RL_structmember_RTC_mBumperArrayGeometry[] = {
  {"arrayGeometry", _0RL_tc_RTC_mGeometry3D},
  {"bumperGeometry", _0RL_tc_RTC_mBumperGeometryList}
};

#ifdef _0RL_tc_RTC_mBumperArrayGeometry
#  undef _0RL_tc_RTC_mBumperArrayGeometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mBumperArrayGeometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/BumperArrayGeometry:1.0", "BumperArrayGeometry", _0RL_structmember_RTC_mBumperArrayGeometry, 2, &_0RL_tcTrack);











#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_BumperArrayGeometry = _0RL_tc_RTC_mBumperArrayGeometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_BumperArrayGeometry = _0RL_tc_RTC_mBumperArrayGeometry;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mCameraImage[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"width", CORBA::TypeCode::PR_ushort_tc()},
  {"height", CORBA::TypeCode::PR_ushort_tc()},
  {"bpp", CORBA::TypeCode::PR_ushort_tc()},
  {"format", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"fDiv", CORBA::TypeCode::PR_double_tc()},
  {"pixels", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mCameraImage
#  undef _0RL_tc_RTC_mCameraImage
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCameraImage = CORBA::TypeCode::PR_struct_tc("IDL:RTC/CameraImage:1.0", "CameraImage", _0RL_structmember_RTC_mCameraImage, 7, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_CameraImage = _0RL_tc_RTC_mCameraImage;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_CameraImage = _0RL_tc_RTC_mCameraImage;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mVector2D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVector2D
#  undef _0RL_tc_RTC_mVector2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVector2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Vector2D:1.0", "Vector2D", _0RL_structmember_RTC_mVector2D, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mPoint2D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPoint2D
#  undef _0RL_tc_RTC_mPoint2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoint2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Point2D:1.0", "Point2D", _0RL_structmember_RTC_mPoint2D, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mCameraInfo[] = {
  {"focalLength", _0RL_tc_RTC_mVector2D},
  {"principalPoint", _0RL_tc_RTC_mPoint2D},
  {"k1", CORBA::TypeCode::PR_double_tc()},
  {"k2", CORBA::TypeCode::PR_double_tc()},
  {"p1", CORBA::TypeCode::PR_double_tc()},
  {"p2", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mCameraInfo
#  undef _0RL_tc_RTC_mCameraInfo
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCameraInfo = CORBA::TypeCode::PR_struct_tc("IDL:RTC/CameraInfo:1.0", "CameraInfo", _0RL_structmember_RTC_mCameraInfo, 6, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_CameraInfo = _0RL_tc_RTC_mCameraInfo;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_CameraInfo = _0RL_tc_RTC_mCameraInfo;
#endif










static CORBA::PR_structMember _0RL_structmember_RTC_mFiducialInfo[] = {
  {"id", CORBA::TypeCode::PR_ulong_tc()},
  {"pose", _0RL_tc_RTC_mPose3D},
  {"poseUncertainty", _0RL_tc_RTC_mPose3D},
  {"size", _0RL_tc_RTC_mSize3D},
  {"sizeUncertainty", _0RL_tc_RTC_mSize3D}
};

#ifdef _0RL_tc_RTC_mFiducialInfo
#  undef _0RL_tc_RTC_mFiducialInfo
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFiducialInfo = CORBA::TypeCode::PR_struct_tc("IDL:RTC/FiducialInfo:1.0", "FiducialInfo", _0RL_structmember_RTC_mFiducialInfo, 5, &_0RL_tcTrack);









#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FiducialInfo = _0RL_tc_RTC_mFiducialInfo;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FiducialInfo = _0RL_tc_RTC_mFiducialInfo;
#endif






































static CORBA::TypeCode_ptr _0RL_tc_RTC_mFiducialInfoList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/FiducialInfoList:1.0", "FiducialInfoList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mFiducialInfo, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FiducialInfoList = _0RL_tc_RTC_mFiducialInfoList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FiducialInfoList = _0RL_tc_RTC_mFiducialInfoList;
#endif











static CORBA::PR_structMember _0RL_structmember_RTC_mFiducials[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"fiducialsList", _0RL_tc_RTC_mFiducialInfoList}
};

#ifdef _0RL_tc_RTC_mFiducials
#  undef _0RL_tc_RTC_mFiducials
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFiducials = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Fiducials:1.0", "Fiducials", _0RL_structmember_RTC_mFiducials, 2, &_0RL_tcTrack);











#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Fiducials = _0RL_tc_RTC_mFiducials;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Fiducials = _0RL_tc_RTC_mFiducials;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mFiducialFOV[] = {
  {"minRange", CORBA::TypeCode::PR_double_tc()},
  {"maxRange", CORBA::TypeCode::PR_double_tc()},
  {"viewAngle", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mFiducialFOV
#  undef _0RL_tc_RTC_mFiducialFOV
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFiducialFOV = CORBA::TypeCode::PR_struct_tc("IDL:RTC/FiducialFOV:1.0", "FiducialFOV", _0RL_structmember_RTC_mFiducialFOV, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FiducialFOV = _0RL_tc_RTC_mFiducialFOV;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FiducialFOV = _0RL_tc_RTC_mFiducialFOV;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGPSTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"msec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mGPSTime
#  undef _0RL_tc_RTC_mGPSTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGPSTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/GPSTime:1.0", "GPSTime", _0RL_structmember_RTC_mGPSTime, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_GPSTime = _0RL_tc_RTC_mGPSTime;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_GPSTime = _0RL_tc_RTC_mGPSTime;
#endif


static const char* _0RL_enumMember_RTC_mGPSFixType[] = { "GPS_FIX_NONE", "GPS_FIX_NORMAL", "GPS_FIX_DGPS" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGPSFixType = CORBA::TypeCode::PR_enum_tc("IDL:RTC/GPSFixType:1.0", "GPSFixType", _0RL_enumMember_RTC_mGPSFixType, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_GPSFixType = _0RL_tc_RTC_mGPSFixType;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_GPSFixType = _0RL_tc_RTC_mGPSFixType;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mGPSData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"timeFromGPS", _0RL_tc_RTC_mGPSTime},
  {"latitude", CORBA::TypeCode::PR_double_tc()},
  {"longitude", CORBA::TypeCode::PR_double_tc()},
  {"altitude", CORBA::TypeCode::PR_double_tc()},
  {"horizontalError", CORBA::TypeCode::PR_double_tc()},
  {"verticalError", CORBA::TypeCode::PR_double_tc()},
  {"heading", CORBA::TypeCode::PR_double_tc()},
  {"horizontalSpeed", CORBA::TypeCode::PR_double_tc()},
  {"verticalSpeed", CORBA::TypeCode::PR_double_tc()},
  {"numSatellites", CORBA::TypeCode::PR_ushort_tc()},
  {"fixType", _0RL_tc_RTC_mGPSFixType}
};

#ifdef _0RL_tc_RTC_mGPSData
#  undef _0RL_tc_RTC_mGPSData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGPSData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/GPSData:1.0", "GPSData", _0RL_structmember_RTC_mGPSData, 12, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_GPSData = _0RL_tc_RTC_mGPSData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_GPSData = _0RL_tc_RTC_mGPSData;
#endif


static const char* _0RL_enumMember_RTC_mGripperStatus[] = { "GRIPPER_STATE_OPEN", "GRIPPER_STATE_CLOSED", "GRIPPER_STATE_MOVING", "GRIPPER_STATE_UNKNOWN" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGripperStatus = CORBA::TypeCode::PR_enum_tc("IDL:RTC/GripperStatus:1.0", "GripperStatus", _0RL_enumMember_RTC_mGripperStatus, 4, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_GripperStatus = _0RL_tc_RTC_mGripperStatus;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_GripperStatus = _0RL_tc_RTC_mGripperStatus;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGripperState[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"status", _0RL_tc_RTC_mGripperStatus}
};

#ifdef _0RL_tc_RTC_mGripperState
#  undef _0RL_tc_RTC_mGripperState
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGripperState = CORBA::TypeCode::PR_struct_tc("IDL:RTC/GripperState:1.0", "GripperState", _0RL_structmember_RTC_mGripperState, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_GripperState = _0RL_tc_RTC_mGripperState;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_GripperState = _0RL_tc_RTC_mGripperState;
#endif












static CORBA::PR_structMember _0RL_structmember_RTC_mGripperGeometry[] = {
  {"exterior", _0RL_tc_RTC_mGeometry3D},
  {"interior", _0RL_tc_RTC_mGeometry3D}
};

#ifdef _0RL_tc_RTC_mGripperGeometry
#  undef _0RL_tc_RTC_mGripperGeometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGripperGeometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/GripperGeometry:1.0", "GripperGeometry", _0RL_structmember_RTC_mGripperGeometry, 2, &_0RL_tcTrack);











#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_GripperGeometry = _0RL_tc_RTC_mGripperGeometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_GripperGeometry = _0RL_tc_RTC_mGripperGeometry;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mVelocity3D[] = {
  {"vx", CORBA::TypeCode::PR_double_tc()},
  {"vy", CORBA::TypeCode::PR_double_tc()},
  {"vz", CORBA::TypeCode::PR_double_tc()},
  {"vr", CORBA::TypeCode::PR_double_tc()},
  {"vp", CORBA::TypeCode::PR_double_tc()},
  {"va", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVelocity3D
#  undef _0RL_tc_RTC_mVelocity3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVelocity3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Velocity3D:1.0", "Velocity3D", _0RL_structmember_RTC_mVelocity3D, 6, &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_RTC_mINSData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"latitude", CORBA::TypeCode::PR_double_tc()},
  {"longitude", CORBA::TypeCode::PR_double_tc()},
  {"altitude", CORBA::TypeCode::PR_double_tc()},
  {"heightAMSL", CORBA::TypeCode::PR_double_tc()},
  {"velocityENU", _0RL_tc_RTC_mVelocity3D},
  {"orientation", _0RL_tc_RTC_mOrientation3D}
};

#ifdef _0RL_tc_RTC_mINSData
#  undef _0RL_tc_RTC_mINSData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mINSData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/INSData:1.0", "INSData", _0RL_structmember_RTC_mINSData, 7, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_INSData = _0RL_tc_RTC_mINSData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_INSData = _0RL_tc_RTC_mINSData;
#endif


static const char* _0RL_enumMember_RTC_mLimbStatus[] = { "LIMB_STATUS_IDLE", "LIMB_STATUS_BRAKED", "LIMB_STATUS_MOVING", "LIMB_STATUS_OOR", "LIMB_STATUS_COLLISION" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mLimbStatus = CORBA::TypeCode::PR_enum_tc("IDL:RTC/LimbStatus:1.0", "LimbStatus", _0RL_enumMember_RTC_mLimbStatus, 5, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_LimbStatus = _0RL_tc_RTC_mLimbStatus;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_LimbStatus = _0RL_tc_RTC_mLimbStatus;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mOAP[] = {
  {"orientation", _0RL_tc_RTC_mVector3D},
  {"approach", _0RL_tc_RTC_mVector3D},
  {"position", _0RL_tc_RTC_mVector3D}
};

#ifdef _0RL_tc_RTC_mOAP
#  undef _0RL_tc_RTC_mOAP
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOAP = CORBA::TypeCode::PR_struct_tc("IDL:RTC/OAP:1.0", "OAP", _0RL_structmember_RTC_mOAP, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mLimbState[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"oapMatrix", _0RL_tc_RTC_mOAP},
  {"status", _0RL_tc_RTC_mLimbStatus}
};

#ifdef _0RL_tc_RTC_mLimbState
#  undef _0RL_tc_RTC_mLimbState
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mLimbState = CORBA::TypeCode::PR_struct_tc("IDL:RTC/LimbState:1.0", "LimbState", _0RL_structmember_RTC_mLimbState, 3, &_0RL_tcTrack);






#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_LimbState = _0RL_tc_RTC_mLimbState;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_LimbState = _0RL_tc_RTC_mLimbState;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mPose2D[] = {
  {"position", _0RL_tc_RTC_mPoint2D},
  {"heading", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPose2D
#  undef _0RL_tc_RTC_mPose2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPose2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Pose2D:1.0", "Pose2D", _0RL_structmember_RTC_mPose2D, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mCovariance2D[] = {
  {"xx", CORBA::TypeCode::PR_double_tc()},
  {"xy", CORBA::TypeCode::PR_double_tc()},
  {"xt", CORBA::TypeCode::PR_double_tc()},
  {"yy", CORBA::TypeCode::PR_double_tc()},
  {"yt", CORBA::TypeCode::PR_double_tc()},
  {"tt", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mCovariance2D
#  undef _0RL_tc_RTC_mCovariance2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCovariance2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Covariance2D:1.0", "Covariance2D", _0RL_structmember_RTC_mCovariance2D, 6, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mHypothesis2D[] = {
  {"mean", _0RL_tc_RTC_mPose2D},
  {"covariance", _0RL_tc_RTC_mCovariance2D},
  {"weight", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mHypothesis2D
#  undef _0RL_tc_RTC_mHypothesis2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mHypothesis2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Hypothesis2D:1.0", "Hypothesis2D", _0RL_structmember_RTC_mHypothesis2D, 3, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Hypothesis2D = _0RL_tc_RTC_mHypothesis2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Hypothesis2D = _0RL_tc_RTC_mHypothesis2D;
#endif


















static CORBA::TypeCode_ptr _0RL_tc_RTC_mHypothesis2DList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/Hypothesis2DList:1.0", "Hypothesis2DList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mHypothesis2D, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Hypothesis2DList = _0RL_tc_RTC_mHypothesis2DList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Hypothesis2DList = _0RL_tc_RTC_mHypothesis2DList;
#endif






static CORBA::PR_structMember _0RL_structmember_RTC_mHypotheses2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"hypotheses", _0RL_tc_RTC_mHypothesis2DList}
};

#ifdef _0RL_tc_RTC_mHypotheses2D
#  undef _0RL_tc_RTC_mHypotheses2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mHypotheses2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Hypotheses2D:1.0", "Hypotheses2D", _0RL_structmember_RTC_mHypotheses2D, 2, &_0RL_tcTrack);






#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Hypotheses2D = _0RL_tc_RTC_mHypotheses2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Hypotheses2D = _0RL_tc_RTC_mHypotheses2D;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mCovariance3D[] = {
  {"xx", CORBA::TypeCode::PR_double_tc()},
  {"xy", CORBA::TypeCode::PR_double_tc()},
  {"xz", CORBA::TypeCode::PR_double_tc()},
  {"xr", CORBA::TypeCode::PR_double_tc()},
  {"xp", CORBA::TypeCode::PR_double_tc()},
  {"xa", CORBA::TypeCode::PR_double_tc()},
  {"yy", CORBA::TypeCode::PR_double_tc()},
  {"yz", CORBA::TypeCode::PR_double_tc()},
  {"yr", CORBA::TypeCode::PR_double_tc()},
  {"yp", CORBA::TypeCode::PR_double_tc()},
  {"ya", CORBA::TypeCode::PR_double_tc()},
  {"zz", CORBA::TypeCode::PR_double_tc()},
  {"zr", CORBA::TypeCode::PR_double_tc()},
  {"zp", CORBA::TypeCode::PR_double_tc()},
  {"za", CORBA::TypeCode::PR_double_tc()},
  {"rr", CORBA::TypeCode::PR_double_tc()},
  {"rp", CORBA::TypeCode::PR_double_tc()},
  {"ra", CORBA::TypeCode::PR_double_tc()},
  {"pp", CORBA::TypeCode::PR_double_tc()},
  {"pa", CORBA::TypeCode::PR_double_tc()},
  {"aa", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mCovariance3D
#  undef _0RL_tc_RTC_mCovariance3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCovariance3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Covariance3D:1.0", "Covariance3D", _0RL_structmember_RTC_mCovariance3D, 21, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mHypothesis3D[] = {
  {"mean", _0RL_tc_RTC_mPose3D},
  {"covariance", _0RL_tc_RTC_mCovariance3D},
  {"weight", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mHypothesis3D
#  undef _0RL_tc_RTC_mHypothesis3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mHypothesis3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Hypothesis3D:1.0", "Hypothesis3D", _0RL_structmember_RTC_mHypothesis3D, 3, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Hypothesis3D = _0RL_tc_RTC_mHypothesis3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Hypothesis3D = _0RL_tc_RTC_mHypothesis3D;
#endif






















static CORBA::TypeCode_ptr _0RL_tc_RTC_mHypothesis3DList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/Hypothesis3DList:1.0", "Hypothesis3DList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mHypothesis3D, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Hypothesis3DList = _0RL_tc_RTC_mHypothesis3DList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Hypothesis3DList = _0RL_tc_RTC_mHypothesis3DList;
#endif







static CORBA::PR_structMember _0RL_structmember_RTC_mHypotheses3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"hypotheses", _0RL_tc_RTC_mHypothesis3DList}
};

#ifdef _0RL_tc_RTC_mHypotheses3D
#  undef _0RL_tc_RTC_mHypotheses3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mHypotheses3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Hypotheses3D:1.0", "Hypotheses3D", _0RL_structmember_RTC_mHypotheses3D, 2, &_0RL_tcTrack);







#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Hypotheses3D = _0RL_tc_RTC_mHypotheses3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Hypotheses3D = _0RL_tc_RTC_mHypotheses3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mOGMapConfig[] = {
  {"xScale", CORBA::TypeCode::PR_double_tc()},
  {"yScale", CORBA::TypeCode::PR_double_tc()},
  {"width", CORBA::TypeCode::PR_ulong_tc()},
  {"height", CORBA::TypeCode::PR_ulong_tc()},
  {"origin", _0RL_tc_RTC_mPose2D}
};

#ifdef _0RL_tc_RTC_mOGMapConfig
#  undef _0RL_tc_RTC_mOGMapConfig
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOGMapConfig = CORBA::TypeCode::PR_struct_tc("IDL:RTC/OGMapConfig:1.0", "OGMapConfig", _0RL_structmember_RTC_mOGMapConfig, 5, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_OGMapConfig = _0RL_tc_RTC_mOGMapConfig;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_OGMapConfig = _0RL_tc_RTC_mOGMapConfig;
#endif


static CORBA::TypeCode_ptr _0RL_tc_RTC_mOGMapCells = CORBA::TypeCode::PR_alias_tc("IDL:RTC/OGMapCells:1.0", "OGMapCells", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_OGMapCells = _0RL_tc_RTC_mOGMapCells;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_OGMapCells = _0RL_tc_RTC_mOGMapCells;
#endif

static CORBA::PR_structMember _0RL_structmember_RTC_mOGMapTile[] = {
  {"column", CORBA::TypeCode::PR_ulong_tc()},
  {"row", CORBA::TypeCode::PR_ulong_tc()},
  {"width", CORBA::TypeCode::PR_ulong_tc()},
  {"height", CORBA::TypeCode::PR_ulong_tc()},
  {"cells", _0RL_tc_RTC_mOGMapCells}
};

#ifdef _0RL_tc_RTC_mOGMapTile
#  undef _0RL_tc_RTC_mOGMapTile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOGMapTile = CORBA::TypeCode::PR_struct_tc("IDL:RTC/OGMapTile:1.0", "OGMapTile", _0RL_structmember_RTC_mOGMapTile, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_OGMapTile = _0RL_tc_RTC_mOGMapTile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_OGMapTile = _0RL_tc_RTC_mOGMapTile;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mPointCovariance2D[] = {
  {"xx", CORBA::TypeCode::PR_double_tc()},
  {"xy", CORBA::TypeCode::PR_double_tc()},
  {"yy", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPointCovariance2D
#  undef _0RL_tc_RTC_mPointCovariance2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPointCovariance2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PointCovariance2D:1.0", "PointCovariance2D", _0RL_structmember_RTC_mPointCovariance2D, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mPointFeature[] = {
  {"probability", CORBA::TypeCode::PR_double_tc()},
  {"position", _0RL_tc_RTC_mPoint2D},
  {"covariance", _0RL_tc_RTC_mPointCovariance2D}
};

#ifdef _0RL_tc_RTC_mPointFeature
#  undef _0RL_tc_RTC_mPointFeature
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPointFeature = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PointFeature:1.0", "PointFeature", _0RL_structmember_RTC_mPointFeature, 3, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PointFeature = _0RL_tc_RTC_mPointFeature;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PointFeature = _0RL_tc_RTC_mPointFeature;
#endif














static CORBA::TypeCode_ptr _0RL_tc_RTC_mPointFeatureList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/PointFeatureList:1.0", "PointFeatureList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPointFeature, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PointFeatureList = _0RL_tc_RTC_mPointFeatureList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PointFeatureList = _0RL_tc_RTC_mPointFeatureList;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mPoseFeature[] = {
  {"probability", CORBA::TypeCode::PR_double_tc()},
  {"position", _0RL_tc_RTC_mPose2D},
  {"covariance", _0RL_tc_RTC_mCovariance2D}
};

#ifdef _0RL_tc_RTC_mPoseFeature
#  undef _0RL_tc_RTC_mPoseFeature
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoseFeature = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PoseFeature:1.0", "PoseFeature", _0RL_structmember_RTC_mPoseFeature, 3, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PoseFeature = _0RL_tc_RTC_mPoseFeature;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PoseFeature = _0RL_tc_RTC_mPoseFeature;
#endif


















static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoseFeatureList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/PoseFeatureList:1.0", "PoseFeatureList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPoseFeature, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PoseFeatureList = _0RL_tc_RTC_mPoseFeatureList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PoseFeatureList = _0RL_tc_RTC_mPoseFeatureList;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mLineFeature[] = {
  {"probability", CORBA::TypeCode::PR_double_tc()},
  {"rho", CORBA::TypeCode::PR_double_tc()},
  {"alpha", CORBA::TypeCode::PR_double_tc()},
  {"covariance", _0RL_tc_RTC_mPointCovariance2D},
  {"start", _0RL_tc_RTC_mPoint2D},
  {"end", _0RL_tc_RTC_mPoint2D},
  {"startSighted", CORBA::TypeCode::PR_boolean_tc()},
  {"endSighted", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_RTC_mLineFeature
#  undef _0RL_tc_RTC_mLineFeature
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mLineFeature = CORBA::TypeCode::PR_struct_tc("IDL:RTC/LineFeature:1.0", "LineFeature", _0RL_structmember_RTC_mLineFeature, 8, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_LineFeature = _0RL_tc_RTC_mLineFeature;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_LineFeature = _0RL_tc_RTC_mLineFeature;
#endif


















static CORBA::TypeCode_ptr _0RL_tc_RTC_mLineFeatureList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/LineFeatureList:1.0", "LineFeatureList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mLineFeature, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_LineFeatureList = _0RL_tc_RTC_mLineFeatureList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_LineFeatureList = _0RL_tc_RTC_mLineFeatureList;
#endif













static CORBA::PR_structMember _0RL_structmember_RTC_mFeatures[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"pointFeatures", _0RL_tc_RTC_mPointFeatureList},
  {"poseFeatures", _0RL_tc_RTC_mPoseFeatureList},
  {"lineFeatures", _0RL_tc_RTC_mLineFeatureList}
};

#ifdef _0RL_tc_RTC_mFeatures
#  undef _0RL_tc_RTC_mFeatures
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFeatures = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Features:1.0", "Features", _0RL_structmember_RTC_mFeatures, 4, &_0RL_tcTrack);













#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Features = _0RL_tc_RTC_mFeatures;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Features = _0RL_tc_RTC_mFeatures;
#endif










static CORBA::TypeCode_ptr _0RL_tc_RTC_mMulticameraImageList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/MulticameraImageList:1.0", "MulticameraImageList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mCameraImage, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MulticameraImageList = _0RL_tc_RTC_mMulticameraImageList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MulticameraImageList = _0RL_tc_RTC_mMulticameraImageList;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mMultiCameraImages[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"images", _0RL_tc_RTC_mMulticameraImageList}
};

#ifdef _0RL_tc_RTC_mMultiCameraImages
#  undef _0RL_tc_RTC_mMultiCameraImages
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mMultiCameraImages = CORBA::TypeCode::PR_struct_tc("IDL:RTC/MultiCameraImages:1.0", "MultiCameraImages", _0RL_structmember_RTC_mMultiCameraImages, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MultiCameraImages = _0RL_tc_RTC_mMultiCameraImages;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MultiCameraImages = _0RL_tc_RTC_mMultiCameraImages;
#endif














static CORBA::TypeCode_ptr _0RL_tc_RTC_mMulticameraInfoList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/MulticameraInfoList:1.0", "MulticameraInfoList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mCameraInfo, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MulticameraInfoList = _0RL_tc_RTC_mMulticameraInfoList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MulticameraInfoList = _0RL_tc_RTC_mMulticameraInfoList;
#endif





















static CORBA::TypeCode_ptr _0RL_tc_RTC_mMulticameraGeometryList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/MulticameraGeometryList:1.0", "MulticameraGeometryList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mGeometry3D, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MulticameraGeometryList = _0RL_tc_RTC_mMulticameraGeometryList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MulticameraGeometryList = _0RL_tc_RTC_mMulticameraGeometryList;
#endif











static CORBA::PR_structMember _0RL_structmember_RTC_mMulticameraGeometry[] = {
  {"geometry", _0RL_tc_RTC_mGeometry3D},
  {"cameraGeometries", _0RL_tc_RTC_mMulticameraGeometryList}
};

#ifdef _0RL_tc_RTC_mMulticameraGeometry
#  undef _0RL_tc_RTC_mMulticameraGeometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mMulticameraGeometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/MulticameraGeometry:1.0", "MulticameraGeometry", _0RL_structmember_RTC_mMulticameraGeometry, 2, &_0RL_tcTrack);











#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MulticameraGeometry = _0RL_tc_RTC_mMulticameraGeometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MulticameraGeometry = _0RL_tc_RTC_mMulticameraGeometry;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mVelocity2D[] = {
  {"vx", CORBA::TypeCode::PR_double_tc()},
  {"vy", CORBA::TypeCode::PR_double_tc()},
  {"va", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVelocity2D
#  undef _0RL_tc_RTC_mVelocity2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVelocity2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Velocity2D:1.0", "Velocity2D", _0RL_structmember_RTC_mVelocity2D, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mWaypoint2D[] = {
  {"target", _0RL_tc_RTC_mPose2D},
  {"distanceTolerance", CORBA::TypeCode::PR_double_tc()},
  {"headingTolerance", CORBA::TypeCode::PR_double_tc()},
  {"timeLimit", _0RL_tc_RTC_mTime},
  {"maxSpeed", _0RL_tc_RTC_mVelocity2D}
};

#ifdef _0RL_tc_RTC_mWaypoint2D
#  undef _0RL_tc_RTC_mWaypoint2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mWaypoint2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Waypoint2D:1.0", "Waypoint2D", _0RL_structmember_RTC_mWaypoint2D, 5, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Waypoint2D = _0RL_tc_RTC_mWaypoint2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Waypoint2D = _0RL_tc_RTC_mWaypoint2D;
#endif






















static CORBA::TypeCode_ptr _0RL_tc_RTC_mWaypoint2DList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/Waypoint2DList:1.0", "Waypoint2DList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mWaypoint2D, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Waypoint2DList = _0RL_tc_RTC_mWaypoint2DList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Waypoint2DList = _0RL_tc_RTC_mWaypoint2DList;
#endif







static CORBA::PR_structMember _0RL_structmember_RTC_mPath2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"waypoints", _0RL_tc_RTC_mWaypoint2DList}
};

#ifdef _0RL_tc_RTC_mPath2D
#  undef _0RL_tc_RTC_mPath2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPath2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Path2D:1.0", "Path2D", _0RL_structmember_RTC_mPath2D, 2, &_0RL_tcTrack);







#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Path2D = _0RL_tc_RTC_mPath2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Path2D = _0RL_tc_RTC_mPath2D;
#endif







static CORBA::PR_structMember _0RL_structmember_RTC_mWaypoint3D[] = {
  {"target", _0RL_tc_RTC_mPose3D},
  {"distanceTolerance", CORBA::TypeCode::PR_double_tc()},
  {"headingTolerance", CORBA::TypeCode::PR_double_tc()},
  {"timeLimit", _0RL_tc_RTC_mTime},
  {"maxSpeed", _0RL_tc_RTC_mVelocity3D}
};

#ifdef _0RL_tc_RTC_mWaypoint3D
#  undef _0RL_tc_RTC_mWaypoint3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mWaypoint3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Waypoint3D:1.0", "Waypoint3D", _0RL_structmember_RTC_mWaypoint3D, 5, &_0RL_tcTrack);






#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Waypoint3D = _0RL_tc_RTC_mWaypoint3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Waypoint3D = _0RL_tc_RTC_mWaypoint3D;
#endif


























static CORBA::TypeCode_ptr _0RL_tc_RTC_mWaypoint3DList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/Waypoint3DList:1.0", "Waypoint3DList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mWaypoint3D, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Waypoint3DList = _0RL_tc_RTC_mWaypoint3DList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Waypoint3DList = _0RL_tc_RTC_mWaypoint3DList;
#endif








static CORBA::PR_structMember _0RL_structmember_RTC_mPath3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"waypoints", _0RL_tc_RTC_mWaypoint3DList}
};

#ifdef _0RL_tc_RTC_mPath3D
#  undef _0RL_tc_RTC_mPath3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPath3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Path3D:1.0", "Path3D", _0RL_structmember_RTC_mPath3D, 2, &_0RL_tcTrack);








#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Path3D = _0RL_tc_RTC_mPath3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Path3D = _0RL_tc_RTC_mPath3D;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mRGBColour[] = {
  {"r", CORBA::TypeCode::PR_double_tc()},
  {"g", CORBA::TypeCode::PR_double_tc()},
  {"b", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mRGBColour
#  undef _0RL_tc_RTC_mRGBColour
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRGBColour = CORBA::TypeCode::PR_struct_tc("IDL:RTC/RGBColour:1.0", "RGBColour", _0RL_structmember_RTC_mRGBColour, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mPointCloudPoint[] = {
  {"point", _0RL_tc_RTC_mPoint3D},
  {"colour", _0RL_tc_RTC_mRGBColour}
};

#ifdef _0RL_tc_RTC_mPointCloudPoint
#  undef _0RL_tc_RTC_mPointCloudPoint
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPointCloudPoint = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PointCloudPoint:1.0", "PointCloudPoint", _0RL_structmember_RTC_mPointCloudPoint, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PointCloudPoint = _0RL_tc_RTC_mPointCloudPoint;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PointCloudPoint = _0RL_tc_RTC_mPointCloudPoint;
#endif














static CORBA::TypeCode_ptr _0RL_tc_RTC_mPointCloudPointList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/PointCloudPointList:1.0", "PointCloudPointList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPointCloudPoint, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PointCloudPointList = _0RL_tc_RTC_mPointCloudPointList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PointCloudPointList = _0RL_tc_RTC_mPointCloudPointList;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mPointCloud[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"points", _0RL_tc_RTC_mPointCloudPointList}
};

#ifdef _0RL_tc_RTC_mPointCloud
#  undef _0RL_tc_RTC_mPointCloud
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPointCloud = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PointCloud:1.0", "PointCloud", _0RL_structmember_RTC_mPointCloud, 2, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PointCloud = _0RL_tc_RTC_mPointCloud;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PointCloud = _0RL_tc_RTC_mPointCloud;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mPanTiltAngles[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"pan", CORBA::TypeCode::PR_double_tc()},
  {"tilt", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPanTiltAngles
#  undef _0RL_tc_RTC_mPanTiltAngles
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPanTiltAngles = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PanTiltAngles:1.0", "PanTiltAngles", _0RL_structmember_RTC_mPanTiltAngles, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PanTiltAngles = _0RL_tc_RTC_mPanTiltAngles;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PanTiltAngles = _0RL_tc_RTC_mPanTiltAngles;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mPanTiltState[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"angles", _0RL_tc_RTC_mPanTiltAngles},
  {"panSpeed", CORBA::TypeCode::PR_double_tc()},
  {"tiltSpeed", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPanTiltState
#  undef _0RL_tc_RTC_mPanTiltState
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPanTiltState = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PanTiltState:1.0", "PanTiltState", _0RL_structmember_RTC_mPanTiltState, 4, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PanTiltState = _0RL_tc_RTC_mPanTiltState;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PanTiltState = _0RL_tc_RTC_mPanTiltState;
#endif






















static CORBA::TypeCode_ptr _0RL_tc_RTC_mElementGeometryList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/ElementGeometryList:1.0", "ElementGeometryList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mGeometry3D, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ElementGeometryList = _0RL_tc_RTC_mElementGeometryList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ElementGeometryList = _0RL_tc_RTC_mElementGeometryList;
#endif











static CORBA::PR_structMember _0RL_structmember_RTC_mRangerGeometry[] = {
  {"geometry", _0RL_tc_RTC_mGeometry3D},
  {"elementGeometries", _0RL_tc_RTC_mElementGeometryList}
};

#ifdef _0RL_tc_RTC_mRangerGeometry
#  undef _0RL_tc_RTC_mRangerGeometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRangerGeometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/RangerGeometry:1.0", "RangerGeometry", _0RL_structmember_RTC_mRangerGeometry, 2, &_0RL_tcTrack);











#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RangerGeometry = _0RL_tc_RTC_mRangerGeometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RangerGeometry = _0RL_tc_RTC_mRangerGeometry;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mRangerConfig[] = {
  {"minAngle", CORBA::TypeCode::PR_double_tc()},
  {"maxAngle", CORBA::TypeCode::PR_double_tc()},
  {"angularRes", CORBA::TypeCode::PR_double_tc()},
  {"minRange", CORBA::TypeCode::PR_double_tc()},
  {"maxRange", CORBA::TypeCode::PR_double_tc()},
  {"rangeRes", CORBA::TypeCode::PR_double_tc()},
  {"frequency", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mRangerConfig
#  undef _0RL_tc_RTC_mRangerConfig
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRangerConfig = CORBA::TypeCode::PR_struct_tc("IDL:RTC/RangerConfig:1.0", "RangerConfig", _0RL_structmember_RTC_mRangerConfig, 7, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RangerConfig = _0RL_tc_RTC_mRangerConfig;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RangerConfig = _0RL_tc_RTC_mRangerConfig;
#endif


static CORBA::TypeCode_ptr _0RL_tc_RTC_mRangeList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/RangeList:1.0", "RangeList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RangeList = _0RL_tc_RTC_mRangeList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RangeList = _0RL_tc_RTC_mRangeList;
#endif














static CORBA::PR_structMember _0RL_structmember_RTC_mRangeData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"ranges", _0RL_tc_RTC_mRangeList},
  {"geometry", _0RL_tc_RTC_mRangerGeometry},
  {"config", _0RL_tc_RTC_mRangerConfig}
};

#ifdef _0RL_tc_RTC_mRangeData
#  undef _0RL_tc_RTC_mRangeData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRangeData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/RangeData:1.0", "RangeData", _0RL_structmember_RTC_mRangeData, 4, &_0RL_tcTrack);














#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RangeData = _0RL_tc_RTC_mRangeData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RangeData = _0RL_tc_RTC_mRangeData;
#endif


static CORBA::TypeCode_ptr _0RL_tc_RTC_mIntensityList = CORBA::TypeCode::PR_alias_tc("IDL:RTC/IntensityList:1.0", "IntensityList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_IntensityList = _0RL_tc_RTC_mIntensityList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_IntensityList = _0RL_tc_RTC_mIntensityList;
#endif














static CORBA::PR_structMember _0RL_structmember_RTC_mIntensityData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"intensities", _0RL_tc_RTC_mIntensityList},
  {"geometry", _0RL_tc_RTC_mRangerGeometry},
  {"config", _0RL_tc_RTC_mRangerConfig}
};

#ifdef _0RL_tc_RTC_mIntensityData
#  undef _0RL_tc_RTC_mIntensityData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mIntensityData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/IntensityData:1.0", "IntensityData", _0RL_structmember_RTC_mIntensityData, 4, &_0RL_tcTrack);














#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_IntensityData = _0RL_tc_RTC_mIntensityData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_IntensityData = _0RL_tc_RTC_mIntensityData;
#endif


static CORBA::TypeCode_ptr _0RL_tc_RTC_mRFIDTagData = CORBA::TypeCode::PR_alias_tc("IDL:RTC/RFIDTagData:1.0", "RFIDTagData", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RFIDTagData = _0RL_tc_RTC_mRFIDTagData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RFIDTagData = _0RL_tc_RTC_mRFIDTagData;
#endif

static void _0RL_RTC_mActArrayActuatorPos_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayActuatorPos* _p = (RTC::ActArrayActuatorPos*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayActuatorPos_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayActuatorPos* _p = new RTC::ActArrayActuatorPos;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActArrayActuatorPos_destructor_fn(void* _v)
{
  RTC::ActArrayActuatorPos* _p = (RTC::ActArrayActuatorPos*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorPos& _s)
{
  RTC::ActArrayActuatorPos* _p = new RTC::ActArrayActuatorPos(_s);
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorPos,
               _0RL_RTC_mActArrayActuatorPos_marshal_fn,
               _0RL_RTC_mActArrayActuatorPos_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorPos* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorPos,
               _0RL_RTC_mActArrayActuatorPos_marshal_fn,
               _0RL_RTC_mActArrayActuatorPos_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorPos*& _sp)
{
  return _a >>= (const RTC::ActArrayActuatorPos*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorPos*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActArrayActuatorPos,
                    _0RL_RTC_mActArrayActuatorPos_unmarshal_fn,
                    _0RL_RTC_mActArrayActuatorPos_marshal_fn,
                    _0RL_RTC_mActArrayActuatorPos_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActArrayActuatorPos*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActArrayActuatorSpeed_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayActuatorSpeed* _p = (RTC::ActArrayActuatorSpeed*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayActuatorSpeed_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayActuatorSpeed* _p = new RTC::ActArrayActuatorSpeed;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActArrayActuatorSpeed_destructor_fn(void* _v)
{
  RTC::ActArrayActuatorSpeed* _p = (RTC::ActArrayActuatorSpeed*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorSpeed& _s)
{
  RTC::ActArrayActuatorSpeed* _p = new RTC::ActArrayActuatorSpeed(_s);
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorSpeed,
               _0RL_RTC_mActArrayActuatorSpeed_marshal_fn,
               _0RL_RTC_mActArrayActuatorSpeed_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorSpeed* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorSpeed,
               _0RL_RTC_mActArrayActuatorSpeed_marshal_fn,
               _0RL_RTC_mActArrayActuatorSpeed_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorSpeed*& _sp)
{
  return _a >>= (const RTC::ActArrayActuatorSpeed*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorSpeed*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActArrayActuatorSpeed,
                    _0RL_RTC_mActArrayActuatorSpeed_unmarshal_fn,
                    _0RL_RTC_mActArrayActuatorSpeed_marshal_fn,
                    _0RL_RTC_mActArrayActuatorSpeed_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActArrayActuatorSpeed*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActArrayActuatorCurrent_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayActuatorCurrent* _p = (RTC::ActArrayActuatorCurrent*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayActuatorCurrent_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayActuatorCurrent* _p = new RTC::ActArrayActuatorCurrent;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActArrayActuatorCurrent_destructor_fn(void* _v)
{
  RTC::ActArrayActuatorCurrent* _p = (RTC::ActArrayActuatorCurrent*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorCurrent& _s)
{
  RTC::ActArrayActuatorCurrent* _p = new RTC::ActArrayActuatorCurrent(_s);
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorCurrent,
               _0RL_RTC_mActArrayActuatorCurrent_marshal_fn,
               _0RL_RTC_mActArrayActuatorCurrent_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorCurrent* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorCurrent,
               _0RL_RTC_mActArrayActuatorCurrent_marshal_fn,
               _0RL_RTC_mActArrayActuatorCurrent_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorCurrent*& _sp)
{
  return _a >>= (const RTC::ActArrayActuatorCurrent*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorCurrent*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActArrayActuatorCurrent,
                    _0RL_RTC_mActArrayActuatorCurrent_unmarshal_fn,
                    _0RL_RTC_mActArrayActuatorCurrent_marshal_fn,
                    _0RL_RTC_mActArrayActuatorCurrent_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActArrayActuatorCurrent*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActArrayActuatorStatus_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayActuatorStatus* _p = (RTC::ActArrayActuatorStatus*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayActuatorStatus_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayActuatorStatus* _p = (RTC::ActArrayActuatorStatus*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorStatus _s)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorStatus,
               _0RL_RTC_mActArrayActuatorStatus_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorStatus& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mActArrayActuatorStatus,
                       _0RL_RTC_mActArrayActuatorStatus_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mActuator_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Actuator* _p = (RTC::Actuator*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActuator_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Actuator* _p = new RTC::Actuator;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActuator_destructor_fn(void* _v)
{
  RTC::Actuator* _p = (RTC::Actuator*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Actuator& _s)
{
  RTC::Actuator* _p = new RTC::Actuator(_s);
  _a.PR_insert(_0RL_tc_RTC_mActuator,
               _0RL_RTC_mActuator_marshal_fn,
               _0RL_RTC_mActuator_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Actuator* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActuator,
               _0RL_RTC_mActuator_marshal_fn,
               _0RL_RTC_mActuator_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Actuator*& _sp)
{
  return _a >>= (const RTC::Actuator*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Actuator*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActuator,
                    _0RL_RTC_mActuator_unmarshal_fn,
                    _0RL_RTC_mActuator_marshal_fn,
                    _0RL_RTC_mActuator_destructor_fn,
                    _v)) {
    _sp = (const RTC::Actuator*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActuatorList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActuatorList* _p = (RTC::ActuatorList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActuatorList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActuatorList* _p = new RTC::ActuatorList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActuatorList_destructor_fn(void* _v)
{
  RTC::ActuatorList* _p = (RTC::ActuatorList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActuatorList& _s)
{
  RTC::ActuatorList* _p = new RTC::ActuatorList(_s);
  _a.PR_insert(_0RL_tc_RTC_mActuatorList,
               _0RL_RTC_mActuatorList_marshal_fn,
               _0RL_RTC_mActuatorList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActuatorList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActuatorList,
               _0RL_RTC_mActuatorList_marshal_fn,
               _0RL_RTC_mActuatorList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActuatorList*& _sp)
{
  return _a >>= (const RTC::ActuatorList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActuatorList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActuatorList,
                    _0RL_RTC_mActuatorList_unmarshal_fn,
                    _0RL_RTC_mActuatorList_marshal_fn,
                    _0RL_RTC_mActuatorList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActuatorList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActArrayState_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayState* _p = (RTC::ActArrayState*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayState* _p = new RTC::ActArrayState;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActArrayState_destructor_fn(void* _v)
{
  RTC::ActArrayState* _p = (RTC::ActArrayState*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayState& _s)
{
  RTC::ActArrayState* _p = new RTC::ActArrayState(_s);
  _a.PR_insert(_0RL_tc_RTC_mActArrayState,
               _0RL_RTC_mActArrayState_marshal_fn,
               _0RL_RTC_mActArrayState_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActArrayState* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayState,
               _0RL_RTC_mActArrayState_marshal_fn,
               _0RL_RTC_mActArrayState_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayState*& _sp)
{
  return _a >>= (const RTC::ActArrayState*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayState*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActArrayState,
                    _0RL_RTC_mActArrayState_unmarshal_fn,
                    _0RL_RTC_mActArrayState_marshal_fn,
                    _0RL_RTC_mActArrayState_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActArrayState*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActArrayActuatorType_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayActuatorType* _p = (RTC::ActArrayActuatorType*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayActuatorType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayActuatorType* _p = (RTC::ActArrayActuatorType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorType _s)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorType,
               _0RL_RTC_mActArrayActuatorType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorType& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mActArrayActuatorType,
                       _0RL_RTC_mActArrayActuatorType_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mActArrayActuatorGeometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayActuatorGeometry* _p = (RTC::ActArrayActuatorGeometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayActuatorGeometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayActuatorGeometry* _p = new RTC::ActArrayActuatorGeometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActArrayActuatorGeometry_destructor_fn(void* _v)
{
  RTC::ActArrayActuatorGeometry* _p = (RTC::ActArrayActuatorGeometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorGeometry& _s)
{
  RTC::ActArrayActuatorGeometry* _p = new RTC::ActArrayActuatorGeometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorGeometry,
               _0RL_RTC_mActArrayActuatorGeometry_marshal_fn,
               _0RL_RTC_mActArrayActuatorGeometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorGeometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorGeometry,
               _0RL_RTC_mActArrayActuatorGeometry_marshal_fn,
               _0RL_RTC_mActArrayActuatorGeometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorGeometry*& _sp)
{
  return _a >>= (const RTC::ActArrayActuatorGeometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorGeometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActArrayActuatorGeometry,
                    _0RL_RTC_mActArrayActuatorGeometry_unmarshal_fn,
                    _0RL_RTC_mActArrayActuatorGeometry_marshal_fn,
                    _0RL_RTC_mActArrayActuatorGeometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActArrayActuatorGeometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActArrayActuatorGeometryList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayActuatorGeometryList* _p = (RTC::ActArrayActuatorGeometryList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayActuatorGeometryList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayActuatorGeometryList* _p = new RTC::ActArrayActuatorGeometryList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActArrayActuatorGeometryList_destructor_fn(void* _v)
{
  RTC::ActArrayActuatorGeometryList* _p = (RTC::ActArrayActuatorGeometryList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorGeometryList& _s)
{
  RTC::ActArrayActuatorGeometryList* _p = new RTC::ActArrayActuatorGeometryList(_s);
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorGeometryList,
               _0RL_RTC_mActArrayActuatorGeometryList_marshal_fn,
               _0RL_RTC_mActArrayActuatorGeometryList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorGeometryList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayActuatorGeometryList,
               _0RL_RTC_mActArrayActuatorGeometryList_marshal_fn,
               _0RL_RTC_mActArrayActuatorGeometryList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorGeometryList*& _sp)
{
  return _a >>= (const RTC::ActArrayActuatorGeometryList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorGeometryList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActArrayActuatorGeometryList,
                    _0RL_RTC_mActArrayActuatorGeometryList_unmarshal_fn,
                    _0RL_RTC_mActArrayActuatorGeometryList_marshal_fn,
                    _0RL_RTC_mActArrayActuatorGeometryList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActArrayActuatorGeometryList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mActArrayGeometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ActArrayGeometry* _p = (RTC::ActArrayGeometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mActArrayGeometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ActArrayGeometry* _p = new RTC::ActArrayGeometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mActArrayGeometry_destructor_fn(void* _v)
{
  RTC::ActArrayGeometry* _p = (RTC::ActArrayGeometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayGeometry& _s)
{
  RTC::ActArrayGeometry* _p = new RTC::ActArrayGeometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mActArrayGeometry,
               _0RL_RTC_mActArrayGeometry_marshal_fn,
               _0RL_RTC_mActArrayGeometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ActArrayGeometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mActArrayGeometry,
               _0RL_RTC_mActArrayGeometry_marshal_fn,
               _0RL_RTC_mActArrayGeometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayGeometry*& _sp)
{
  return _a >>= (const RTC::ActArrayGeometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayGeometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mActArrayGeometry,
                    _0RL_RTC_mActArrayGeometry_unmarshal_fn,
                    _0RL_RTC_mActArrayGeometry_marshal_fn,
                    _0RL_RTC_mActArrayGeometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::ActArrayGeometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mBumperGeometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::BumperGeometry* _p = (RTC::BumperGeometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mBumperGeometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::BumperGeometry* _p = new RTC::BumperGeometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mBumperGeometry_destructor_fn(void* _v)
{
  RTC::BumperGeometry* _p = (RTC::BumperGeometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::BumperGeometry& _s)
{
  RTC::BumperGeometry* _p = new RTC::BumperGeometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mBumperGeometry,
               _0RL_RTC_mBumperGeometry_marshal_fn,
               _0RL_RTC_mBumperGeometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::BumperGeometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mBumperGeometry,
               _0RL_RTC_mBumperGeometry_marshal_fn,
               _0RL_RTC_mBumperGeometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::BumperGeometry*& _sp)
{
  return _a >>= (const RTC::BumperGeometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::BumperGeometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mBumperGeometry,
                    _0RL_RTC_mBumperGeometry_unmarshal_fn,
                    _0RL_RTC_mBumperGeometry_marshal_fn,
                    _0RL_RTC_mBumperGeometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::BumperGeometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mBumperGeometryList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::BumperGeometryList* _p = (RTC::BumperGeometryList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mBumperGeometryList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::BumperGeometryList* _p = new RTC::BumperGeometryList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mBumperGeometryList_destructor_fn(void* _v)
{
  RTC::BumperGeometryList* _p = (RTC::BumperGeometryList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::BumperGeometryList& _s)
{
  RTC::BumperGeometryList* _p = new RTC::BumperGeometryList(_s);
  _a.PR_insert(_0RL_tc_RTC_mBumperGeometryList,
               _0RL_RTC_mBumperGeometryList_marshal_fn,
               _0RL_RTC_mBumperGeometryList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::BumperGeometryList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mBumperGeometryList,
               _0RL_RTC_mBumperGeometryList_marshal_fn,
               _0RL_RTC_mBumperGeometryList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::BumperGeometryList*& _sp)
{
  return _a >>= (const RTC::BumperGeometryList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::BumperGeometryList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mBumperGeometryList,
                    _0RL_RTC_mBumperGeometryList_unmarshal_fn,
                    _0RL_RTC_mBumperGeometryList_marshal_fn,
                    _0RL_RTC_mBumperGeometryList_destructor_fn,
                    _v)) {
    _sp = (const RTC::BumperGeometryList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mBumperArrayGeometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::BumperArrayGeometry* _p = (RTC::BumperArrayGeometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mBumperArrayGeometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::BumperArrayGeometry* _p = new RTC::BumperArrayGeometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mBumperArrayGeometry_destructor_fn(void* _v)
{
  RTC::BumperArrayGeometry* _p = (RTC::BumperArrayGeometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::BumperArrayGeometry& _s)
{
  RTC::BumperArrayGeometry* _p = new RTC::BumperArrayGeometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mBumperArrayGeometry,
               _0RL_RTC_mBumperArrayGeometry_marshal_fn,
               _0RL_RTC_mBumperArrayGeometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::BumperArrayGeometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mBumperArrayGeometry,
               _0RL_RTC_mBumperArrayGeometry_marshal_fn,
               _0RL_RTC_mBumperArrayGeometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::BumperArrayGeometry*& _sp)
{
  return _a >>= (const RTC::BumperArrayGeometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::BumperArrayGeometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mBumperArrayGeometry,
                    _0RL_RTC_mBumperArrayGeometry_unmarshal_fn,
                    _0RL_RTC_mBumperArrayGeometry_marshal_fn,
                    _0RL_RTC_mBumperArrayGeometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::BumperArrayGeometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mCameraImage_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::CameraImage* _p = (RTC::CameraImage*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mCameraImage_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::CameraImage* _p = new RTC::CameraImage;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mCameraImage_destructor_fn(void* _v)
{
  RTC::CameraImage* _p = (RTC::CameraImage*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::CameraImage& _s)
{
  RTC::CameraImage* _p = new RTC::CameraImage(_s);
  _a.PR_insert(_0RL_tc_RTC_mCameraImage,
               _0RL_RTC_mCameraImage_marshal_fn,
               _0RL_RTC_mCameraImage_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::CameraImage* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mCameraImage,
               _0RL_RTC_mCameraImage_marshal_fn,
               _0RL_RTC_mCameraImage_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::CameraImage*& _sp)
{
  return _a >>= (const RTC::CameraImage*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::CameraImage*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mCameraImage,
                    _0RL_RTC_mCameraImage_unmarshal_fn,
                    _0RL_RTC_mCameraImage_marshal_fn,
                    _0RL_RTC_mCameraImage_destructor_fn,
                    _v)) {
    _sp = (const RTC::CameraImage*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mCameraInfo_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::CameraInfo* _p = (RTC::CameraInfo*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mCameraInfo_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::CameraInfo* _p = new RTC::CameraInfo;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mCameraInfo_destructor_fn(void* _v)
{
  RTC::CameraInfo* _p = (RTC::CameraInfo*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::CameraInfo& _s)
{
  RTC::CameraInfo* _p = new RTC::CameraInfo(_s);
  _a.PR_insert(_0RL_tc_RTC_mCameraInfo,
               _0RL_RTC_mCameraInfo_marshal_fn,
               _0RL_RTC_mCameraInfo_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::CameraInfo* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mCameraInfo,
               _0RL_RTC_mCameraInfo_marshal_fn,
               _0RL_RTC_mCameraInfo_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::CameraInfo*& _sp)
{
  return _a >>= (const RTC::CameraInfo*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::CameraInfo*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mCameraInfo,
                    _0RL_RTC_mCameraInfo_unmarshal_fn,
                    _0RL_RTC_mCameraInfo_marshal_fn,
                    _0RL_RTC_mCameraInfo_destructor_fn,
                    _v)) {
    _sp = (const RTC::CameraInfo*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFiducialInfo_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FiducialInfo* _p = (RTC::FiducialInfo*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFiducialInfo_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FiducialInfo* _p = new RTC::FiducialInfo;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFiducialInfo_destructor_fn(void* _v)
{
  RTC::FiducialInfo* _p = (RTC::FiducialInfo*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FiducialInfo& _s)
{
  RTC::FiducialInfo* _p = new RTC::FiducialInfo(_s);
  _a.PR_insert(_0RL_tc_RTC_mFiducialInfo,
               _0RL_RTC_mFiducialInfo_marshal_fn,
               _0RL_RTC_mFiducialInfo_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FiducialInfo* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFiducialInfo,
               _0RL_RTC_mFiducialInfo_marshal_fn,
               _0RL_RTC_mFiducialInfo_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FiducialInfo*& _sp)
{
  return _a >>= (const RTC::FiducialInfo*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FiducialInfo*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFiducialInfo,
                    _0RL_RTC_mFiducialInfo_unmarshal_fn,
                    _0RL_RTC_mFiducialInfo_marshal_fn,
                    _0RL_RTC_mFiducialInfo_destructor_fn,
                    _v)) {
    _sp = (const RTC::FiducialInfo*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFiducialInfoList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FiducialInfoList* _p = (RTC::FiducialInfoList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFiducialInfoList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FiducialInfoList* _p = new RTC::FiducialInfoList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFiducialInfoList_destructor_fn(void* _v)
{
  RTC::FiducialInfoList* _p = (RTC::FiducialInfoList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FiducialInfoList& _s)
{
  RTC::FiducialInfoList* _p = new RTC::FiducialInfoList(_s);
  _a.PR_insert(_0RL_tc_RTC_mFiducialInfoList,
               _0RL_RTC_mFiducialInfoList_marshal_fn,
               _0RL_RTC_mFiducialInfoList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FiducialInfoList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFiducialInfoList,
               _0RL_RTC_mFiducialInfoList_marshal_fn,
               _0RL_RTC_mFiducialInfoList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FiducialInfoList*& _sp)
{
  return _a >>= (const RTC::FiducialInfoList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FiducialInfoList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFiducialInfoList,
                    _0RL_RTC_mFiducialInfoList_unmarshal_fn,
                    _0RL_RTC_mFiducialInfoList_marshal_fn,
                    _0RL_RTC_mFiducialInfoList_destructor_fn,
                    _v)) {
    _sp = (const RTC::FiducialInfoList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFiducials_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Fiducials* _p = (RTC::Fiducials*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFiducials_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Fiducials* _p = new RTC::Fiducials;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFiducials_destructor_fn(void* _v)
{
  RTC::Fiducials* _p = (RTC::Fiducials*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Fiducials& _s)
{
  RTC::Fiducials* _p = new RTC::Fiducials(_s);
  _a.PR_insert(_0RL_tc_RTC_mFiducials,
               _0RL_RTC_mFiducials_marshal_fn,
               _0RL_RTC_mFiducials_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Fiducials* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFiducials,
               _0RL_RTC_mFiducials_marshal_fn,
               _0RL_RTC_mFiducials_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Fiducials*& _sp)
{
  return _a >>= (const RTC::Fiducials*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Fiducials*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFiducials,
                    _0RL_RTC_mFiducials_unmarshal_fn,
                    _0RL_RTC_mFiducials_marshal_fn,
                    _0RL_RTC_mFiducials_destructor_fn,
                    _v)) {
    _sp = (const RTC::Fiducials*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFiducialFOV_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FiducialFOV* _p = (RTC::FiducialFOV*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFiducialFOV_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FiducialFOV* _p = new RTC::FiducialFOV;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFiducialFOV_destructor_fn(void* _v)
{
  RTC::FiducialFOV* _p = (RTC::FiducialFOV*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FiducialFOV& _s)
{
  RTC::FiducialFOV* _p = new RTC::FiducialFOV(_s);
  _a.PR_insert(_0RL_tc_RTC_mFiducialFOV,
               _0RL_RTC_mFiducialFOV_marshal_fn,
               _0RL_RTC_mFiducialFOV_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FiducialFOV* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFiducialFOV,
               _0RL_RTC_mFiducialFOV_marshal_fn,
               _0RL_RTC_mFiducialFOV_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FiducialFOV*& _sp)
{
  return _a >>= (const RTC::FiducialFOV*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FiducialFOV*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFiducialFOV,
                    _0RL_RTC_mFiducialFOV_unmarshal_fn,
                    _0RL_RTC_mFiducialFOV_marshal_fn,
                    _0RL_RTC_mFiducialFOV_destructor_fn,
                    _v)) {
    _sp = (const RTC::FiducialFOV*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGPSTime_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::GPSTime* _p = (RTC::GPSTime*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGPSTime_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::GPSTime* _p = new RTC::GPSTime;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGPSTime_destructor_fn(void* _v)
{
  RTC::GPSTime* _p = (RTC::GPSTime*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::GPSTime& _s)
{
  RTC::GPSTime* _p = new RTC::GPSTime(_s);
  _a.PR_insert(_0RL_tc_RTC_mGPSTime,
               _0RL_RTC_mGPSTime_marshal_fn,
               _0RL_RTC_mGPSTime_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::GPSTime* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGPSTime,
               _0RL_RTC_mGPSTime_marshal_fn,
               _0RL_RTC_mGPSTime_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::GPSTime*& _sp)
{
  return _a >>= (const RTC::GPSTime*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GPSTime*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGPSTime,
                    _0RL_RTC_mGPSTime_unmarshal_fn,
                    _0RL_RTC_mGPSTime_marshal_fn,
                    _0RL_RTC_mGPSTime_destructor_fn,
                    _v)) {
    _sp = (const RTC::GPSTime*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGPSFixType_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::GPSFixType* _p = (RTC::GPSFixType*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGPSFixType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::GPSFixType* _p = (RTC::GPSFixType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::GPSFixType _s)
{
  _a.PR_insert(_0RL_tc_RTC_mGPSFixType,
               _0RL_RTC_mGPSFixType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::GPSFixType& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mGPSFixType,
                       _0RL_RTC_mGPSFixType_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mGPSData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::GPSData* _p = (RTC::GPSData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGPSData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::GPSData* _p = new RTC::GPSData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGPSData_destructor_fn(void* _v)
{
  RTC::GPSData* _p = (RTC::GPSData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::GPSData& _s)
{
  RTC::GPSData* _p = new RTC::GPSData(_s);
  _a.PR_insert(_0RL_tc_RTC_mGPSData,
               _0RL_RTC_mGPSData_marshal_fn,
               _0RL_RTC_mGPSData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::GPSData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGPSData,
               _0RL_RTC_mGPSData_marshal_fn,
               _0RL_RTC_mGPSData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::GPSData*& _sp)
{
  return _a >>= (const RTC::GPSData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GPSData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGPSData,
                    _0RL_RTC_mGPSData_unmarshal_fn,
                    _0RL_RTC_mGPSData_marshal_fn,
                    _0RL_RTC_mGPSData_destructor_fn,
                    _v)) {
    _sp = (const RTC::GPSData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGripperStatus_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::GripperStatus* _p = (RTC::GripperStatus*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGripperStatus_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::GripperStatus* _p = (RTC::GripperStatus*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::GripperStatus _s)
{
  _a.PR_insert(_0RL_tc_RTC_mGripperStatus,
               _0RL_RTC_mGripperStatus_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::GripperStatus& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mGripperStatus,
                       _0RL_RTC_mGripperStatus_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mGripperState_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::GripperState* _p = (RTC::GripperState*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGripperState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::GripperState* _p = new RTC::GripperState;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGripperState_destructor_fn(void* _v)
{
  RTC::GripperState* _p = (RTC::GripperState*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::GripperState& _s)
{
  RTC::GripperState* _p = new RTC::GripperState(_s);
  _a.PR_insert(_0RL_tc_RTC_mGripperState,
               _0RL_RTC_mGripperState_marshal_fn,
               _0RL_RTC_mGripperState_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::GripperState* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGripperState,
               _0RL_RTC_mGripperState_marshal_fn,
               _0RL_RTC_mGripperState_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::GripperState*& _sp)
{
  return _a >>= (const RTC::GripperState*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GripperState*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGripperState,
                    _0RL_RTC_mGripperState_unmarshal_fn,
                    _0RL_RTC_mGripperState_marshal_fn,
                    _0RL_RTC_mGripperState_destructor_fn,
                    _v)) {
    _sp = (const RTC::GripperState*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGripperGeometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::GripperGeometry* _p = (RTC::GripperGeometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGripperGeometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::GripperGeometry* _p = new RTC::GripperGeometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGripperGeometry_destructor_fn(void* _v)
{
  RTC::GripperGeometry* _p = (RTC::GripperGeometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::GripperGeometry& _s)
{
  RTC::GripperGeometry* _p = new RTC::GripperGeometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mGripperGeometry,
               _0RL_RTC_mGripperGeometry_marshal_fn,
               _0RL_RTC_mGripperGeometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::GripperGeometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGripperGeometry,
               _0RL_RTC_mGripperGeometry_marshal_fn,
               _0RL_RTC_mGripperGeometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::GripperGeometry*& _sp)
{
  return _a >>= (const RTC::GripperGeometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GripperGeometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGripperGeometry,
                    _0RL_RTC_mGripperGeometry_unmarshal_fn,
                    _0RL_RTC_mGripperGeometry_marshal_fn,
                    _0RL_RTC_mGripperGeometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::GripperGeometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mINSData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::INSData* _p = (RTC::INSData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mINSData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::INSData* _p = new RTC::INSData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mINSData_destructor_fn(void* _v)
{
  RTC::INSData* _p = (RTC::INSData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::INSData& _s)
{
  RTC::INSData* _p = new RTC::INSData(_s);
  _a.PR_insert(_0RL_tc_RTC_mINSData,
               _0RL_RTC_mINSData_marshal_fn,
               _0RL_RTC_mINSData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::INSData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mINSData,
               _0RL_RTC_mINSData_marshal_fn,
               _0RL_RTC_mINSData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::INSData*& _sp)
{
  return _a >>= (const RTC::INSData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::INSData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mINSData,
                    _0RL_RTC_mINSData_unmarshal_fn,
                    _0RL_RTC_mINSData_marshal_fn,
                    _0RL_RTC_mINSData_destructor_fn,
                    _v)) {
    _sp = (const RTC::INSData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mLimbStatus_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::LimbStatus* _p = (RTC::LimbStatus*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mLimbStatus_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::LimbStatus* _p = (RTC::LimbStatus*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::LimbStatus _s)
{
  _a.PR_insert(_0RL_tc_RTC_mLimbStatus,
               _0RL_RTC_mLimbStatus_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::LimbStatus& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mLimbStatus,
                       _0RL_RTC_mLimbStatus_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mLimbState_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::LimbState* _p = (RTC::LimbState*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mLimbState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::LimbState* _p = new RTC::LimbState;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mLimbState_destructor_fn(void* _v)
{
  RTC::LimbState* _p = (RTC::LimbState*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::LimbState& _s)
{
  RTC::LimbState* _p = new RTC::LimbState(_s);
  _a.PR_insert(_0RL_tc_RTC_mLimbState,
               _0RL_RTC_mLimbState_marshal_fn,
               _0RL_RTC_mLimbState_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::LimbState* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mLimbState,
               _0RL_RTC_mLimbState_marshal_fn,
               _0RL_RTC_mLimbState_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::LimbState*& _sp)
{
  return _a >>= (const RTC::LimbState*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::LimbState*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mLimbState,
                    _0RL_RTC_mLimbState_unmarshal_fn,
                    _0RL_RTC_mLimbState_marshal_fn,
                    _0RL_RTC_mLimbState_destructor_fn,
                    _v)) {
    _sp = (const RTC::LimbState*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mHypothesis2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Hypothesis2D* _p = (RTC::Hypothesis2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mHypothesis2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Hypothesis2D* _p = new RTC::Hypothesis2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mHypothesis2D_destructor_fn(void* _v)
{
  RTC::Hypothesis2D* _p = (RTC::Hypothesis2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis2D& _s)
{
  RTC::Hypothesis2D* _p = new RTC::Hypothesis2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mHypothesis2D,
               _0RL_RTC_mHypothesis2D_marshal_fn,
               _0RL_RTC_mHypothesis2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Hypothesis2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mHypothesis2D,
               _0RL_RTC_mHypothesis2D_marshal_fn,
               _0RL_RTC_mHypothesis2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis2D*& _sp)
{
  return _a >>= (const RTC::Hypothesis2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mHypothesis2D,
                    _0RL_RTC_mHypothesis2D_unmarshal_fn,
                    _0RL_RTC_mHypothesis2D_marshal_fn,
                    _0RL_RTC_mHypothesis2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Hypothesis2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mHypothesis2DList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Hypothesis2DList* _p = (RTC::Hypothesis2DList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mHypothesis2DList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Hypothesis2DList* _p = new RTC::Hypothesis2DList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mHypothesis2DList_destructor_fn(void* _v)
{
  RTC::Hypothesis2DList* _p = (RTC::Hypothesis2DList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis2DList& _s)
{
  RTC::Hypothesis2DList* _p = new RTC::Hypothesis2DList(_s);
  _a.PR_insert(_0RL_tc_RTC_mHypothesis2DList,
               _0RL_RTC_mHypothesis2DList_marshal_fn,
               _0RL_RTC_mHypothesis2DList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Hypothesis2DList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mHypothesis2DList,
               _0RL_RTC_mHypothesis2DList_marshal_fn,
               _0RL_RTC_mHypothesis2DList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis2DList*& _sp)
{
  return _a >>= (const RTC::Hypothesis2DList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis2DList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mHypothesis2DList,
                    _0RL_RTC_mHypothesis2DList_unmarshal_fn,
                    _0RL_RTC_mHypothesis2DList_marshal_fn,
                    _0RL_RTC_mHypothesis2DList_destructor_fn,
                    _v)) {
    _sp = (const RTC::Hypothesis2DList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mHypotheses2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Hypotheses2D* _p = (RTC::Hypotheses2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mHypotheses2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Hypotheses2D* _p = new RTC::Hypotheses2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mHypotheses2D_destructor_fn(void* _v)
{
  RTC::Hypotheses2D* _p = (RTC::Hypotheses2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Hypotheses2D& _s)
{
  RTC::Hypotheses2D* _p = new RTC::Hypotheses2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mHypotheses2D,
               _0RL_RTC_mHypotheses2D_marshal_fn,
               _0RL_RTC_mHypotheses2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Hypotheses2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mHypotheses2D,
               _0RL_RTC_mHypotheses2D_marshal_fn,
               _0RL_RTC_mHypotheses2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypotheses2D*& _sp)
{
  return _a >>= (const RTC::Hypotheses2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypotheses2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mHypotheses2D,
                    _0RL_RTC_mHypotheses2D_unmarshal_fn,
                    _0RL_RTC_mHypotheses2D_marshal_fn,
                    _0RL_RTC_mHypotheses2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Hypotheses2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mHypothesis3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Hypothesis3D* _p = (RTC::Hypothesis3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mHypothesis3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Hypothesis3D* _p = new RTC::Hypothesis3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mHypothesis3D_destructor_fn(void* _v)
{
  RTC::Hypothesis3D* _p = (RTC::Hypothesis3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis3D& _s)
{
  RTC::Hypothesis3D* _p = new RTC::Hypothesis3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mHypothesis3D,
               _0RL_RTC_mHypothesis3D_marshal_fn,
               _0RL_RTC_mHypothesis3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Hypothesis3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mHypothesis3D,
               _0RL_RTC_mHypothesis3D_marshal_fn,
               _0RL_RTC_mHypothesis3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis3D*& _sp)
{
  return _a >>= (const RTC::Hypothesis3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mHypothesis3D,
                    _0RL_RTC_mHypothesis3D_unmarshal_fn,
                    _0RL_RTC_mHypothesis3D_marshal_fn,
                    _0RL_RTC_mHypothesis3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Hypothesis3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mHypothesis3DList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Hypothesis3DList* _p = (RTC::Hypothesis3DList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mHypothesis3DList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Hypothesis3DList* _p = new RTC::Hypothesis3DList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mHypothesis3DList_destructor_fn(void* _v)
{
  RTC::Hypothesis3DList* _p = (RTC::Hypothesis3DList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis3DList& _s)
{
  RTC::Hypothesis3DList* _p = new RTC::Hypothesis3DList(_s);
  _a.PR_insert(_0RL_tc_RTC_mHypothesis3DList,
               _0RL_RTC_mHypothesis3DList_marshal_fn,
               _0RL_RTC_mHypothesis3DList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Hypothesis3DList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mHypothesis3DList,
               _0RL_RTC_mHypothesis3DList_marshal_fn,
               _0RL_RTC_mHypothesis3DList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis3DList*& _sp)
{
  return _a >>= (const RTC::Hypothesis3DList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis3DList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mHypothesis3DList,
                    _0RL_RTC_mHypothesis3DList_unmarshal_fn,
                    _0RL_RTC_mHypothesis3DList_marshal_fn,
                    _0RL_RTC_mHypothesis3DList_destructor_fn,
                    _v)) {
    _sp = (const RTC::Hypothesis3DList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mHypotheses3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Hypotheses3D* _p = (RTC::Hypotheses3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mHypotheses3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Hypotheses3D* _p = new RTC::Hypotheses3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mHypotheses3D_destructor_fn(void* _v)
{
  RTC::Hypotheses3D* _p = (RTC::Hypotheses3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Hypotheses3D& _s)
{
  RTC::Hypotheses3D* _p = new RTC::Hypotheses3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mHypotheses3D,
               _0RL_RTC_mHypotheses3D_marshal_fn,
               _0RL_RTC_mHypotheses3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Hypotheses3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mHypotheses3D,
               _0RL_RTC_mHypotheses3D_marshal_fn,
               _0RL_RTC_mHypotheses3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypotheses3D*& _sp)
{
  return _a >>= (const RTC::Hypotheses3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypotheses3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mHypotheses3D,
                    _0RL_RTC_mHypotheses3D_unmarshal_fn,
                    _0RL_RTC_mHypotheses3D_marshal_fn,
                    _0RL_RTC_mHypotheses3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Hypotheses3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mOGMapConfig_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::OGMapConfig* _p = (RTC::OGMapConfig*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mOGMapConfig_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::OGMapConfig* _p = new RTC::OGMapConfig;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mOGMapConfig_destructor_fn(void* _v)
{
  RTC::OGMapConfig* _p = (RTC::OGMapConfig*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::OGMapConfig& _s)
{
  RTC::OGMapConfig* _p = new RTC::OGMapConfig(_s);
  _a.PR_insert(_0RL_tc_RTC_mOGMapConfig,
               _0RL_RTC_mOGMapConfig_marshal_fn,
               _0RL_RTC_mOGMapConfig_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::OGMapConfig* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mOGMapConfig,
               _0RL_RTC_mOGMapConfig_marshal_fn,
               _0RL_RTC_mOGMapConfig_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapConfig*& _sp)
{
  return _a >>= (const RTC::OGMapConfig*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OGMapConfig*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mOGMapConfig,
                    _0RL_RTC_mOGMapConfig_unmarshal_fn,
                    _0RL_RTC_mOGMapConfig_marshal_fn,
                    _0RL_RTC_mOGMapConfig_destructor_fn,
                    _v)) {
    _sp = (const RTC::OGMapConfig*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mOGMapCells_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::OGMapCells* _p = (RTC::OGMapCells*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mOGMapCells_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::OGMapCells* _p = new RTC::OGMapCells;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mOGMapCells_destructor_fn(void* _v)
{
  RTC::OGMapCells* _p = (RTC::OGMapCells*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::OGMapCells& _s)
{
  RTC::OGMapCells* _p = new RTC::OGMapCells(_s);
  _a.PR_insert(_0RL_tc_RTC_mOGMapCells,
               _0RL_RTC_mOGMapCells_marshal_fn,
               _0RL_RTC_mOGMapCells_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::OGMapCells* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mOGMapCells,
               _0RL_RTC_mOGMapCells_marshal_fn,
               _0RL_RTC_mOGMapCells_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapCells*& _sp)
{
  return _a >>= (const RTC::OGMapCells*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OGMapCells*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mOGMapCells,
                    _0RL_RTC_mOGMapCells_unmarshal_fn,
                    _0RL_RTC_mOGMapCells_marshal_fn,
                    _0RL_RTC_mOGMapCells_destructor_fn,
                    _v)) {
    _sp = (const RTC::OGMapCells*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mOGMapTile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::OGMapTile* _p = (RTC::OGMapTile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mOGMapTile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::OGMapTile* _p = new RTC::OGMapTile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mOGMapTile_destructor_fn(void* _v)
{
  RTC::OGMapTile* _p = (RTC::OGMapTile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::OGMapTile& _s)
{
  RTC::OGMapTile* _p = new RTC::OGMapTile(_s);
  _a.PR_insert(_0RL_tc_RTC_mOGMapTile,
               _0RL_RTC_mOGMapTile_marshal_fn,
               _0RL_RTC_mOGMapTile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::OGMapTile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mOGMapTile,
               _0RL_RTC_mOGMapTile_marshal_fn,
               _0RL_RTC_mOGMapTile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapTile*& _sp)
{
  return _a >>= (const RTC::OGMapTile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OGMapTile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mOGMapTile,
                    _0RL_RTC_mOGMapTile_unmarshal_fn,
                    _0RL_RTC_mOGMapTile_marshal_fn,
                    _0RL_RTC_mOGMapTile_destructor_fn,
                    _v)) {
    _sp = (const RTC::OGMapTile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPointFeature_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PointFeature* _p = (RTC::PointFeature*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPointFeature_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PointFeature* _p = new RTC::PointFeature;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPointFeature_destructor_fn(void* _v)
{
  RTC::PointFeature* _p = (RTC::PointFeature*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PointFeature& _s)
{
  RTC::PointFeature* _p = new RTC::PointFeature(_s);
  _a.PR_insert(_0RL_tc_RTC_mPointFeature,
               _0RL_RTC_mPointFeature_marshal_fn,
               _0RL_RTC_mPointFeature_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PointFeature* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPointFeature,
               _0RL_RTC_mPointFeature_marshal_fn,
               _0RL_RTC_mPointFeature_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointFeature*& _sp)
{
  return _a >>= (const RTC::PointFeature*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointFeature*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPointFeature,
                    _0RL_RTC_mPointFeature_unmarshal_fn,
                    _0RL_RTC_mPointFeature_marshal_fn,
                    _0RL_RTC_mPointFeature_destructor_fn,
                    _v)) {
    _sp = (const RTC::PointFeature*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPointFeatureList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PointFeatureList* _p = (RTC::PointFeatureList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPointFeatureList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PointFeatureList* _p = new RTC::PointFeatureList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPointFeatureList_destructor_fn(void* _v)
{
  RTC::PointFeatureList* _p = (RTC::PointFeatureList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PointFeatureList& _s)
{
  RTC::PointFeatureList* _p = new RTC::PointFeatureList(_s);
  _a.PR_insert(_0RL_tc_RTC_mPointFeatureList,
               _0RL_RTC_mPointFeatureList_marshal_fn,
               _0RL_RTC_mPointFeatureList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PointFeatureList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPointFeatureList,
               _0RL_RTC_mPointFeatureList_marshal_fn,
               _0RL_RTC_mPointFeatureList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointFeatureList*& _sp)
{
  return _a >>= (const RTC::PointFeatureList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointFeatureList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPointFeatureList,
                    _0RL_RTC_mPointFeatureList_unmarshal_fn,
                    _0RL_RTC_mPointFeatureList_marshal_fn,
                    _0RL_RTC_mPointFeatureList_destructor_fn,
                    _v)) {
    _sp = (const RTC::PointFeatureList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPoseFeature_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PoseFeature* _p = (RTC::PoseFeature*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPoseFeature_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PoseFeature* _p = new RTC::PoseFeature;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPoseFeature_destructor_fn(void* _v)
{
  RTC::PoseFeature* _p = (RTC::PoseFeature*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PoseFeature& _s)
{
  RTC::PoseFeature* _p = new RTC::PoseFeature(_s);
  _a.PR_insert(_0RL_tc_RTC_mPoseFeature,
               _0RL_RTC_mPoseFeature_marshal_fn,
               _0RL_RTC_mPoseFeature_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PoseFeature* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPoseFeature,
               _0RL_RTC_mPoseFeature_marshal_fn,
               _0RL_RTC_mPoseFeature_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PoseFeature*& _sp)
{
  return _a >>= (const RTC::PoseFeature*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PoseFeature*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPoseFeature,
                    _0RL_RTC_mPoseFeature_unmarshal_fn,
                    _0RL_RTC_mPoseFeature_marshal_fn,
                    _0RL_RTC_mPoseFeature_destructor_fn,
                    _v)) {
    _sp = (const RTC::PoseFeature*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPoseFeatureList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PoseFeatureList* _p = (RTC::PoseFeatureList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPoseFeatureList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PoseFeatureList* _p = new RTC::PoseFeatureList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPoseFeatureList_destructor_fn(void* _v)
{
  RTC::PoseFeatureList* _p = (RTC::PoseFeatureList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PoseFeatureList& _s)
{
  RTC::PoseFeatureList* _p = new RTC::PoseFeatureList(_s);
  _a.PR_insert(_0RL_tc_RTC_mPoseFeatureList,
               _0RL_RTC_mPoseFeatureList_marshal_fn,
               _0RL_RTC_mPoseFeatureList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PoseFeatureList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPoseFeatureList,
               _0RL_RTC_mPoseFeatureList_marshal_fn,
               _0RL_RTC_mPoseFeatureList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PoseFeatureList*& _sp)
{
  return _a >>= (const RTC::PoseFeatureList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PoseFeatureList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPoseFeatureList,
                    _0RL_RTC_mPoseFeatureList_unmarshal_fn,
                    _0RL_RTC_mPoseFeatureList_marshal_fn,
                    _0RL_RTC_mPoseFeatureList_destructor_fn,
                    _v)) {
    _sp = (const RTC::PoseFeatureList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mLineFeature_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::LineFeature* _p = (RTC::LineFeature*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mLineFeature_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::LineFeature* _p = new RTC::LineFeature;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mLineFeature_destructor_fn(void* _v)
{
  RTC::LineFeature* _p = (RTC::LineFeature*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::LineFeature& _s)
{
  RTC::LineFeature* _p = new RTC::LineFeature(_s);
  _a.PR_insert(_0RL_tc_RTC_mLineFeature,
               _0RL_RTC_mLineFeature_marshal_fn,
               _0RL_RTC_mLineFeature_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::LineFeature* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mLineFeature,
               _0RL_RTC_mLineFeature_marshal_fn,
               _0RL_RTC_mLineFeature_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::LineFeature*& _sp)
{
  return _a >>= (const RTC::LineFeature*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::LineFeature*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mLineFeature,
                    _0RL_RTC_mLineFeature_unmarshal_fn,
                    _0RL_RTC_mLineFeature_marshal_fn,
                    _0RL_RTC_mLineFeature_destructor_fn,
                    _v)) {
    _sp = (const RTC::LineFeature*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mLineFeatureList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::LineFeatureList* _p = (RTC::LineFeatureList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mLineFeatureList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::LineFeatureList* _p = new RTC::LineFeatureList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mLineFeatureList_destructor_fn(void* _v)
{
  RTC::LineFeatureList* _p = (RTC::LineFeatureList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::LineFeatureList& _s)
{
  RTC::LineFeatureList* _p = new RTC::LineFeatureList(_s);
  _a.PR_insert(_0RL_tc_RTC_mLineFeatureList,
               _0RL_RTC_mLineFeatureList_marshal_fn,
               _0RL_RTC_mLineFeatureList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::LineFeatureList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mLineFeatureList,
               _0RL_RTC_mLineFeatureList_marshal_fn,
               _0RL_RTC_mLineFeatureList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::LineFeatureList*& _sp)
{
  return _a >>= (const RTC::LineFeatureList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::LineFeatureList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mLineFeatureList,
                    _0RL_RTC_mLineFeatureList_unmarshal_fn,
                    _0RL_RTC_mLineFeatureList_marshal_fn,
                    _0RL_RTC_mLineFeatureList_destructor_fn,
                    _v)) {
    _sp = (const RTC::LineFeatureList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFeatures_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Features* _p = (RTC::Features*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFeatures_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Features* _p = new RTC::Features;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFeatures_destructor_fn(void* _v)
{
  RTC::Features* _p = (RTC::Features*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Features& _s)
{
  RTC::Features* _p = new RTC::Features(_s);
  _a.PR_insert(_0RL_tc_RTC_mFeatures,
               _0RL_RTC_mFeatures_marshal_fn,
               _0RL_RTC_mFeatures_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Features* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFeatures,
               _0RL_RTC_mFeatures_marshal_fn,
               _0RL_RTC_mFeatures_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Features*& _sp)
{
  return _a >>= (const RTC::Features*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Features*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFeatures,
                    _0RL_RTC_mFeatures_unmarshal_fn,
                    _0RL_RTC_mFeatures_marshal_fn,
                    _0RL_RTC_mFeatures_destructor_fn,
                    _v)) {
    _sp = (const RTC::Features*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMulticameraImageList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::MulticameraImageList* _p = (RTC::MulticameraImageList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mMulticameraImageList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::MulticameraImageList* _p = new RTC::MulticameraImageList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mMulticameraImageList_destructor_fn(void* _v)
{
  RTC::MulticameraImageList* _p = (RTC::MulticameraImageList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::MulticameraImageList& _s)
{
  RTC::MulticameraImageList* _p = new RTC::MulticameraImageList(_s);
  _a.PR_insert(_0RL_tc_RTC_mMulticameraImageList,
               _0RL_RTC_mMulticameraImageList_marshal_fn,
               _0RL_RTC_mMulticameraImageList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::MulticameraImageList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mMulticameraImageList,
               _0RL_RTC_mMulticameraImageList_marshal_fn,
               _0RL_RTC_mMulticameraImageList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraImageList*& _sp)
{
  return _a >>= (const RTC::MulticameraImageList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraImageList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mMulticameraImageList,
                    _0RL_RTC_mMulticameraImageList_unmarshal_fn,
                    _0RL_RTC_mMulticameraImageList_marshal_fn,
                    _0RL_RTC_mMulticameraImageList_destructor_fn,
                    _v)) {
    _sp = (const RTC::MulticameraImageList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMultiCameraImages_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::MultiCameraImages* _p = (RTC::MultiCameraImages*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mMultiCameraImages_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::MultiCameraImages* _p = new RTC::MultiCameraImages;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mMultiCameraImages_destructor_fn(void* _v)
{
  RTC::MultiCameraImages* _p = (RTC::MultiCameraImages*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::MultiCameraImages& _s)
{
  RTC::MultiCameraImages* _p = new RTC::MultiCameraImages(_s);
  _a.PR_insert(_0RL_tc_RTC_mMultiCameraImages,
               _0RL_RTC_mMultiCameraImages_marshal_fn,
               _0RL_RTC_mMultiCameraImages_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::MultiCameraImages* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mMultiCameraImages,
               _0RL_RTC_mMultiCameraImages_marshal_fn,
               _0RL_RTC_mMultiCameraImages_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MultiCameraImages*& _sp)
{
  return _a >>= (const RTC::MultiCameraImages*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MultiCameraImages*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mMultiCameraImages,
                    _0RL_RTC_mMultiCameraImages_unmarshal_fn,
                    _0RL_RTC_mMultiCameraImages_marshal_fn,
                    _0RL_RTC_mMultiCameraImages_destructor_fn,
                    _v)) {
    _sp = (const RTC::MultiCameraImages*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMulticameraInfoList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::MulticameraInfoList* _p = (RTC::MulticameraInfoList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mMulticameraInfoList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::MulticameraInfoList* _p = new RTC::MulticameraInfoList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mMulticameraInfoList_destructor_fn(void* _v)
{
  RTC::MulticameraInfoList* _p = (RTC::MulticameraInfoList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::MulticameraInfoList& _s)
{
  RTC::MulticameraInfoList* _p = new RTC::MulticameraInfoList(_s);
  _a.PR_insert(_0RL_tc_RTC_mMulticameraInfoList,
               _0RL_RTC_mMulticameraInfoList_marshal_fn,
               _0RL_RTC_mMulticameraInfoList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::MulticameraInfoList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mMulticameraInfoList,
               _0RL_RTC_mMulticameraInfoList_marshal_fn,
               _0RL_RTC_mMulticameraInfoList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraInfoList*& _sp)
{
  return _a >>= (const RTC::MulticameraInfoList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraInfoList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mMulticameraInfoList,
                    _0RL_RTC_mMulticameraInfoList_unmarshal_fn,
                    _0RL_RTC_mMulticameraInfoList_marshal_fn,
                    _0RL_RTC_mMulticameraInfoList_destructor_fn,
                    _v)) {
    _sp = (const RTC::MulticameraInfoList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMulticameraGeometryList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::MulticameraGeometryList* _p = (RTC::MulticameraGeometryList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mMulticameraGeometryList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::MulticameraGeometryList* _p = new RTC::MulticameraGeometryList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mMulticameraGeometryList_destructor_fn(void* _v)
{
  RTC::MulticameraGeometryList* _p = (RTC::MulticameraGeometryList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::MulticameraGeometryList& _s)
{
  RTC::MulticameraGeometryList* _p = new RTC::MulticameraGeometryList(_s);
  _a.PR_insert(_0RL_tc_RTC_mMulticameraGeometryList,
               _0RL_RTC_mMulticameraGeometryList_marshal_fn,
               _0RL_RTC_mMulticameraGeometryList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::MulticameraGeometryList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mMulticameraGeometryList,
               _0RL_RTC_mMulticameraGeometryList_marshal_fn,
               _0RL_RTC_mMulticameraGeometryList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraGeometryList*& _sp)
{
  return _a >>= (const RTC::MulticameraGeometryList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraGeometryList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mMulticameraGeometryList,
                    _0RL_RTC_mMulticameraGeometryList_unmarshal_fn,
                    _0RL_RTC_mMulticameraGeometryList_marshal_fn,
                    _0RL_RTC_mMulticameraGeometryList_destructor_fn,
                    _v)) {
    _sp = (const RTC::MulticameraGeometryList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMulticameraGeometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::MulticameraGeometry* _p = (RTC::MulticameraGeometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mMulticameraGeometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::MulticameraGeometry* _p = new RTC::MulticameraGeometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mMulticameraGeometry_destructor_fn(void* _v)
{
  RTC::MulticameraGeometry* _p = (RTC::MulticameraGeometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::MulticameraGeometry& _s)
{
  RTC::MulticameraGeometry* _p = new RTC::MulticameraGeometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mMulticameraGeometry,
               _0RL_RTC_mMulticameraGeometry_marshal_fn,
               _0RL_RTC_mMulticameraGeometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::MulticameraGeometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mMulticameraGeometry,
               _0RL_RTC_mMulticameraGeometry_marshal_fn,
               _0RL_RTC_mMulticameraGeometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraGeometry*& _sp)
{
  return _a >>= (const RTC::MulticameraGeometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraGeometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mMulticameraGeometry,
                    _0RL_RTC_mMulticameraGeometry_unmarshal_fn,
                    _0RL_RTC_mMulticameraGeometry_marshal_fn,
                    _0RL_RTC_mMulticameraGeometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::MulticameraGeometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mWaypoint2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Waypoint2D* _p = (RTC::Waypoint2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mWaypoint2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Waypoint2D* _p = new RTC::Waypoint2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mWaypoint2D_destructor_fn(void* _v)
{
  RTC::Waypoint2D* _p = (RTC::Waypoint2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Waypoint2D& _s)
{
  RTC::Waypoint2D* _p = new RTC::Waypoint2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mWaypoint2D,
               _0RL_RTC_mWaypoint2D_marshal_fn,
               _0RL_RTC_mWaypoint2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Waypoint2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mWaypoint2D,
               _0RL_RTC_mWaypoint2D_marshal_fn,
               _0RL_RTC_mWaypoint2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint2D*& _sp)
{
  return _a >>= (const RTC::Waypoint2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mWaypoint2D,
                    _0RL_RTC_mWaypoint2D_unmarshal_fn,
                    _0RL_RTC_mWaypoint2D_marshal_fn,
                    _0RL_RTC_mWaypoint2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Waypoint2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mWaypoint2DList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Waypoint2DList* _p = (RTC::Waypoint2DList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mWaypoint2DList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Waypoint2DList* _p = new RTC::Waypoint2DList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mWaypoint2DList_destructor_fn(void* _v)
{
  RTC::Waypoint2DList* _p = (RTC::Waypoint2DList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Waypoint2DList& _s)
{
  RTC::Waypoint2DList* _p = new RTC::Waypoint2DList(_s);
  _a.PR_insert(_0RL_tc_RTC_mWaypoint2DList,
               _0RL_RTC_mWaypoint2DList_marshal_fn,
               _0RL_RTC_mWaypoint2DList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Waypoint2DList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mWaypoint2DList,
               _0RL_RTC_mWaypoint2DList_marshal_fn,
               _0RL_RTC_mWaypoint2DList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint2DList*& _sp)
{
  return _a >>= (const RTC::Waypoint2DList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint2DList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mWaypoint2DList,
                    _0RL_RTC_mWaypoint2DList_unmarshal_fn,
                    _0RL_RTC_mWaypoint2DList_marshal_fn,
                    _0RL_RTC_mWaypoint2DList_destructor_fn,
                    _v)) {
    _sp = (const RTC::Waypoint2DList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPath2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Path2D* _p = (RTC::Path2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPath2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Path2D* _p = new RTC::Path2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPath2D_destructor_fn(void* _v)
{
  RTC::Path2D* _p = (RTC::Path2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Path2D& _s)
{
  RTC::Path2D* _p = new RTC::Path2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPath2D,
               _0RL_RTC_mPath2D_marshal_fn,
               _0RL_RTC_mPath2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Path2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPath2D,
               _0RL_RTC_mPath2D_marshal_fn,
               _0RL_RTC_mPath2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Path2D*& _sp)
{
  return _a >>= (const RTC::Path2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Path2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPath2D,
                    _0RL_RTC_mPath2D_unmarshal_fn,
                    _0RL_RTC_mPath2D_marshal_fn,
                    _0RL_RTC_mPath2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Path2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mWaypoint3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Waypoint3D* _p = (RTC::Waypoint3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mWaypoint3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Waypoint3D* _p = new RTC::Waypoint3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mWaypoint3D_destructor_fn(void* _v)
{
  RTC::Waypoint3D* _p = (RTC::Waypoint3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Waypoint3D& _s)
{
  RTC::Waypoint3D* _p = new RTC::Waypoint3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mWaypoint3D,
               _0RL_RTC_mWaypoint3D_marshal_fn,
               _0RL_RTC_mWaypoint3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Waypoint3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mWaypoint3D,
               _0RL_RTC_mWaypoint3D_marshal_fn,
               _0RL_RTC_mWaypoint3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint3D*& _sp)
{
  return _a >>= (const RTC::Waypoint3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mWaypoint3D,
                    _0RL_RTC_mWaypoint3D_unmarshal_fn,
                    _0RL_RTC_mWaypoint3D_marshal_fn,
                    _0RL_RTC_mWaypoint3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Waypoint3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mWaypoint3DList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Waypoint3DList* _p = (RTC::Waypoint3DList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mWaypoint3DList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Waypoint3DList* _p = new RTC::Waypoint3DList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mWaypoint3DList_destructor_fn(void* _v)
{
  RTC::Waypoint3DList* _p = (RTC::Waypoint3DList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Waypoint3DList& _s)
{
  RTC::Waypoint3DList* _p = new RTC::Waypoint3DList(_s);
  _a.PR_insert(_0RL_tc_RTC_mWaypoint3DList,
               _0RL_RTC_mWaypoint3DList_marshal_fn,
               _0RL_RTC_mWaypoint3DList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Waypoint3DList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mWaypoint3DList,
               _0RL_RTC_mWaypoint3DList_marshal_fn,
               _0RL_RTC_mWaypoint3DList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint3DList*& _sp)
{
  return _a >>= (const RTC::Waypoint3DList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint3DList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mWaypoint3DList,
                    _0RL_RTC_mWaypoint3DList_unmarshal_fn,
                    _0RL_RTC_mWaypoint3DList_marshal_fn,
                    _0RL_RTC_mWaypoint3DList_destructor_fn,
                    _v)) {
    _sp = (const RTC::Waypoint3DList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPath3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Path3D* _p = (RTC::Path3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPath3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Path3D* _p = new RTC::Path3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPath3D_destructor_fn(void* _v)
{
  RTC::Path3D* _p = (RTC::Path3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Path3D& _s)
{
  RTC::Path3D* _p = new RTC::Path3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPath3D,
               _0RL_RTC_mPath3D_marshal_fn,
               _0RL_RTC_mPath3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Path3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPath3D,
               _0RL_RTC_mPath3D_marshal_fn,
               _0RL_RTC_mPath3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Path3D*& _sp)
{
  return _a >>= (const RTC::Path3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Path3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPath3D,
                    _0RL_RTC_mPath3D_unmarshal_fn,
                    _0RL_RTC_mPath3D_marshal_fn,
                    _0RL_RTC_mPath3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Path3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPointCloudPoint_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PointCloudPoint* _p = (RTC::PointCloudPoint*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPointCloudPoint_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PointCloudPoint* _p = new RTC::PointCloudPoint;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPointCloudPoint_destructor_fn(void* _v)
{
  RTC::PointCloudPoint* _p = (RTC::PointCloudPoint*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PointCloudPoint& _s)
{
  RTC::PointCloudPoint* _p = new RTC::PointCloudPoint(_s);
  _a.PR_insert(_0RL_tc_RTC_mPointCloudPoint,
               _0RL_RTC_mPointCloudPoint_marshal_fn,
               _0RL_RTC_mPointCloudPoint_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PointCloudPoint* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPointCloudPoint,
               _0RL_RTC_mPointCloudPoint_marshal_fn,
               _0RL_RTC_mPointCloudPoint_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointCloudPoint*& _sp)
{
  return _a >>= (const RTC::PointCloudPoint*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointCloudPoint*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPointCloudPoint,
                    _0RL_RTC_mPointCloudPoint_unmarshal_fn,
                    _0RL_RTC_mPointCloudPoint_marshal_fn,
                    _0RL_RTC_mPointCloudPoint_destructor_fn,
                    _v)) {
    _sp = (const RTC::PointCloudPoint*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPointCloudPointList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PointCloudPointList* _p = (RTC::PointCloudPointList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPointCloudPointList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PointCloudPointList* _p = new RTC::PointCloudPointList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPointCloudPointList_destructor_fn(void* _v)
{
  RTC::PointCloudPointList* _p = (RTC::PointCloudPointList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PointCloudPointList& _s)
{
  RTC::PointCloudPointList* _p = new RTC::PointCloudPointList(_s);
  _a.PR_insert(_0RL_tc_RTC_mPointCloudPointList,
               _0RL_RTC_mPointCloudPointList_marshal_fn,
               _0RL_RTC_mPointCloudPointList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PointCloudPointList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPointCloudPointList,
               _0RL_RTC_mPointCloudPointList_marshal_fn,
               _0RL_RTC_mPointCloudPointList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointCloudPointList*& _sp)
{
  return _a >>= (const RTC::PointCloudPointList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointCloudPointList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPointCloudPointList,
                    _0RL_RTC_mPointCloudPointList_unmarshal_fn,
                    _0RL_RTC_mPointCloudPointList_marshal_fn,
                    _0RL_RTC_mPointCloudPointList_destructor_fn,
                    _v)) {
    _sp = (const RTC::PointCloudPointList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPointCloud_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PointCloud* _p = (RTC::PointCloud*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPointCloud_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PointCloud* _p = new RTC::PointCloud;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPointCloud_destructor_fn(void* _v)
{
  RTC::PointCloud* _p = (RTC::PointCloud*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PointCloud& _s)
{
  RTC::PointCloud* _p = new RTC::PointCloud(_s);
  _a.PR_insert(_0RL_tc_RTC_mPointCloud,
               _0RL_RTC_mPointCloud_marshal_fn,
               _0RL_RTC_mPointCloud_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PointCloud* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPointCloud,
               _0RL_RTC_mPointCloud_marshal_fn,
               _0RL_RTC_mPointCloud_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointCloud*& _sp)
{
  return _a >>= (const RTC::PointCloud*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointCloud*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPointCloud,
                    _0RL_RTC_mPointCloud_unmarshal_fn,
                    _0RL_RTC_mPointCloud_marshal_fn,
                    _0RL_RTC_mPointCloud_destructor_fn,
                    _v)) {
    _sp = (const RTC::PointCloud*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPanTiltAngles_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PanTiltAngles* _p = (RTC::PanTiltAngles*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPanTiltAngles_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PanTiltAngles* _p = new RTC::PanTiltAngles;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPanTiltAngles_destructor_fn(void* _v)
{
  RTC::PanTiltAngles* _p = (RTC::PanTiltAngles*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PanTiltAngles& _s)
{
  RTC::PanTiltAngles* _p = new RTC::PanTiltAngles(_s);
  _a.PR_insert(_0RL_tc_RTC_mPanTiltAngles,
               _0RL_RTC_mPanTiltAngles_marshal_fn,
               _0RL_RTC_mPanTiltAngles_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PanTiltAngles* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPanTiltAngles,
               _0RL_RTC_mPanTiltAngles_marshal_fn,
               _0RL_RTC_mPanTiltAngles_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PanTiltAngles*& _sp)
{
  return _a >>= (const RTC::PanTiltAngles*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PanTiltAngles*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPanTiltAngles,
                    _0RL_RTC_mPanTiltAngles_unmarshal_fn,
                    _0RL_RTC_mPanTiltAngles_marshal_fn,
                    _0RL_RTC_mPanTiltAngles_destructor_fn,
                    _v)) {
    _sp = (const RTC::PanTiltAngles*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPanTiltState_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PanTiltState* _p = (RTC::PanTiltState*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPanTiltState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PanTiltState* _p = new RTC::PanTiltState;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPanTiltState_destructor_fn(void* _v)
{
  RTC::PanTiltState* _p = (RTC::PanTiltState*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PanTiltState& _s)
{
  RTC::PanTiltState* _p = new RTC::PanTiltState(_s);
  _a.PR_insert(_0RL_tc_RTC_mPanTiltState,
               _0RL_RTC_mPanTiltState_marshal_fn,
               _0RL_RTC_mPanTiltState_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PanTiltState* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPanTiltState,
               _0RL_RTC_mPanTiltState_marshal_fn,
               _0RL_RTC_mPanTiltState_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PanTiltState*& _sp)
{
  return _a >>= (const RTC::PanTiltState*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PanTiltState*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPanTiltState,
                    _0RL_RTC_mPanTiltState_unmarshal_fn,
                    _0RL_RTC_mPanTiltState_marshal_fn,
                    _0RL_RTC_mPanTiltState_destructor_fn,
                    _v)) {
    _sp = (const RTC::PanTiltState*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mElementGeometryList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ElementGeometryList* _p = (RTC::ElementGeometryList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mElementGeometryList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ElementGeometryList* _p = new RTC::ElementGeometryList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mElementGeometryList_destructor_fn(void* _v)
{
  RTC::ElementGeometryList* _p = (RTC::ElementGeometryList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ElementGeometryList& _s)
{
  RTC::ElementGeometryList* _p = new RTC::ElementGeometryList(_s);
  _a.PR_insert(_0RL_tc_RTC_mElementGeometryList,
               _0RL_RTC_mElementGeometryList_marshal_fn,
               _0RL_RTC_mElementGeometryList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ElementGeometryList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mElementGeometryList,
               _0RL_RTC_mElementGeometryList_marshal_fn,
               _0RL_RTC_mElementGeometryList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ElementGeometryList*& _sp)
{
  return _a >>= (const RTC::ElementGeometryList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ElementGeometryList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mElementGeometryList,
                    _0RL_RTC_mElementGeometryList_unmarshal_fn,
                    _0RL_RTC_mElementGeometryList_marshal_fn,
                    _0RL_RTC_mElementGeometryList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ElementGeometryList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRangerGeometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RangerGeometry* _p = (RTC::RangerGeometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRangerGeometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RangerGeometry* _p = new RTC::RangerGeometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRangerGeometry_destructor_fn(void* _v)
{
  RTC::RangerGeometry* _p = (RTC::RangerGeometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RangerGeometry& _s)
{
  RTC::RangerGeometry* _p = new RTC::RangerGeometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mRangerGeometry,
               _0RL_RTC_mRangerGeometry_marshal_fn,
               _0RL_RTC_mRangerGeometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RangerGeometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRangerGeometry,
               _0RL_RTC_mRangerGeometry_marshal_fn,
               _0RL_RTC_mRangerGeometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangerGeometry*& _sp)
{
  return _a >>= (const RTC::RangerGeometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangerGeometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRangerGeometry,
                    _0RL_RTC_mRangerGeometry_unmarshal_fn,
                    _0RL_RTC_mRangerGeometry_marshal_fn,
                    _0RL_RTC_mRangerGeometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::RangerGeometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRangerConfig_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RangerConfig* _p = (RTC::RangerConfig*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRangerConfig_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RangerConfig* _p = new RTC::RangerConfig;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRangerConfig_destructor_fn(void* _v)
{
  RTC::RangerConfig* _p = (RTC::RangerConfig*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RangerConfig& _s)
{
  RTC::RangerConfig* _p = new RTC::RangerConfig(_s);
  _a.PR_insert(_0RL_tc_RTC_mRangerConfig,
               _0RL_RTC_mRangerConfig_marshal_fn,
               _0RL_RTC_mRangerConfig_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RangerConfig* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRangerConfig,
               _0RL_RTC_mRangerConfig_marshal_fn,
               _0RL_RTC_mRangerConfig_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangerConfig*& _sp)
{
  return _a >>= (const RTC::RangerConfig*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangerConfig*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRangerConfig,
                    _0RL_RTC_mRangerConfig_unmarshal_fn,
                    _0RL_RTC_mRangerConfig_marshal_fn,
                    _0RL_RTC_mRangerConfig_destructor_fn,
                    _v)) {
    _sp = (const RTC::RangerConfig*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRangeList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RangeList* _p = (RTC::RangeList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRangeList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RangeList* _p = new RTC::RangeList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRangeList_destructor_fn(void* _v)
{
  RTC::RangeList* _p = (RTC::RangeList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RangeList& _s)
{
  RTC::RangeList* _p = new RTC::RangeList(_s);
  _a.PR_insert(_0RL_tc_RTC_mRangeList,
               _0RL_RTC_mRangeList_marshal_fn,
               _0RL_RTC_mRangeList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RangeList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRangeList,
               _0RL_RTC_mRangeList_marshal_fn,
               _0RL_RTC_mRangeList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangeList*& _sp)
{
  return _a >>= (const RTC::RangeList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangeList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRangeList,
                    _0RL_RTC_mRangeList_unmarshal_fn,
                    _0RL_RTC_mRangeList_marshal_fn,
                    _0RL_RTC_mRangeList_destructor_fn,
                    _v)) {
    _sp = (const RTC::RangeList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRangeData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RangeData* _p = (RTC::RangeData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRangeData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RangeData* _p = new RTC::RangeData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRangeData_destructor_fn(void* _v)
{
  RTC::RangeData* _p = (RTC::RangeData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RangeData& _s)
{
  RTC::RangeData* _p = new RTC::RangeData(_s);
  _a.PR_insert(_0RL_tc_RTC_mRangeData,
               _0RL_RTC_mRangeData_marshal_fn,
               _0RL_RTC_mRangeData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RangeData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRangeData,
               _0RL_RTC_mRangeData_marshal_fn,
               _0RL_RTC_mRangeData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangeData*& _sp)
{
  return _a >>= (const RTC::RangeData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangeData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRangeData,
                    _0RL_RTC_mRangeData_unmarshal_fn,
                    _0RL_RTC_mRangeData_marshal_fn,
                    _0RL_RTC_mRangeData_destructor_fn,
                    _v)) {
    _sp = (const RTC::RangeData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mIntensityList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::IntensityList* _p = (RTC::IntensityList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mIntensityList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::IntensityList* _p = new RTC::IntensityList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mIntensityList_destructor_fn(void* _v)
{
  RTC::IntensityList* _p = (RTC::IntensityList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::IntensityList& _s)
{
  RTC::IntensityList* _p = new RTC::IntensityList(_s);
  _a.PR_insert(_0RL_tc_RTC_mIntensityList,
               _0RL_RTC_mIntensityList_marshal_fn,
               _0RL_RTC_mIntensityList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::IntensityList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mIntensityList,
               _0RL_RTC_mIntensityList_marshal_fn,
               _0RL_RTC_mIntensityList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::IntensityList*& _sp)
{
  return _a >>= (const RTC::IntensityList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::IntensityList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mIntensityList,
                    _0RL_RTC_mIntensityList_unmarshal_fn,
                    _0RL_RTC_mIntensityList_marshal_fn,
                    _0RL_RTC_mIntensityList_destructor_fn,
                    _v)) {
    _sp = (const RTC::IntensityList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mIntensityData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::IntensityData* _p = (RTC::IntensityData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mIntensityData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::IntensityData* _p = new RTC::IntensityData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mIntensityData_destructor_fn(void* _v)
{
  RTC::IntensityData* _p = (RTC::IntensityData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::IntensityData& _s)
{
  RTC::IntensityData* _p = new RTC::IntensityData(_s);
  _a.PR_insert(_0RL_tc_RTC_mIntensityData,
               _0RL_RTC_mIntensityData_marshal_fn,
               _0RL_RTC_mIntensityData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::IntensityData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mIntensityData,
               _0RL_RTC_mIntensityData_marshal_fn,
               _0RL_RTC_mIntensityData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::IntensityData*& _sp)
{
  return _a >>= (const RTC::IntensityData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::IntensityData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mIntensityData,
                    _0RL_RTC_mIntensityData_unmarshal_fn,
                    _0RL_RTC_mIntensityData_marshal_fn,
                    _0RL_RTC_mIntensityData_destructor_fn,
                    _v)) {
    _sp = (const RTC::IntensityData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRFIDTagData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RFIDTagData* _p = (RTC::RFIDTagData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRFIDTagData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RFIDTagData* _p = new RTC::RFIDTagData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRFIDTagData_destructor_fn(void* _v)
{
  RTC::RFIDTagData* _p = (RTC::RFIDTagData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RFIDTagData& _s)
{
  RTC::RFIDTagData* _p = new RTC::RFIDTagData(_s);
  _a.PR_insert(_0RL_tc_RTC_mRFIDTagData,
               _0RL_RTC_mRFIDTagData_marshal_fn,
               _0RL_RTC_mRFIDTagData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RFIDTagData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRFIDTagData,
               _0RL_RTC_mRFIDTagData_marshal_fn,
               _0RL_RTC_mRFIDTagData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RFIDTagData*& _sp)
{
  return _a >>= (const RTC::RFIDTagData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RFIDTagData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRFIDTagData,
                    _0RL_RTC_mRFIDTagData_unmarshal_fn,
                    _0RL_RTC_mRFIDTagData_marshal_fn,
                    _0RL_RTC_mRFIDTagData_destructor_fn,
                    _v)) {
    _sp = (const RTC::RFIDTagData*)_v;
    return 1;
  }
  return 0;
}

