// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "RTC.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_RTC_mExecutionContextHandle__t = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/ExecutionContextHandle_t:1.0", "ExecutionContextHandle_t", CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionContextHandle_t = _0RL_tc_RTC_mExecutionContextHandle__t;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionContextHandle_t = _0RL_tc_RTC_mExecutionContextHandle__t;
#endif

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mUniqueIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/UniqueIdentifier:1.0", "UniqueIdentifier", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_RTC_mUniqueIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/UniqueIdentifier:1.0", "UniqueIdentifier", _0RL_tc_SDOPackage_mUniqueIdentifier, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_UniqueIdentifier = _0RL_tc_RTC_mUniqueIdentifier;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_UniqueIdentifier = _0RL_tc_RTC_mUniqueIdentifier;
#endif

static CORBA::PR_structMember _0RL_structmember_SDOPackage_mNameValue[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_SDOPackage_mNameValue
#  undef _0RL_tc_SDOPackage_mNameValue
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mNameValue = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/NameValue:1.0", "NameValue", _0RL_structmember_SDOPackage_mNameValue, 2, &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mNVList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/NVList:1.0", "NVList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_SDOPackage_mNameValue, &_0RL_tcTrack), &_0RL_tcTrack);




static CORBA::TypeCode_ptr _0RL_tc_RTC_mNVList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/NVList:1.0", "NVList", _0RL_tc_SDOPackage_mNVList, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_NVList = _0RL_tc_RTC_mNVList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_NVList = _0RL_tc_RTC_mNVList;
#endif

static const char* _0RL_enumMember_RTC_mReturnCode__t[] = { "RTC_OK", "RTC_ERROR", "BAD_PARAMETER", "UNSUPPORTED", "OUT_OF_RESOURCES", "PRECONDITION_NOT_MET" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mReturnCode__t = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/RTC/ReturnCode_t:1.0", "ReturnCode_t", _0RL_enumMember_RTC_mReturnCode__t, 6, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ReturnCode_t = _0RL_tc_RTC_mReturnCode__t;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ReturnCode_t = _0RL_tc_RTC_mReturnCode__t;
#endif

static const char* _0RL_enumMember_RTC_mLifeCycleState[] = { "CREATED_STATE", "INACTIVE_STATE", "ACTIVE_STATE", "ERROR_STATE" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mLifeCycleState = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/RTC/LifeCycleState:1.0", "LifeCycleState", _0RL_enumMember_RTC_mLifeCycleState, 4, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_LifeCycleState = _0RL_tc_RTC_mLifeCycleState;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_LifeCycleState = _0RL_tc_RTC_mLifeCycleState;
#endif

static CORBA::TypeCode_ptr _0RL_tc_RTC_mExecutionContextList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/ExecutionContextList:1.0", "ExecutionContextList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ExecutionContext:1.0", "ExecutionContext", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionContextList = _0RL_tc_RTC_mExecutionContextList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionContextList = _0RL_tc_RTC_mExecutionContextList;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ComponentAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ComponentAction:1.0", "ComponentAction", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ComponentAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ComponentAction:1.0", "ComponentAction", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_LightweightRTObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/LightweightRTObject:1.0", "LightweightRTObject", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_LightweightRTObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/LightweightRTObject:1.0", "LightweightRTObject", &_0RL_tcTrack);
#endif

static const char* _0RL_enumMember_RTC_mExecutionKind[] = { "PERIODIC", "EVENT_DRIVEN", "OTHER" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mExecutionKind = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/RTC/ExecutionKind:1.0", "ExecutionKind", _0RL_enumMember_RTC_mExecutionKind, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionKind = _0RL_tc_RTC_mExecutionKind;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionKind = _0RL_tc_RTC_mExecutionKind;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionContext = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ExecutionContext:1.0", "ExecutionContext", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionContext = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ExecutionContext:1.0", "ExecutionContext", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_DataFlowComponentAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/DataFlowComponentAction:1.0", "DataFlowComponentAction", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_DataFlowComponentAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/DataFlowComponentAction:1.0", "DataFlowComponentAction", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_DataFlowComponent = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/DataFlowComponent:1.0", "DataFlowComponent", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_DataFlowComponent = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/DataFlowComponent:1.0", "DataFlowComponent", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Fsm = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/Fsm:1.0", "Fsm", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Fsm = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/Fsm:1.0", "Fsm", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FsmParticipantAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmParticipantAction:1.0", "FsmParticipantAction", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FsmParticipantAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmParticipantAction:1.0", "FsmParticipantAction", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FsmParticipant = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmParticipant:1.0", "FsmParticipant", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FsmParticipant = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmParticipant:1.0", "FsmParticipant", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Mode = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/Mode:1.0", "Mode", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Mode = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/Mode:1.0", "Mode", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ModeCapable = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ModeCapable:1.0", "ModeCapable", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ModeCapable = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ModeCapable:1.0", "ModeCapable", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MultiModeComponentAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/MultiModeComponentAction:1.0", "MultiModeComponentAction", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MultiModeComponentAction = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/MultiModeComponentAction:1.0", "MultiModeComponentAction", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MultiModeObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/MultiModeObject:1.0", "MultiModeObject", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MultiModeObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/MultiModeObject:1.0", "MultiModeObject", &_0RL_tcTrack);
#endif

static const char* _0RL_enumMember_RTC_mPortInterfacePolarity[] = { "PROVIDED", "REQUIRED" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPortInterfacePolarity = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/RTC/PortInterfacePolarity:1.0", "PortInterfacePolarity", _0RL_enumMember_RTC_mPortInterfacePolarity, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PortInterfacePolarity = _0RL_tc_RTC_mPortInterfacePolarity;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PortInterfacePolarity = _0RL_tc_RTC_mPortInterfacePolarity;
#endif

static CORBA::PR_structMember _0RL_structmember_RTC_mPortInterfaceProfile[] = {
  {"instance_name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"type_name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"polarity", _0RL_tc_RTC_mPortInterfacePolarity}
};

#ifdef _0RL_tc_RTC_mPortInterfaceProfile
#  undef _0RL_tc_RTC_mPortInterfaceProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPortInterfaceProfile = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/RTC/PortInterfaceProfile:1.0", "PortInterfaceProfile", _0RL_structmember_RTC_mPortInterfaceProfile, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PortInterfaceProfile = _0RL_tc_RTC_mPortInterfaceProfile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PortInterfaceProfile = _0RL_tc_RTC_mPortInterfaceProfile;
#endif






static CORBA::TypeCode_ptr _0RL_tc_RTC_mPortInterfaceProfileList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/PortInterfaceProfileList:1.0", "PortInterfaceProfileList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPortInterfaceProfile, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PortInterfaceProfileList = _0RL_tc_RTC_mPortInterfaceProfileList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PortInterfaceProfileList = _0RL_tc_RTC_mPortInterfaceProfileList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_RTC_mPortServiceList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/PortServiceList:1.0", "PortServiceList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/PortService:1.0", "PortService", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PortServiceList = _0RL_tc_RTC_mPortServiceList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PortServiceList = _0RL_tc_RTC_mPortServiceList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_RTC_mRTCList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/RTCList:1.0", "RTCList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/RTObject:1.0", "RTObject", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RTCList = _0RL_tc_RTC_mRTCList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RTCList = _0RL_tc_RTC_mRTCList;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mConnectorProfile[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"connector_id", _0RL_tc_RTC_mUniqueIdentifier},
  {"ports", _0RL_tc_RTC_mPortServiceList},
  {"properties", _0RL_tc_RTC_mNVList}
};

#ifdef _0RL_tc_RTC_mConnectorProfile
#  undef _0RL_tc_RTC_mConnectorProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mConnectorProfile = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/RTC/ConnectorProfile:1.0", "ConnectorProfile", _0RL_structmember_RTC_mConnectorProfile, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ConnectorProfile = _0RL_tc_RTC_mConnectorProfile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ConnectorProfile = _0RL_tc_RTC_mConnectorProfile;
#endif










static CORBA::TypeCode_ptr _0RL_tc_RTC_mConnectorProfileList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/ConnectorProfileList:1.0", "ConnectorProfileList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mConnectorProfile, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ConnectorProfileList = _0RL_tc_RTC_mConnectorProfileList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ConnectorProfileList = _0RL_tc_RTC_mConnectorProfileList;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mPortProfile[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"interfaces", _0RL_tc_RTC_mPortInterfaceProfileList},
  {"port_ref", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/PortService:1.0", "PortService", &_0RL_tcTrack)},
  {"connector_profiles", _0RL_tc_RTC_mConnectorProfileList},
  {"owner", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/RTObject:1.0", "RTObject", &_0RL_tcTrack)},
  {"properties", _0RL_tc_RTC_mNVList}
};

#ifdef _0RL_tc_RTC_mPortProfile
#  undef _0RL_tc_RTC_mPortProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPortProfile = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/RTC/PortProfile:1.0", "PortProfile", _0RL_structmember_RTC_mPortProfile, 6, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PortProfile = _0RL_tc_RTC_mPortProfile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PortProfile = _0RL_tc_RTC_mPortProfile;
#endif






















static CORBA::TypeCode_ptr _0RL_tc_RTC_mPortProfileList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/PortProfileList:1.0", "PortProfileList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPortProfile, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PortProfileList = _0RL_tc_RTC_mPortProfileList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PortProfileList = _0RL_tc_RTC_mPortProfileList;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mExecutionContextProfile[] = {
  {"kind", _0RL_tc_RTC_mExecutionKind},
  {"rate", CORBA::TypeCode::PR_double_tc()},
  {"owner", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/RTObject:1.0", "RTObject", &_0RL_tcTrack)},
  {"participants", _0RL_tc_RTC_mRTCList},
  {"properties", _0RL_tc_RTC_mNVList}
};

#ifdef _0RL_tc_RTC_mExecutionContextProfile
#  undef _0RL_tc_RTC_mExecutionContextProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mExecutionContextProfile = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/RTC/ExecutionContextProfile:1.0", "ExecutionContextProfile", _0RL_structmember_RTC_mExecutionContextProfile, 5, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionContextProfile = _0RL_tc_RTC_mExecutionContextProfile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionContextProfile = _0RL_tc_RTC_mExecutionContextProfile;
#endif










static CORBA::TypeCode_ptr _0RL_tc_RTC_mExecutionContextProfileList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/ExecutionContextProfileList:1.0", "ExecutionContextProfileList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mExecutionContextProfile, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionContextProfileList = _0RL_tc_RTC_mExecutionContextProfileList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionContextProfileList = _0RL_tc_RTC_mExecutionContextProfileList;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FsmObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmObject:1.0", "FsmObject", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FsmObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmObject:1.0", "FsmObject", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_RTC_mFsmBehaviorProfile[] = {
  {"action_component", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmParticipantAction:1.0", "FsmParticipantAction", &_0RL_tcTrack)},
  {"id", _0RL_tc_RTC_mUniqueIdentifier}
};

#ifdef _0RL_tc_RTC_mFsmBehaviorProfile
#  undef _0RL_tc_RTC_mFsmBehaviorProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFsmBehaviorProfile = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/RTC/FsmBehaviorProfile:1.0", "FsmBehaviorProfile", _0RL_structmember_RTC_mFsmBehaviorProfile, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FsmBehaviorProfile = _0RL_tc_RTC_mFsmBehaviorProfile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FsmBehaviorProfile = _0RL_tc_RTC_mFsmBehaviorProfile;
#endif






static CORBA::TypeCode_ptr _0RL_tc_RTC_mFsmBehaviorProfileList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/FsmBehaviorProfileList:1.0", "FsmBehaviorProfileList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mFsmBehaviorProfile, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FsmBehaviorProfileList = _0RL_tc_RTC_mFsmBehaviorProfileList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FsmBehaviorProfileList = _0RL_tc_RTC_mFsmBehaviorProfileList;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mFsmProfile[] = {
  {"behavior_profiles", _0RL_tc_RTC_mFsmBehaviorProfileList}
};

#ifdef _0RL_tc_RTC_mFsmProfile
#  undef _0RL_tc_RTC_mFsmProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFsmProfile = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/RTC/FsmProfile:1.0", "FsmProfile", _0RL_structmember_RTC_mFsmProfile, 1, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FsmProfile = _0RL_tc_RTC_mFsmProfile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FsmProfile = _0RL_tc_RTC_mFsmProfile;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FsmService = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmService:1.0", "FsmService", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FsmService = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/FsmService:1.0", "FsmService", &_0RL_tcTrack);
#endif







static CORBA::PR_structMember _0RL_structmember_RTC_mComponentProfile[] = {
  {"instance_name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"type_name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"description", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"version", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"vendor", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"category", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"port_profiles", _0RL_tc_RTC_mPortProfileList},
  {"parent", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/RTObject:1.0", "RTObject", &_0RL_tcTrack)},
  {"properties", _0RL_tc_RTC_mNVList}
};

#ifdef _0RL_tc_RTC_mComponentProfile
#  undef _0RL_tc_RTC_mComponentProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mComponentProfile = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/RTC/ComponentProfile:1.0", "ComponentProfile", _0RL_structmember_RTC_mComponentProfile, 9, &_0RL_tcTrack);







#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ComponentProfile = _0RL_tc_RTC_mComponentProfile;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ComponentProfile = _0RL_tc_RTC_mComponentProfile;
#endif






























static CORBA::TypeCode_ptr _0RL_tc_RTC_mComponentProfileList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/ComponentProfileList:1.0", "ComponentProfileList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mComponentProfile, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ComponentProfileList = _0RL_tc_RTC_mComponentProfileList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ComponentProfileList = _0RL_tc_RTC_mComponentProfileList;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PortService = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/PortService:1.0", "PortService", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PortService = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/PortService:1.0", "PortService", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionContextService = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ExecutionContextService:1.0", "ExecutionContextService", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionContextService = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ExecutionContextService:1.0", "ExecutionContextService", &_0RL_tcTrack);
#endif

static CORBA::TypeCode_ptr _0RL_tc_RTC_mExecutionContextServiceList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/RTC/ExecutionContextServiceList:1.0", "ExecutionContextServiceList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/ExecutionContextService:1.0", "ExecutionContextService", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_ExecutionContextServiceList = _0RL_tc_RTC_mExecutionContextServiceList;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_ExecutionContextServiceList = _0RL_tc_RTC_mExecutionContextServiceList;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RTObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/RTObject:1.0", "RTObject", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RTObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/RTC/RTObject:1.0", "RTObject", &_0RL_tcTrack);
#endif

static void _0RL_RTC_mReturnCode__t_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ReturnCode_t* _p = (RTC::ReturnCode_t*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mReturnCode__t_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ReturnCode_t* _p = (RTC::ReturnCode_t*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::ReturnCode_t _s)
{
  _a.PR_insert(_0RL_tc_RTC_mReturnCode__t,
               _0RL_RTC_mReturnCode__t_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ReturnCode_t& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mReturnCode__t,
                       _0RL_RTC_mReturnCode__t_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mLifeCycleState_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::LifeCycleState* _p = (RTC::LifeCycleState*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mLifeCycleState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::LifeCycleState* _p = (RTC::LifeCycleState*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::LifeCycleState _s)
{
  _a.PR_insert(_0RL_tc_RTC_mLifeCycleState,
               _0RL_RTC_mLifeCycleState_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::LifeCycleState& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mLifeCycleState,
                       _0RL_RTC_mLifeCycleState_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mExecutionContextList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ExecutionContextList* _p = (RTC::ExecutionContextList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mExecutionContextList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ExecutionContextList* _p = new RTC::ExecutionContextList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mExecutionContextList_destructor_fn(void* _v)
{
  RTC::ExecutionContextList* _p = (RTC::ExecutionContextList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextList& _s)
{
  RTC::ExecutionContextList* _p = new RTC::ExecutionContextList(_s);
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextList,
               _0RL_RTC_mExecutionContextList_marshal_fn,
               _0RL_RTC_mExecutionContextList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextList,
               _0RL_RTC_mExecutionContextList_marshal_fn,
               _0RL_RTC_mExecutionContextList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextList*& _sp)
{
  return _a >>= (const RTC::ExecutionContextList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mExecutionContextList,
                    _0RL_RTC_mExecutionContextList_unmarshal_fn,
                    _0RL_RTC_mExecutionContextList_marshal_fn,
                    _0RL_RTC_mExecutionContextList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ExecutionContextList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mComponentAction_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mComponentAction_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::ComponentAction::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mComponentAction_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::ComponentAction_ptr _o)
{
  RTC::ComponentAction_ptr _no = RTC::ComponentAction::_duplicate(_o);
  _a.PR_insert(RTC::_tc_ComponentAction,
               _0RL_RTC_mComponentAction_marshal_fn,
               _0RL_RTC_mComponentAction_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::ComponentAction_ptr* _op)
{
  _a.PR_insert(RTC::_tc_ComponentAction,
               _0RL_RTC_mComponentAction_marshal_fn,
               _0RL_RTC_mComponentAction_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::ComponentAction::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ComponentAction_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_ComponentAction,
                    _0RL_RTC_mComponentAction_unmarshal_fn,
                    _0RL_RTC_mComponentAction_marshal_fn,
                    _0RL_RTC_mComponentAction_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::ComponentAction_ptr)_r->_ptrToObjRef(RTC::ComponentAction::_PD_repoId);
    else
      _o = RTC::ComponentAction::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mLightweightRTObject_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mLightweightRTObject_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::LightweightRTObject::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mLightweightRTObject_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::LightweightRTObject_ptr _o)
{
  RTC::LightweightRTObject_ptr _no = RTC::LightweightRTObject::_duplicate(_o);
  _a.PR_insert(RTC::_tc_LightweightRTObject,
               _0RL_RTC_mLightweightRTObject_marshal_fn,
               _0RL_RTC_mLightweightRTObject_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::LightweightRTObject_ptr* _op)
{
  _a.PR_insert(RTC::_tc_LightweightRTObject,
               _0RL_RTC_mLightweightRTObject_marshal_fn,
               _0RL_RTC_mLightweightRTObject_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::LightweightRTObject::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::LightweightRTObject_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_LightweightRTObject,
                    _0RL_RTC_mLightweightRTObject_unmarshal_fn,
                    _0RL_RTC_mLightweightRTObject_marshal_fn,
                    _0RL_RTC_mLightweightRTObject_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::LightweightRTObject_ptr)_r->_ptrToObjRef(RTC::LightweightRTObject::_PD_repoId);
    else
      _o = RTC::LightweightRTObject::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mExecutionKind_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ExecutionKind* _p = (RTC::ExecutionKind*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mExecutionKind_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ExecutionKind* _p = (RTC::ExecutionKind*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::ExecutionKind _s)
{
  _a.PR_insert(_0RL_tc_RTC_mExecutionKind,
               _0RL_RTC_mExecutionKind_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionKind& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mExecutionKind,
                       _0RL_RTC_mExecutionKind_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mExecutionContext_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mExecutionContext_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::ExecutionContext::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mExecutionContext_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::ExecutionContext_ptr _o)
{
  RTC::ExecutionContext_ptr _no = RTC::ExecutionContext::_duplicate(_o);
  _a.PR_insert(RTC::_tc_ExecutionContext,
               _0RL_RTC_mExecutionContext_marshal_fn,
               _0RL_RTC_mExecutionContext_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContext_ptr* _op)
{
  _a.PR_insert(RTC::_tc_ExecutionContext,
               _0RL_RTC_mExecutionContext_marshal_fn,
               _0RL_RTC_mExecutionContext_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::ExecutionContext::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContext_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_ExecutionContext,
                    _0RL_RTC_mExecutionContext_unmarshal_fn,
                    _0RL_RTC_mExecutionContext_marshal_fn,
                    _0RL_RTC_mExecutionContext_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::ExecutionContext_ptr)_r->_ptrToObjRef(RTC::ExecutionContext::_PD_repoId);
    else
      _o = RTC::ExecutionContext::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mDataFlowComponentAction_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mDataFlowComponentAction_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::DataFlowComponentAction::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mDataFlowComponentAction_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponentAction_ptr _o)
{
  RTC::DataFlowComponentAction_ptr _no = RTC::DataFlowComponentAction::_duplicate(_o);
  _a.PR_insert(RTC::_tc_DataFlowComponentAction,
               _0RL_RTC_mDataFlowComponentAction_marshal_fn,
               _0RL_RTC_mDataFlowComponentAction_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponentAction_ptr* _op)
{
  _a.PR_insert(RTC::_tc_DataFlowComponentAction,
               _0RL_RTC_mDataFlowComponentAction_marshal_fn,
               _0RL_RTC_mDataFlowComponentAction_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::DataFlowComponentAction::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::DataFlowComponentAction_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_DataFlowComponentAction,
                    _0RL_RTC_mDataFlowComponentAction_unmarshal_fn,
                    _0RL_RTC_mDataFlowComponentAction_marshal_fn,
                    _0RL_RTC_mDataFlowComponentAction_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::DataFlowComponentAction_ptr)_r->_ptrToObjRef(RTC::DataFlowComponentAction::_PD_repoId);
    else
      _o = RTC::DataFlowComponentAction::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mDataFlowComponent_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mDataFlowComponent_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::DataFlowComponent::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mDataFlowComponent_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponent_ptr _o)
{
  RTC::DataFlowComponent_ptr _no = RTC::DataFlowComponent::_duplicate(_o);
  _a.PR_insert(RTC::_tc_DataFlowComponent,
               _0RL_RTC_mDataFlowComponent_marshal_fn,
               _0RL_RTC_mDataFlowComponent_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponent_ptr* _op)
{
  _a.PR_insert(RTC::_tc_DataFlowComponent,
               _0RL_RTC_mDataFlowComponent_marshal_fn,
               _0RL_RTC_mDataFlowComponent_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::DataFlowComponent::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::DataFlowComponent_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_DataFlowComponent,
                    _0RL_RTC_mDataFlowComponent_unmarshal_fn,
                    _0RL_RTC_mDataFlowComponent_marshal_fn,
                    _0RL_RTC_mDataFlowComponent_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::DataFlowComponent_ptr)_r->_ptrToObjRef(RTC::DataFlowComponent::_PD_repoId);
    else
      _o = RTC::DataFlowComponent::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsm_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mFsm_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::Fsm::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mFsm_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::Fsm_ptr _o)
{
  RTC::Fsm_ptr _no = RTC::Fsm::_duplicate(_o);
  _a.PR_insert(RTC::_tc_Fsm,
               _0RL_RTC_mFsm_marshal_fn,
               _0RL_RTC_mFsm_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::Fsm_ptr* _op)
{
  _a.PR_insert(RTC::_tc_Fsm,
               _0RL_RTC_mFsm_marshal_fn,
               _0RL_RTC_mFsm_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::Fsm::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Fsm_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_Fsm,
                    _0RL_RTC_mFsm_unmarshal_fn,
                    _0RL_RTC_mFsm_marshal_fn,
                    _0RL_RTC_mFsm_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::Fsm_ptr)_r->_ptrToObjRef(RTC::Fsm::_PD_repoId);
    else
      _o = RTC::Fsm::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsmParticipantAction_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mFsmParticipantAction_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::FsmParticipantAction::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mFsmParticipantAction_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::FsmParticipantAction_ptr _o)
{
  RTC::FsmParticipantAction_ptr _no = RTC::FsmParticipantAction::_duplicate(_o);
  _a.PR_insert(RTC::_tc_FsmParticipantAction,
               _0RL_RTC_mFsmParticipantAction_marshal_fn,
               _0RL_RTC_mFsmParticipantAction_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::FsmParticipantAction_ptr* _op)
{
  _a.PR_insert(RTC::_tc_FsmParticipantAction,
               _0RL_RTC_mFsmParticipantAction_marshal_fn,
               _0RL_RTC_mFsmParticipantAction_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::FsmParticipantAction::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmParticipantAction_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_FsmParticipantAction,
                    _0RL_RTC_mFsmParticipantAction_unmarshal_fn,
                    _0RL_RTC_mFsmParticipantAction_marshal_fn,
                    _0RL_RTC_mFsmParticipantAction_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::FsmParticipantAction_ptr)_r->_ptrToObjRef(RTC::FsmParticipantAction::_PD_repoId);
    else
      _o = RTC::FsmParticipantAction::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsmParticipant_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mFsmParticipant_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::FsmParticipant::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mFsmParticipant_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::FsmParticipant_ptr _o)
{
  RTC::FsmParticipant_ptr _no = RTC::FsmParticipant::_duplicate(_o);
  _a.PR_insert(RTC::_tc_FsmParticipant,
               _0RL_RTC_mFsmParticipant_marshal_fn,
               _0RL_RTC_mFsmParticipant_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::FsmParticipant_ptr* _op)
{
  _a.PR_insert(RTC::_tc_FsmParticipant,
               _0RL_RTC_mFsmParticipant_marshal_fn,
               _0RL_RTC_mFsmParticipant_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::FsmParticipant::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmParticipant_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_FsmParticipant,
                    _0RL_RTC_mFsmParticipant_unmarshal_fn,
                    _0RL_RTC_mFsmParticipant_marshal_fn,
                    _0RL_RTC_mFsmParticipant_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::FsmParticipant_ptr)_r->_ptrToObjRef(RTC::FsmParticipant::_PD_repoId);
    else
      _o = RTC::FsmParticipant::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMode_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mMode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::Mode::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mMode_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::Mode_ptr _o)
{
  RTC::Mode_ptr _no = RTC::Mode::_duplicate(_o);
  _a.PR_insert(RTC::_tc_Mode,
               _0RL_RTC_mMode_marshal_fn,
               _0RL_RTC_mMode_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::Mode_ptr* _op)
{
  _a.PR_insert(RTC::_tc_Mode,
               _0RL_RTC_mMode_marshal_fn,
               _0RL_RTC_mMode_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::Mode::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Mode_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_Mode,
                    _0RL_RTC_mMode_unmarshal_fn,
                    _0RL_RTC_mMode_marshal_fn,
                    _0RL_RTC_mMode_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::Mode_ptr)_r->_ptrToObjRef(RTC::Mode::_PD_repoId);
    else
      _o = RTC::Mode::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mModeCapable_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mModeCapable_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::ModeCapable::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mModeCapable_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::ModeCapable_ptr _o)
{
  RTC::ModeCapable_ptr _no = RTC::ModeCapable::_duplicate(_o);
  _a.PR_insert(RTC::_tc_ModeCapable,
               _0RL_RTC_mModeCapable_marshal_fn,
               _0RL_RTC_mModeCapable_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::ModeCapable_ptr* _op)
{
  _a.PR_insert(RTC::_tc_ModeCapable,
               _0RL_RTC_mModeCapable_marshal_fn,
               _0RL_RTC_mModeCapable_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::ModeCapable::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ModeCapable_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_ModeCapable,
                    _0RL_RTC_mModeCapable_unmarshal_fn,
                    _0RL_RTC_mModeCapable_marshal_fn,
                    _0RL_RTC_mModeCapable_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::ModeCapable_ptr)_r->_ptrToObjRef(RTC::ModeCapable::_PD_repoId);
    else
      _o = RTC::ModeCapable::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMultiModeComponentAction_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mMultiModeComponentAction_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::MultiModeComponentAction::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mMultiModeComponentAction_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::MultiModeComponentAction_ptr _o)
{
  RTC::MultiModeComponentAction_ptr _no = RTC::MultiModeComponentAction::_duplicate(_o);
  _a.PR_insert(RTC::_tc_MultiModeComponentAction,
               _0RL_RTC_mMultiModeComponentAction_marshal_fn,
               _0RL_RTC_mMultiModeComponentAction_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::MultiModeComponentAction_ptr* _op)
{
  _a.PR_insert(RTC::_tc_MultiModeComponentAction,
               _0RL_RTC_mMultiModeComponentAction_marshal_fn,
               _0RL_RTC_mMultiModeComponentAction_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::MultiModeComponentAction::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MultiModeComponentAction_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_MultiModeComponentAction,
                    _0RL_RTC_mMultiModeComponentAction_unmarshal_fn,
                    _0RL_RTC_mMultiModeComponentAction_marshal_fn,
                    _0RL_RTC_mMultiModeComponentAction_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::MultiModeComponentAction_ptr)_r->_ptrToObjRef(RTC::MultiModeComponentAction::_PD_repoId);
    else
      _o = RTC::MultiModeComponentAction::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mMultiModeObject_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mMultiModeObject_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::MultiModeObject::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mMultiModeObject_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::MultiModeObject_ptr _o)
{
  RTC::MultiModeObject_ptr _no = RTC::MultiModeObject::_duplicate(_o);
  _a.PR_insert(RTC::_tc_MultiModeObject,
               _0RL_RTC_mMultiModeObject_marshal_fn,
               _0RL_RTC_mMultiModeObject_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::MultiModeObject_ptr* _op)
{
  _a.PR_insert(RTC::_tc_MultiModeObject,
               _0RL_RTC_mMultiModeObject_marshal_fn,
               _0RL_RTC_mMultiModeObject_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::MultiModeObject::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MultiModeObject_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_MultiModeObject,
                    _0RL_RTC_mMultiModeObject_unmarshal_fn,
                    _0RL_RTC_mMultiModeObject_marshal_fn,
                    _0RL_RTC_mMultiModeObject_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::MultiModeObject_ptr)_r->_ptrToObjRef(RTC::MultiModeObject::_PD_repoId);
    else
      _o = RTC::MultiModeObject::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPortInterfacePolarity_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PortInterfacePolarity* _p = (RTC::PortInterfacePolarity*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPortInterfacePolarity_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PortInterfacePolarity* _p = (RTC::PortInterfacePolarity*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::PortInterfacePolarity _s)
{
  _a.PR_insert(_0RL_tc_RTC_mPortInterfacePolarity,
               _0RL_RTC_mPortInterfacePolarity_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortInterfacePolarity& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mPortInterfacePolarity,
                       _0RL_RTC_mPortInterfacePolarity_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mPortInterfaceProfile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PortInterfaceProfile* _p = (RTC::PortInterfaceProfile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPortInterfaceProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PortInterfaceProfile* _p = new RTC::PortInterfaceProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPortInterfaceProfile_destructor_fn(void* _v)
{
  RTC::PortInterfaceProfile* _p = (RTC::PortInterfaceProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PortInterfaceProfile& _s)
{
  RTC::PortInterfaceProfile* _p = new RTC::PortInterfaceProfile(_s);
  _a.PR_insert(_0RL_tc_RTC_mPortInterfaceProfile,
               _0RL_RTC_mPortInterfaceProfile_marshal_fn,
               _0RL_RTC_mPortInterfaceProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PortInterfaceProfile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPortInterfaceProfile,
               _0RL_RTC_mPortInterfaceProfile_marshal_fn,
               _0RL_RTC_mPortInterfaceProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortInterfaceProfile*& _sp)
{
  return _a >>= (const RTC::PortInterfaceProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortInterfaceProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPortInterfaceProfile,
                    _0RL_RTC_mPortInterfaceProfile_unmarshal_fn,
                    _0RL_RTC_mPortInterfaceProfile_marshal_fn,
                    _0RL_RTC_mPortInterfaceProfile_destructor_fn,
                    _v)) {
    _sp = (const RTC::PortInterfaceProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPortInterfaceProfileList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PortInterfaceProfileList* _p = (RTC::PortInterfaceProfileList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPortInterfaceProfileList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PortInterfaceProfileList* _p = new RTC::PortInterfaceProfileList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPortInterfaceProfileList_destructor_fn(void* _v)
{
  RTC::PortInterfaceProfileList* _p = (RTC::PortInterfaceProfileList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PortInterfaceProfileList& _s)
{
  RTC::PortInterfaceProfileList* _p = new RTC::PortInterfaceProfileList(_s);
  _a.PR_insert(_0RL_tc_RTC_mPortInterfaceProfileList,
               _0RL_RTC_mPortInterfaceProfileList_marshal_fn,
               _0RL_RTC_mPortInterfaceProfileList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PortInterfaceProfileList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPortInterfaceProfileList,
               _0RL_RTC_mPortInterfaceProfileList_marshal_fn,
               _0RL_RTC_mPortInterfaceProfileList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortInterfaceProfileList*& _sp)
{
  return _a >>= (const RTC::PortInterfaceProfileList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortInterfaceProfileList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPortInterfaceProfileList,
                    _0RL_RTC_mPortInterfaceProfileList_unmarshal_fn,
                    _0RL_RTC_mPortInterfaceProfileList_marshal_fn,
                    _0RL_RTC_mPortInterfaceProfileList_destructor_fn,
                    _v)) {
    _sp = (const RTC::PortInterfaceProfileList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPortServiceList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PortServiceList* _p = (RTC::PortServiceList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPortServiceList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PortServiceList* _p = new RTC::PortServiceList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPortServiceList_destructor_fn(void* _v)
{
  RTC::PortServiceList* _p = (RTC::PortServiceList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PortServiceList& _s)
{
  RTC::PortServiceList* _p = new RTC::PortServiceList(_s);
  _a.PR_insert(_0RL_tc_RTC_mPortServiceList,
               _0RL_RTC_mPortServiceList_marshal_fn,
               _0RL_RTC_mPortServiceList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PortServiceList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPortServiceList,
               _0RL_RTC_mPortServiceList_marshal_fn,
               _0RL_RTC_mPortServiceList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortServiceList*& _sp)
{
  return _a >>= (const RTC::PortServiceList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortServiceList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPortServiceList,
                    _0RL_RTC_mPortServiceList_unmarshal_fn,
                    _0RL_RTC_mPortServiceList_marshal_fn,
                    _0RL_RTC_mPortServiceList_destructor_fn,
                    _v)) {
    _sp = (const RTC::PortServiceList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRTCList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RTCList* _p = (RTC::RTCList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRTCList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RTCList* _p = new RTC::RTCList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRTCList_destructor_fn(void* _v)
{
  RTC::RTCList* _p = (RTC::RTCList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RTCList& _s)
{
  RTC::RTCList* _p = new RTC::RTCList(_s);
  _a.PR_insert(_0RL_tc_RTC_mRTCList,
               _0RL_RTC_mRTCList_marshal_fn,
               _0RL_RTC_mRTCList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RTCList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRTCList,
               _0RL_RTC_mRTCList_marshal_fn,
               _0RL_RTC_mRTCList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RTCList*& _sp)
{
  return _a >>= (const RTC::RTCList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RTCList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRTCList,
                    _0RL_RTC_mRTCList_unmarshal_fn,
                    _0RL_RTC_mRTCList_marshal_fn,
                    _0RL_RTC_mRTCList_destructor_fn,
                    _v)) {
    _sp = (const RTC::RTCList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mConnectorProfile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ConnectorProfile* _p = (RTC::ConnectorProfile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mConnectorProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ConnectorProfile* _p = new RTC::ConnectorProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mConnectorProfile_destructor_fn(void* _v)
{
  RTC::ConnectorProfile* _p = (RTC::ConnectorProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ConnectorProfile& _s)
{
  RTC::ConnectorProfile* _p = new RTC::ConnectorProfile(_s);
  _a.PR_insert(_0RL_tc_RTC_mConnectorProfile,
               _0RL_RTC_mConnectorProfile_marshal_fn,
               _0RL_RTC_mConnectorProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ConnectorProfile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mConnectorProfile,
               _0RL_RTC_mConnectorProfile_marshal_fn,
               _0RL_RTC_mConnectorProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ConnectorProfile*& _sp)
{
  return _a >>= (const RTC::ConnectorProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ConnectorProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mConnectorProfile,
                    _0RL_RTC_mConnectorProfile_unmarshal_fn,
                    _0RL_RTC_mConnectorProfile_marshal_fn,
                    _0RL_RTC_mConnectorProfile_destructor_fn,
                    _v)) {
    _sp = (const RTC::ConnectorProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mConnectorProfileList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ConnectorProfileList* _p = (RTC::ConnectorProfileList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mConnectorProfileList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ConnectorProfileList* _p = new RTC::ConnectorProfileList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mConnectorProfileList_destructor_fn(void* _v)
{
  RTC::ConnectorProfileList* _p = (RTC::ConnectorProfileList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ConnectorProfileList& _s)
{
  RTC::ConnectorProfileList* _p = new RTC::ConnectorProfileList(_s);
  _a.PR_insert(_0RL_tc_RTC_mConnectorProfileList,
               _0RL_RTC_mConnectorProfileList_marshal_fn,
               _0RL_RTC_mConnectorProfileList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ConnectorProfileList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mConnectorProfileList,
               _0RL_RTC_mConnectorProfileList_marshal_fn,
               _0RL_RTC_mConnectorProfileList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ConnectorProfileList*& _sp)
{
  return _a >>= (const RTC::ConnectorProfileList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ConnectorProfileList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mConnectorProfileList,
                    _0RL_RTC_mConnectorProfileList_unmarshal_fn,
                    _0RL_RTC_mConnectorProfileList_marshal_fn,
                    _0RL_RTC_mConnectorProfileList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ConnectorProfileList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPortProfile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PortProfile* _p = (RTC::PortProfile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPortProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PortProfile* _p = new RTC::PortProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPortProfile_destructor_fn(void* _v)
{
  RTC::PortProfile* _p = (RTC::PortProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PortProfile& _s)
{
  RTC::PortProfile* _p = new RTC::PortProfile(_s);
  _a.PR_insert(_0RL_tc_RTC_mPortProfile,
               _0RL_RTC_mPortProfile_marshal_fn,
               _0RL_RTC_mPortProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PortProfile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPortProfile,
               _0RL_RTC_mPortProfile_marshal_fn,
               _0RL_RTC_mPortProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortProfile*& _sp)
{
  return _a >>= (const RTC::PortProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPortProfile,
                    _0RL_RTC_mPortProfile_unmarshal_fn,
                    _0RL_RTC_mPortProfile_marshal_fn,
                    _0RL_RTC_mPortProfile_destructor_fn,
                    _v)) {
    _sp = (const RTC::PortProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPortProfileList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PortProfileList* _p = (RTC::PortProfileList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPortProfileList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PortProfileList* _p = new RTC::PortProfileList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPortProfileList_destructor_fn(void* _v)
{
  RTC::PortProfileList* _p = (RTC::PortProfileList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PortProfileList& _s)
{
  RTC::PortProfileList* _p = new RTC::PortProfileList(_s);
  _a.PR_insert(_0RL_tc_RTC_mPortProfileList,
               _0RL_RTC_mPortProfileList_marshal_fn,
               _0RL_RTC_mPortProfileList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PortProfileList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPortProfileList,
               _0RL_RTC_mPortProfileList_marshal_fn,
               _0RL_RTC_mPortProfileList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortProfileList*& _sp)
{
  return _a >>= (const RTC::PortProfileList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortProfileList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPortProfileList,
                    _0RL_RTC_mPortProfileList_unmarshal_fn,
                    _0RL_RTC_mPortProfileList_marshal_fn,
                    _0RL_RTC_mPortProfileList_destructor_fn,
                    _v)) {
    _sp = (const RTC::PortProfileList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mExecutionContextProfile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ExecutionContextProfile* _p = (RTC::ExecutionContextProfile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mExecutionContextProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ExecutionContextProfile* _p = new RTC::ExecutionContextProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mExecutionContextProfile_destructor_fn(void* _v)
{
  RTC::ExecutionContextProfile* _p = (RTC::ExecutionContextProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextProfile& _s)
{
  RTC::ExecutionContextProfile* _p = new RTC::ExecutionContextProfile(_s);
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextProfile,
               _0RL_RTC_mExecutionContextProfile_marshal_fn,
               _0RL_RTC_mExecutionContextProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextProfile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextProfile,
               _0RL_RTC_mExecutionContextProfile_marshal_fn,
               _0RL_RTC_mExecutionContextProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextProfile*& _sp)
{
  return _a >>= (const RTC::ExecutionContextProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mExecutionContextProfile,
                    _0RL_RTC_mExecutionContextProfile_unmarshal_fn,
                    _0RL_RTC_mExecutionContextProfile_marshal_fn,
                    _0RL_RTC_mExecutionContextProfile_destructor_fn,
                    _v)) {
    _sp = (const RTC::ExecutionContextProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mExecutionContextProfileList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ExecutionContextProfileList* _p = (RTC::ExecutionContextProfileList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mExecutionContextProfileList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ExecutionContextProfileList* _p = new RTC::ExecutionContextProfileList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mExecutionContextProfileList_destructor_fn(void* _v)
{
  RTC::ExecutionContextProfileList* _p = (RTC::ExecutionContextProfileList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextProfileList& _s)
{
  RTC::ExecutionContextProfileList* _p = new RTC::ExecutionContextProfileList(_s);
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextProfileList,
               _0RL_RTC_mExecutionContextProfileList_marshal_fn,
               _0RL_RTC_mExecutionContextProfileList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextProfileList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextProfileList,
               _0RL_RTC_mExecutionContextProfileList_marshal_fn,
               _0RL_RTC_mExecutionContextProfileList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextProfileList*& _sp)
{
  return _a >>= (const RTC::ExecutionContextProfileList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextProfileList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mExecutionContextProfileList,
                    _0RL_RTC_mExecutionContextProfileList_unmarshal_fn,
                    _0RL_RTC_mExecutionContextProfileList_marshal_fn,
                    _0RL_RTC_mExecutionContextProfileList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ExecutionContextProfileList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsmObject_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mFsmObject_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::FsmObject::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mFsmObject_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::FsmObject_ptr _o)
{
  RTC::FsmObject_ptr _no = RTC::FsmObject::_duplicate(_o);
  _a.PR_insert(RTC::_tc_FsmObject,
               _0RL_RTC_mFsmObject_marshal_fn,
               _0RL_RTC_mFsmObject_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::FsmObject_ptr* _op)
{
  _a.PR_insert(RTC::_tc_FsmObject,
               _0RL_RTC_mFsmObject_marshal_fn,
               _0RL_RTC_mFsmObject_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::FsmObject::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmObject_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_FsmObject,
                    _0RL_RTC_mFsmObject_unmarshal_fn,
                    _0RL_RTC_mFsmObject_marshal_fn,
                    _0RL_RTC_mFsmObject_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::FsmObject_ptr)_r->_ptrToObjRef(RTC::FsmObject::_PD_repoId);
    else
      _o = RTC::FsmObject::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsmBehaviorProfile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FsmBehaviorProfile* _p = (RTC::FsmBehaviorProfile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFsmBehaviorProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FsmBehaviorProfile* _p = new RTC::FsmBehaviorProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFsmBehaviorProfile_destructor_fn(void* _v)
{
  RTC::FsmBehaviorProfile* _p = (RTC::FsmBehaviorProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FsmBehaviorProfile& _s)
{
  RTC::FsmBehaviorProfile* _p = new RTC::FsmBehaviorProfile(_s);
  _a.PR_insert(_0RL_tc_RTC_mFsmBehaviorProfile,
               _0RL_RTC_mFsmBehaviorProfile_marshal_fn,
               _0RL_RTC_mFsmBehaviorProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FsmBehaviorProfile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFsmBehaviorProfile,
               _0RL_RTC_mFsmBehaviorProfile_marshal_fn,
               _0RL_RTC_mFsmBehaviorProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmBehaviorProfile*& _sp)
{
  return _a >>= (const RTC::FsmBehaviorProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FsmBehaviorProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFsmBehaviorProfile,
                    _0RL_RTC_mFsmBehaviorProfile_unmarshal_fn,
                    _0RL_RTC_mFsmBehaviorProfile_marshal_fn,
                    _0RL_RTC_mFsmBehaviorProfile_destructor_fn,
                    _v)) {
    _sp = (const RTC::FsmBehaviorProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsmBehaviorProfileList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FsmBehaviorProfileList* _p = (RTC::FsmBehaviorProfileList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFsmBehaviorProfileList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FsmBehaviorProfileList* _p = new RTC::FsmBehaviorProfileList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFsmBehaviorProfileList_destructor_fn(void* _v)
{
  RTC::FsmBehaviorProfileList* _p = (RTC::FsmBehaviorProfileList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FsmBehaviorProfileList& _s)
{
  RTC::FsmBehaviorProfileList* _p = new RTC::FsmBehaviorProfileList(_s);
  _a.PR_insert(_0RL_tc_RTC_mFsmBehaviorProfileList,
               _0RL_RTC_mFsmBehaviorProfileList_marshal_fn,
               _0RL_RTC_mFsmBehaviorProfileList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FsmBehaviorProfileList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFsmBehaviorProfileList,
               _0RL_RTC_mFsmBehaviorProfileList_marshal_fn,
               _0RL_RTC_mFsmBehaviorProfileList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmBehaviorProfileList*& _sp)
{
  return _a >>= (const RTC::FsmBehaviorProfileList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FsmBehaviorProfileList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFsmBehaviorProfileList,
                    _0RL_RTC_mFsmBehaviorProfileList_unmarshal_fn,
                    _0RL_RTC_mFsmBehaviorProfileList_marshal_fn,
                    _0RL_RTC_mFsmBehaviorProfileList_destructor_fn,
                    _v)) {
    _sp = (const RTC::FsmBehaviorProfileList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsmProfile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FsmProfile* _p = (RTC::FsmProfile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFsmProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FsmProfile* _p = new RTC::FsmProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFsmProfile_destructor_fn(void* _v)
{
  RTC::FsmProfile* _p = (RTC::FsmProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FsmProfile& _s)
{
  RTC::FsmProfile* _p = new RTC::FsmProfile(_s);
  _a.PR_insert(_0RL_tc_RTC_mFsmProfile,
               _0RL_RTC_mFsmProfile_marshal_fn,
               _0RL_RTC_mFsmProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FsmProfile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFsmProfile,
               _0RL_RTC_mFsmProfile_marshal_fn,
               _0RL_RTC_mFsmProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmProfile*& _sp)
{
  return _a >>= (const RTC::FsmProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FsmProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFsmProfile,
                    _0RL_RTC_mFsmProfile_unmarshal_fn,
                    _0RL_RTC_mFsmProfile_marshal_fn,
                    _0RL_RTC_mFsmProfile_destructor_fn,
                    _v)) {
    _sp = (const RTC::FsmProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFsmService_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mFsmService_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::FsmService::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mFsmService_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::FsmService_ptr _o)
{
  RTC::FsmService_ptr _no = RTC::FsmService::_duplicate(_o);
  _a.PR_insert(RTC::_tc_FsmService,
               _0RL_RTC_mFsmService_marshal_fn,
               _0RL_RTC_mFsmService_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::FsmService_ptr* _op)
{
  _a.PR_insert(RTC::_tc_FsmService,
               _0RL_RTC_mFsmService_marshal_fn,
               _0RL_RTC_mFsmService_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::FsmService::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmService_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_FsmService,
                    _0RL_RTC_mFsmService_unmarshal_fn,
                    _0RL_RTC_mFsmService_marshal_fn,
                    _0RL_RTC_mFsmService_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::FsmService_ptr)_r->_ptrToObjRef(RTC::FsmService::_PD_repoId);
    else
      _o = RTC::FsmService::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mComponentProfile_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ComponentProfile* _p = (RTC::ComponentProfile*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mComponentProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ComponentProfile* _p = new RTC::ComponentProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mComponentProfile_destructor_fn(void* _v)
{
  RTC::ComponentProfile* _p = (RTC::ComponentProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ComponentProfile& _s)
{
  RTC::ComponentProfile* _p = new RTC::ComponentProfile(_s);
  _a.PR_insert(_0RL_tc_RTC_mComponentProfile,
               _0RL_RTC_mComponentProfile_marshal_fn,
               _0RL_RTC_mComponentProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ComponentProfile* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mComponentProfile,
               _0RL_RTC_mComponentProfile_marshal_fn,
               _0RL_RTC_mComponentProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ComponentProfile*& _sp)
{
  return _a >>= (const RTC::ComponentProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ComponentProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mComponentProfile,
                    _0RL_RTC_mComponentProfile_unmarshal_fn,
                    _0RL_RTC_mComponentProfile_marshal_fn,
                    _0RL_RTC_mComponentProfile_destructor_fn,
                    _v)) {
    _sp = (const RTC::ComponentProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mComponentProfileList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ComponentProfileList* _p = (RTC::ComponentProfileList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mComponentProfileList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ComponentProfileList* _p = new RTC::ComponentProfileList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mComponentProfileList_destructor_fn(void* _v)
{
  RTC::ComponentProfileList* _p = (RTC::ComponentProfileList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ComponentProfileList& _s)
{
  RTC::ComponentProfileList* _p = new RTC::ComponentProfileList(_s);
  _a.PR_insert(_0RL_tc_RTC_mComponentProfileList,
               _0RL_RTC_mComponentProfileList_marshal_fn,
               _0RL_RTC_mComponentProfileList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ComponentProfileList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mComponentProfileList,
               _0RL_RTC_mComponentProfileList_marshal_fn,
               _0RL_RTC_mComponentProfileList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ComponentProfileList*& _sp)
{
  return _a >>= (const RTC::ComponentProfileList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ComponentProfileList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mComponentProfileList,
                    _0RL_RTC_mComponentProfileList_unmarshal_fn,
                    _0RL_RTC_mComponentProfileList_marshal_fn,
                    _0RL_RTC_mComponentProfileList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ComponentProfileList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPortService_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mPortService_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::PortService::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mPortService_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::PortService_ptr _o)
{
  RTC::PortService_ptr _no = RTC::PortService::_duplicate(_o);
  _a.PR_insert(RTC::_tc_PortService,
               _0RL_RTC_mPortService_marshal_fn,
               _0RL_RTC_mPortService_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::PortService_ptr* _op)
{
  _a.PR_insert(RTC::_tc_PortService,
               _0RL_RTC_mPortService_marshal_fn,
               _0RL_RTC_mPortService_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::PortService::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortService_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_PortService,
                    _0RL_RTC_mPortService_unmarshal_fn,
                    _0RL_RTC_mPortService_marshal_fn,
                    _0RL_RTC_mPortService_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::PortService_ptr)_r->_ptrToObjRef(RTC::PortService::_PD_repoId);
    else
      _o = RTC::PortService::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mExecutionContextService_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mExecutionContextService_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::ExecutionContextService::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mExecutionContextService_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextService_ptr _o)
{
  RTC::ExecutionContextService_ptr _no = RTC::ExecutionContextService::_duplicate(_o);
  _a.PR_insert(RTC::_tc_ExecutionContextService,
               _0RL_RTC_mExecutionContextService_marshal_fn,
               _0RL_RTC_mExecutionContextService_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextService_ptr* _op)
{
  _a.PR_insert(RTC::_tc_ExecutionContextService,
               _0RL_RTC_mExecutionContextService_marshal_fn,
               _0RL_RTC_mExecutionContextService_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::ExecutionContextService::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextService_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_ExecutionContextService,
                    _0RL_RTC_mExecutionContextService_unmarshal_fn,
                    _0RL_RTC_mExecutionContextService_marshal_fn,
                    _0RL_RTC_mExecutionContextService_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::ExecutionContextService_ptr)_r->_ptrToObjRef(RTC::ExecutionContextService::_PD_repoId);
    else
      _o = RTC::ExecutionContextService::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mExecutionContextServiceList_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::ExecutionContextServiceList* _p = (RTC::ExecutionContextServiceList*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mExecutionContextServiceList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::ExecutionContextServiceList* _p = new RTC::ExecutionContextServiceList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mExecutionContextServiceList_destructor_fn(void* _v)
{
  RTC::ExecutionContextServiceList* _p = (RTC::ExecutionContextServiceList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextServiceList& _s)
{
  RTC::ExecutionContextServiceList* _p = new RTC::ExecutionContextServiceList(_s);
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextServiceList,
               _0RL_RTC_mExecutionContextServiceList_marshal_fn,
               _0RL_RTC_mExecutionContextServiceList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextServiceList* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mExecutionContextServiceList,
               _0RL_RTC_mExecutionContextServiceList_marshal_fn,
               _0RL_RTC_mExecutionContextServiceList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextServiceList*& _sp)
{
  return _a >>= (const RTC::ExecutionContextServiceList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextServiceList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mExecutionContextServiceList,
                    _0RL_RTC_mExecutionContextServiceList_unmarshal_fn,
                    _0RL_RTC_mExecutionContextServiceList_marshal_fn,
                    _0RL_RTC_mExecutionContextServiceList_destructor_fn,
                    _v)) {
    _sp = (const RTC::ExecutionContextServiceList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRTObject_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mRTObject_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::RTObject::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mRTObject_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::RTObject_ptr _o)
{
  RTC::RTObject_ptr _no = RTC::RTObject::_duplicate(_o);
  _a.PR_insert(RTC::_tc_RTObject,
               _0RL_RTC_mRTObject_marshal_fn,
               _0RL_RTC_mRTObject_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::RTObject_ptr* _op)
{
  _a.PR_insert(RTC::_tc_RTObject,
               _0RL_RTC_mRTObject_marshal_fn,
               _0RL_RTC_mRTObject_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::RTObject::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RTObject_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_RTObject,
                    _0RL_RTC_mRTObject_unmarshal_fn,
                    _0RL_RTC_mRTObject_marshal_fn,
                    _0RL_RTC_mRTObject_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::RTObject_ptr)_r->_ptrToObjRef(RTC::RTObject::_PD_repoId);
    else
      _o = RTC::RTObject::_nil();
    return 1;
  }
  return 0;
}

