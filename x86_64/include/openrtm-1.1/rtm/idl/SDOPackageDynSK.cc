// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "SDOPackage.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mStringList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/StringList:1.0", "StringList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_StringList = _0RL_tc_SDOPackage_mStringList;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_StringList = _0RL_tc_SDOPackage_mStringList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mSDOList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/SDOList:1.0", "SDOList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDO:1.0", "SDO", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_SDOList = _0RL_tc_SDOPackage_mSDOList;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_SDOList = _0RL_tc_SDOPackage_mSDOList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mOrganizationList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/OrganizationList:1.0", "OrganizationList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/Organization:1.0", "Organization", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_OrganizationList = _0RL_tc_SDOPackage_mOrganizationList;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_OrganizationList = _0RL_tc_SDOPackage_mOrganizationList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mUniqueIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/UniqueIdentifier:1.0", "UniqueIdentifier", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_UniqueIdentifier = _0RL_tc_SDOPackage_mUniqueIdentifier;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_UniqueIdentifier = _0RL_tc_SDOPackage_mUniqueIdentifier;
#endif

static CORBA::PR_structMember _0RL_structmember_SDOPackage_mNameValue[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_SDOPackage_mNameValue
#  undef _0RL_tc_SDOPackage_mNameValue
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mNameValue = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/NameValue:1.0", "NameValue", _0RL_structmember_SDOPackage_mNameValue, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_NameValue = _0RL_tc_SDOPackage_mNameValue;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_NameValue = _0RL_tc_SDOPackage_mNameValue;
#endif






static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mNVList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/NVList:1.0", "NVList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_SDOPackage_mNameValue, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_NVList = _0RL_tc_SDOPackage_mNVList;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_NVList = _0RL_tc_SDOPackage_mNVList;
#endif

static const char* _0RL_enumMember_SDOPackage_mNumericType[] = { "SHORT_TYPE", "LONG_TYPE", "FLOAT_TYPE", "DOUBLE_TYPE" };
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mNumericType = CORBA::TypeCode::PR_enum_tc("IDL:org.omg/SDOPackage/NumericType:1.0", "NumericType", _0RL_enumMember_SDOPackage_mNumericType, 4, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_NumericType = _0RL_tc_SDOPackage_mNumericType;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_NumericType = _0RL_tc_SDOPackage_mNumericType;
#endif

static CORBA::PR_unionMember _0RL_unionMember_SDOPackage_mNumeric[] = {
  {"short_value", CORBA::TypeCode::PR_short_tc(), SDOPackage::SHORT_TYPE},
  {"long_value", CORBA::TypeCode::PR_long_tc(), SDOPackage::LONG_TYPE},
  {"float_value", CORBA::TypeCode::PR_float_tc(), SDOPackage::FLOAT_TYPE},
  {"double_value", CORBA::TypeCode::PR_double_tc(), SDOPackage::DOUBLE_TYPE}
};
#ifdef _0RL_tc_SDOPackage_mNumeric
#  undef _0RL_tc_SDOPackage_mNumeric
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mNumeric = CORBA::TypeCode::PR_union_tc("IDL:org.omg/SDOPackage/Numeric:1.0", "Numeric", _0RL_tc_SDOPackage_mNumericType, _0RL_unionMember_SDOPackage_mNumeric, 4, -1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_Numeric = _0RL_tc_SDOPackage_mNumeric;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_Numeric = _0RL_tc_SDOPackage_mNumeric;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mEnumerationType[] = {
  {"enumerated_values", _0RL_tc_SDOPackage_mStringList}
};

#ifdef _0RL_tc_SDOPackage_mEnumerationType
#  undef _0RL_tc_SDOPackage_mEnumerationType
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mEnumerationType = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/EnumerationType:1.0", "EnumerationType", _0RL_structmember_SDOPackage_mEnumerationType, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_EnumerationType = _0RL_tc_SDOPackage_mEnumerationType;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_EnumerationType = _0RL_tc_SDOPackage_mEnumerationType;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mRangeType[] = {
  {"min", _0RL_tc_SDOPackage_mNumeric},
  {"max", _0RL_tc_SDOPackage_mNumeric},
  {"min_inclusive", CORBA::TypeCode::PR_boolean_tc()},
  {"max_inclusive", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_SDOPackage_mRangeType
#  undef _0RL_tc_SDOPackage_mRangeType
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mRangeType = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/RangeType:1.0", "RangeType", _0RL_structmember_SDOPackage_mRangeType, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_RangeType = _0RL_tc_SDOPackage_mRangeType;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_RangeType = _0RL_tc_SDOPackage_mRangeType;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mIntervalType[] = {
  {"min", _0RL_tc_SDOPackage_mNumeric},
  {"max", _0RL_tc_SDOPackage_mNumeric},
  {"min_inclusive", CORBA::TypeCode::PR_boolean_tc()},
  {"max_inclusive", CORBA::TypeCode::PR_boolean_tc()},
  {"step", _0RL_tc_SDOPackage_mNumeric}
};

#ifdef _0RL_tc_SDOPackage_mIntervalType
#  undef _0RL_tc_SDOPackage_mIntervalType
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mIntervalType = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/IntervalType:1.0", "IntervalType", _0RL_structmember_SDOPackage_mIntervalType, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_IntervalType = _0RL_tc_SDOPackage_mIntervalType;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_IntervalType = _0RL_tc_SDOPackage_mIntervalType;
#endif


static const char* _0RL_enumMember_SDOPackage_mComplexDataType[] = { "ENUMERATION", "RANGE", "INTERVAL" };
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mComplexDataType = CORBA::TypeCode::PR_enum_tc("IDL:org.omg/SDOPackage/ComplexDataType:1.0", "ComplexDataType", _0RL_enumMember_SDOPackage_mComplexDataType, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_ComplexDataType = _0RL_tc_SDOPackage_mComplexDataType;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_ComplexDataType = _0RL_tc_SDOPackage_mComplexDataType;
#endif




static CORBA::PR_unionMember _0RL_unionMember_SDOPackage_mAllowedValues[] = {
  {"allowed_enum", _0RL_tc_SDOPackage_mEnumerationType, SDOPackage::ENUMERATION},
  {"allowed_interval", _0RL_tc_SDOPackage_mIntervalType, SDOPackage::INTERVAL},
  {"allowed_range", _0RL_tc_SDOPackage_mRangeType, SDOPackage::RANGE}
};
#ifdef _0RL_tc_SDOPackage_mAllowedValues
#  undef _0RL_tc_SDOPackage_mAllowedValues
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mAllowedValues = CORBA::TypeCode::PR_union_tc("IDL:org.omg/SDOPackage/AllowedValues:1.0", "AllowedValues", _0RL_tc_SDOPackage_mComplexDataType, _0RL_unionMember_SDOPackage_mAllowedValues, 3, -1, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_AllowedValues = _0RL_tc_SDOPackage_mAllowedValues;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_AllowedValues = _0RL_tc_SDOPackage_mAllowedValues;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mParameter[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"allowed_values", _0RL_tc_SDOPackage_mAllowedValues}
};

#ifdef _0RL_tc_SDOPackage_mParameter
#  undef _0RL_tc_SDOPackage_mParameter
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mParameter = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/Parameter:1.0", "Parameter", _0RL_structmember_SDOPackage_mParameter, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_Parameter = _0RL_tc_SDOPackage_mParameter;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_Parameter = _0RL_tc_SDOPackage_mParameter;
#endif






static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mParameterList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/ParameterList:1.0", "ParameterList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_SDOPackage_mParameter, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_ParameterList = _0RL_tc_SDOPackage_mParameterList;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_ParameterList = _0RL_tc_SDOPackage_mParameterList;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mOrganizationProperty[] = {
  {"properties", _0RL_tc_SDOPackage_mNVList}
};

#ifdef _0RL_tc_SDOPackage_mOrganizationProperty
#  undef _0RL_tc_SDOPackage_mOrganizationProperty
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mOrganizationProperty = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/OrganizationProperty:1.0", "OrganizationProperty", _0RL_structmember_SDOPackage_mOrganizationProperty, 1, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_OrganizationProperty = _0RL_tc_SDOPackage_mOrganizationProperty;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_OrganizationProperty = _0RL_tc_SDOPackage_mOrganizationProperty;
#endif


static const char* _0RL_enumMember_SDOPackage_mDependencyType[] = { "OWN", "OWNED", "NO_DEPENDENCY" };
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mDependencyType = CORBA::TypeCode::PR_enum_tc("IDL:org.omg/SDOPackage/DependencyType:1.0", "DependencyType", _0RL_enumMember_SDOPackage_mDependencyType, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_DependencyType = _0RL_tc_SDOPackage_mDependencyType;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_DependencyType = _0RL_tc_SDOPackage_mDependencyType;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mDeviceProfile[] = {
  {"device_type", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"manufacturer", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"model", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"version", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"properties", _0RL_tc_SDOPackage_mNVList}
};

#ifdef _0RL_tc_SDOPackage_mDeviceProfile
#  undef _0RL_tc_SDOPackage_mDeviceProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mDeviceProfile = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/DeviceProfile:1.0", "DeviceProfile", _0RL_structmember_SDOPackage_mDeviceProfile, 5, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_DeviceProfile = _0RL_tc_SDOPackage_mDeviceProfile;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_DeviceProfile = _0RL_tc_SDOPackage_mDeviceProfile;
#endif



static CORBA::PR_structMember _0RL_structmember_SDOPackage_mServiceProfile[] = {
  {"id", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"interface_type", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"properties", _0RL_tc_SDOPackage_mNVList},
  {"service", CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDOService:1.0", "SDOService", &_0RL_tcTrack)}
};

#ifdef _0RL_tc_SDOPackage_mServiceProfile
#  undef _0RL_tc_SDOPackage_mServiceProfile
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mServiceProfile = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/ServiceProfile:1.0", "ServiceProfile", _0RL_structmember_SDOPackage_mServiceProfile, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_ServiceProfile = _0RL_tc_SDOPackage_mServiceProfile;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_ServiceProfile = _0RL_tc_SDOPackage_mServiceProfile;
#endif










static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mServiceProfileList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/ServiceProfileList:1.0", "ServiceProfileList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_SDOPackage_mServiceProfile, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_ServiceProfileList = _0RL_tc_SDOPackage_mServiceProfileList;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_ServiceProfileList = _0RL_tc_SDOPackage_mServiceProfileList;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mConfigurationSet[] = {
  {"id", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"description", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"configuration_data", _0RL_tc_SDOPackage_mNVList}
};

#ifdef _0RL_tc_SDOPackage_mConfigurationSet
#  undef _0RL_tc_SDOPackage_mConfigurationSet
#endif
static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mConfigurationSet = CORBA::TypeCode::PR_struct_tc("IDL:org.omg/SDOPackage/ConfigurationSet:1.0", "ConfigurationSet", _0RL_structmember_SDOPackage_mConfigurationSet, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_ConfigurationSet = _0RL_tc_SDOPackage_mConfigurationSet;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_ConfigurationSet = _0RL_tc_SDOPackage_mConfigurationSet;
#endif










static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mConfigurationSetList = CORBA::TypeCode::PR_alias_tc("IDL:org.omg/SDOPackage/ConfigurationSetList:1.0", "ConfigurationSetList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_SDOPackage_mConfigurationSet, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_ConfigurationSetList = _0RL_tc_SDOPackage_mConfigurationSetList;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_ConfigurationSetList = _0RL_tc_SDOPackage_mConfigurationSetList;
#endif

static CORBA::PR_structMember _0RL_structmember_SDOPackage_mNotAvailable[] = {
  {"description", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mNotAvailable = CORBA::TypeCode::PR_exception_tc("IDL:org.omg/SDOPackage/NotAvailable:1.0", "NotAvailable", _0RL_structmember_SDOPackage_mNotAvailable, 1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_NotAvailable = _0RL_tc_SDOPackage_mNotAvailable;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_NotAvailable = _0RL_tc_SDOPackage_mNotAvailable;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mInterfaceNotImplemented[] = {
  {"description", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mInterfaceNotImplemented = CORBA::TypeCode::PR_exception_tc("IDL:org.omg/SDOPackage/InterfaceNotImplemented:1.0", "InterfaceNotImplemented", _0RL_structmember_SDOPackage_mInterfaceNotImplemented, 1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_InterfaceNotImplemented = _0RL_tc_SDOPackage_mInterfaceNotImplemented;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_InterfaceNotImplemented = _0RL_tc_SDOPackage_mInterfaceNotImplemented;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mInvalidParameter[] = {
  {"description", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mInvalidParameter = CORBA::TypeCode::PR_exception_tc("IDL:org.omg/SDOPackage/InvalidParameter:1.0", "InvalidParameter", _0RL_structmember_SDOPackage_mInvalidParameter, 1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_InvalidParameter = _0RL_tc_SDOPackage_mInvalidParameter;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_InvalidParameter = _0RL_tc_SDOPackage_mInvalidParameter;
#endif


static CORBA::PR_structMember _0RL_structmember_SDOPackage_mInternalError[] = {
  {"description", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_SDOPackage_mInternalError = CORBA::TypeCode::PR_exception_tc("IDL:org.omg/SDOPackage/InternalError:1.0", "InternalError", _0RL_structmember_SDOPackage_mInternalError, 1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_InternalError = _0RL_tc_SDOPackage_mInternalError;
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_InternalError = _0RL_tc_SDOPackage_mInternalError;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_SDOSystemElement = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDOSystemElement:1.0", "SDOSystemElement", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_SDOSystemElement = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDOSystemElement:1.0", "SDOSystemElement", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_SDO = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDO:1.0", "SDO", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_SDO = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDO:1.0", "SDO", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_Configuration = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/Configuration:1.0", "Configuration", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_Configuration = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/Configuration:1.0", "Configuration", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_Monitoring = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/Monitoring:1.0", "Monitoring", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_Monitoring = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/Monitoring:1.0", "Monitoring", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_SDOService = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDOService:1.0", "SDOService", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_SDOService = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/SDOService:1.0", "SDOService", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SDOPackage { 
  const ::CORBA::TypeCode_ptr _tc_Organization = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/Organization:1.0", "Organization", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr SDOPackage::_tc_Organization = CORBA::TypeCode::PR_interface_tc("IDL:org.omg/SDOPackage/Organization:1.0", "Organization", &_0RL_tcTrack);
#endif

static void _0RL_SDOPackage_mStringList_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::StringList* _p = (SDOPackage::StringList*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mStringList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::StringList* _p = new SDOPackage::StringList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mStringList_destructor_fn(void* _v)
{
  SDOPackage::StringList* _p = (SDOPackage::StringList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::StringList& _s)
{
  SDOPackage::StringList* _p = new SDOPackage::StringList(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mStringList,
               _0RL_SDOPackage_mStringList_marshal_fn,
               _0RL_SDOPackage_mStringList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::StringList* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mStringList,
               _0RL_SDOPackage_mStringList_marshal_fn,
               _0RL_SDOPackage_mStringList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::StringList*& _sp)
{
  return _a >>= (const SDOPackage::StringList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::StringList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mStringList,
                    _0RL_SDOPackage_mStringList_unmarshal_fn,
                    _0RL_SDOPackage_mStringList_marshal_fn,
                    _0RL_SDOPackage_mStringList_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::StringList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mSDOList_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::SDOList* _p = (SDOPackage::SDOList*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mSDOList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::SDOList* _p = new SDOPackage::SDOList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mSDOList_destructor_fn(void* _v)
{
  SDOPackage::SDOList* _p = (SDOPackage::SDOList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::SDOList& _s)
{
  SDOPackage::SDOList* _p = new SDOPackage::SDOList(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mSDOList,
               _0RL_SDOPackage_mSDOList_marshal_fn,
               _0RL_SDOPackage_mSDOList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::SDOList* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mSDOList,
               _0RL_SDOPackage_mSDOList_marshal_fn,
               _0RL_SDOPackage_mSDOList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDOList*& _sp)
{
  return _a >>= (const SDOPackage::SDOList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::SDOList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mSDOList,
                    _0RL_SDOPackage_mSDOList_unmarshal_fn,
                    _0RL_SDOPackage_mSDOList_marshal_fn,
                    _0RL_SDOPackage_mSDOList_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::SDOList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mOrganizationList_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::OrganizationList* _p = (SDOPackage::OrganizationList*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mOrganizationList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::OrganizationList* _p = new SDOPackage::OrganizationList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mOrganizationList_destructor_fn(void* _v)
{
  SDOPackage::OrganizationList* _p = (SDOPackage::OrganizationList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::OrganizationList& _s)
{
  SDOPackage::OrganizationList* _p = new SDOPackage::OrganizationList(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mOrganizationList,
               _0RL_SDOPackage_mOrganizationList_marshal_fn,
               _0RL_SDOPackage_mOrganizationList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::OrganizationList* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mOrganizationList,
               _0RL_SDOPackage_mOrganizationList_marshal_fn,
               _0RL_SDOPackage_mOrganizationList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::OrganizationList*& _sp)
{
  return _a >>= (const SDOPackage::OrganizationList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::OrganizationList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mOrganizationList,
                    _0RL_SDOPackage_mOrganizationList_unmarshal_fn,
                    _0RL_SDOPackage_mOrganizationList_marshal_fn,
                    _0RL_SDOPackage_mOrganizationList_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::OrganizationList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mNameValue_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::NameValue* _p = (SDOPackage::NameValue*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mNameValue_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::NameValue* _p = new SDOPackage::NameValue;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mNameValue_destructor_fn(void* _v)
{
  SDOPackage::NameValue* _p = (SDOPackage::NameValue*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::NameValue& _s)
{
  SDOPackage::NameValue* _p = new SDOPackage::NameValue(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mNameValue,
               _0RL_SDOPackage_mNameValue_marshal_fn,
               _0RL_SDOPackage_mNameValue_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::NameValue* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mNameValue,
               _0RL_SDOPackage_mNameValue_marshal_fn,
               _0RL_SDOPackage_mNameValue_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::NameValue*& _sp)
{
  return _a >>= (const SDOPackage::NameValue*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::NameValue*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mNameValue,
                    _0RL_SDOPackage_mNameValue_unmarshal_fn,
                    _0RL_SDOPackage_mNameValue_marshal_fn,
                    _0RL_SDOPackage_mNameValue_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::NameValue*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mNVList_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::NVList* _p = (SDOPackage::NVList*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mNVList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::NVList* _p = new SDOPackage::NVList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mNVList_destructor_fn(void* _v)
{
  SDOPackage::NVList* _p = (SDOPackage::NVList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::NVList& _s)
{
  SDOPackage::NVList* _p = new SDOPackage::NVList(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mNVList,
               _0RL_SDOPackage_mNVList_marshal_fn,
               _0RL_SDOPackage_mNVList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::NVList* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mNVList,
               _0RL_SDOPackage_mNVList_marshal_fn,
               _0RL_SDOPackage_mNVList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::NVList*& _sp)
{
  return _a >>= (const SDOPackage::NVList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::NVList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mNVList,
                    _0RL_SDOPackage_mNVList_unmarshal_fn,
                    _0RL_SDOPackage_mNVList_marshal_fn,
                    _0RL_SDOPackage_mNVList_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::NVList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mNumericType_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::NumericType* _p = (SDOPackage::NumericType*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mNumericType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::NumericType* _p = (SDOPackage::NumericType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, SDOPackage::NumericType _s)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mNumericType,
               _0RL_SDOPackage_mNumericType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::NumericType& _s)
{
  return _a.PR_extract(_0RL_tc_SDOPackage_mNumericType,
                       _0RL_SDOPackage_mNumericType_unmarshal_fn,
                       &_s);
}

static void _0RL_SDOPackage_mNumeric_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::Numeric* _p = (SDOPackage::Numeric*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mNumeric_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::Numeric* _p = new SDOPackage::Numeric;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mNumeric_destructor_fn(void* _v)
{
  SDOPackage::Numeric* _p = (SDOPackage::Numeric*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::Numeric& _s)
{
  SDOPackage::Numeric* _p = new SDOPackage::Numeric(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mNumeric,
               _0RL_SDOPackage_mNumeric_marshal_fn,
               _0RL_SDOPackage_mNumeric_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::Numeric* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mNumeric,
               _0RL_SDOPackage_mNumeric_marshal_fn,
               _0RL_SDOPackage_mNumeric_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Numeric*& _sp)
{
  return _a >>= (const SDOPackage::Numeric*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::Numeric*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mNumeric,
                    _0RL_SDOPackage_mNumeric_unmarshal_fn,
                    _0RL_SDOPackage_mNumeric_marshal_fn,
                    _0RL_SDOPackage_mNumeric_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::Numeric*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mEnumerationType_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::EnumerationType* _p = (SDOPackage::EnumerationType*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mEnumerationType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::EnumerationType* _p = new SDOPackage::EnumerationType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mEnumerationType_destructor_fn(void* _v)
{
  SDOPackage::EnumerationType* _p = (SDOPackage::EnumerationType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::EnumerationType& _s)
{
  SDOPackage::EnumerationType* _p = new SDOPackage::EnumerationType(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mEnumerationType,
               _0RL_SDOPackage_mEnumerationType_marshal_fn,
               _0RL_SDOPackage_mEnumerationType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::EnumerationType* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mEnumerationType,
               _0RL_SDOPackage_mEnumerationType_marshal_fn,
               _0RL_SDOPackage_mEnumerationType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::EnumerationType*& _sp)
{
  return _a >>= (const SDOPackage::EnumerationType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::EnumerationType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mEnumerationType,
                    _0RL_SDOPackage_mEnumerationType_unmarshal_fn,
                    _0RL_SDOPackage_mEnumerationType_marshal_fn,
                    _0RL_SDOPackage_mEnumerationType_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::EnumerationType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mRangeType_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::RangeType* _p = (SDOPackage::RangeType*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mRangeType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::RangeType* _p = new SDOPackage::RangeType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mRangeType_destructor_fn(void* _v)
{
  SDOPackage::RangeType* _p = (SDOPackage::RangeType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::RangeType& _s)
{
  SDOPackage::RangeType* _p = new SDOPackage::RangeType(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mRangeType,
               _0RL_SDOPackage_mRangeType_marshal_fn,
               _0RL_SDOPackage_mRangeType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::RangeType* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mRangeType,
               _0RL_SDOPackage_mRangeType_marshal_fn,
               _0RL_SDOPackage_mRangeType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::RangeType*& _sp)
{
  return _a >>= (const SDOPackage::RangeType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::RangeType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mRangeType,
                    _0RL_SDOPackage_mRangeType_unmarshal_fn,
                    _0RL_SDOPackage_mRangeType_marshal_fn,
                    _0RL_SDOPackage_mRangeType_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::RangeType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mIntervalType_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::IntervalType* _p = (SDOPackage::IntervalType*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mIntervalType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::IntervalType* _p = new SDOPackage::IntervalType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mIntervalType_destructor_fn(void* _v)
{
  SDOPackage::IntervalType* _p = (SDOPackage::IntervalType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::IntervalType& _s)
{
  SDOPackage::IntervalType* _p = new SDOPackage::IntervalType(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mIntervalType,
               _0RL_SDOPackage_mIntervalType_marshal_fn,
               _0RL_SDOPackage_mIntervalType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::IntervalType* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mIntervalType,
               _0RL_SDOPackage_mIntervalType_marshal_fn,
               _0RL_SDOPackage_mIntervalType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::IntervalType*& _sp)
{
  return _a >>= (const SDOPackage::IntervalType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::IntervalType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mIntervalType,
                    _0RL_SDOPackage_mIntervalType_unmarshal_fn,
                    _0RL_SDOPackage_mIntervalType_marshal_fn,
                    _0RL_SDOPackage_mIntervalType_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::IntervalType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mComplexDataType_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::ComplexDataType* _p = (SDOPackage::ComplexDataType*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mComplexDataType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::ComplexDataType* _p = (SDOPackage::ComplexDataType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, SDOPackage::ComplexDataType _s)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mComplexDataType,
               _0RL_SDOPackage_mComplexDataType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ComplexDataType& _s)
{
  return _a.PR_extract(_0RL_tc_SDOPackage_mComplexDataType,
                       _0RL_SDOPackage_mComplexDataType_unmarshal_fn,
                       &_s);
}

static void _0RL_SDOPackage_mAllowedValues_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::AllowedValues* _p = (SDOPackage::AllowedValues*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mAllowedValues_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::AllowedValues* _p = new SDOPackage::AllowedValues;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mAllowedValues_destructor_fn(void* _v)
{
  SDOPackage::AllowedValues* _p = (SDOPackage::AllowedValues*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::AllowedValues& _s)
{
  SDOPackage::AllowedValues* _p = new SDOPackage::AllowedValues(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mAllowedValues,
               _0RL_SDOPackage_mAllowedValues_marshal_fn,
               _0RL_SDOPackage_mAllowedValues_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::AllowedValues* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mAllowedValues,
               _0RL_SDOPackage_mAllowedValues_marshal_fn,
               _0RL_SDOPackage_mAllowedValues_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::AllowedValues*& _sp)
{
  return _a >>= (const SDOPackage::AllowedValues*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::AllowedValues*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mAllowedValues,
                    _0RL_SDOPackage_mAllowedValues_unmarshal_fn,
                    _0RL_SDOPackage_mAllowedValues_marshal_fn,
                    _0RL_SDOPackage_mAllowedValues_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::AllowedValues*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mParameter_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::Parameter* _p = (SDOPackage::Parameter*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mParameter_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::Parameter* _p = new SDOPackage::Parameter;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mParameter_destructor_fn(void* _v)
{
  SDOPackage::Parameter* _p = (SDOPackage::Parameter*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::Parameter& _s)
{
  SDOPackage::Parameter* _p = new SDOPackage::Parameter(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mParameter,
               _0RL_SDOPackage_mParameter_marshal_fn,
               _0RL_SDOPackage_mParameter_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::Parameter* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mParameter,
               _0RL_SDOPackage_mParameter_marshal_fn,
               _0RL_SDOPackage_mParameter_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Parameter*& _sp)
{
  return _a >>= (const SDOPackage::Parameter*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::Parameter*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mParameter,
                    _0RL_SDOPackage_mParameter_unmarshal_fn,
                    _0RL_SDOPackage_mParameter_marshal_fn,
                    _0RL_SDOPackage_mParameter_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::Parameter*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mParameterList_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::ParameterList* _p = (SDOPackage::ParameterList*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mParameterList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::ParameterList* _p = new SDOPackage::ParameterList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mParameterList_destructor_fn(void* _v)
{
  SDOPackage::ParameterList* _p = (SDOPackage::ParameterList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::ParameterList& _s)
{
  SDOPackage::ParameterList* _p = new SDOPackage::ParameterList(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mParameterList,
               _0RL_SDOPackage_mParameterList_marshal_fn,
               _0RL_SDOPackage_mParameterList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::ParameterList* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mParameterList,
               _0RL_SDOPackage_mParameterList_marshal_fn,
               _0RL_SDOPackage_mParameterList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ParameterList*& _sp)
{
  return _a >>= (const SDOPackage::ParameterList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ParameterList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mParameterList,
                    _0RL_SDOPackage_mParameterList_unmarshal_fn,
                    _0RL_SDOPackage_mParameterList_marshal_fn,
                    _0RL_SDOPackage_mParameterList_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::ParameterList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mOrganizationProperty_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::OrganizationProperty* _p = (SDOPackage::OrganizationProperty*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mOrganizationProperty_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::OrganizationProperty* _p = new SDOPackage::OrganizationProperty;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mOrganizationProperty_destructor_fn(void* _v)
{
  SDOPackage::OrganizationProperty* _p = (SDOPackage::OrganizationProperty*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::OrganizationProperty& _s)
{
  SDOPackage::OrganizationProperty* _p = new SDOPackage::OrganizationProperty(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mOrganizationProperty,
               _0RL_SDOPackage_mOrganizationProperty_marshal_fn,
               _0RL_SDOPackage_mOrganizationProperty_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::OrganizationProperty* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mOrganizationProperty,
               _0RL_SDOPackage_mOrganizationProperty_marshal_fn,
               _0RL_SDOPackage_mOrganizationProperty_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::OrganizationProperty*& _sp)
{
  return _a >>= (const SDOPackage::OrganizationProperty*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::OrganizationProperty*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mOrganizationProperty,
                    _0RL_SDOPackage_mOrganizationProperty_unmarshal_fn,
                    _0RL_SDOPackage_mOrganizationProperty_marshal_fn,
                    _0RL_SDOPackage_mOrganizationProperty_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::OrganizationProperty*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mDependencyType_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::DependencyType* _p = (SDOPackage::DependencyType*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mDependencyType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::DependencyType* _p = (SDOPackage::DependencyType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, SDOPackage::DependencyType _s)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mDependencyType,
               _0RL_SDOPackage_mDependencyType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::DependencyType& _s)
{
  return _a.PR_extract(_0RL_tc_SDOPackage_mDependencyType,
                       _0RL_SDOPackage_mDependencyType_unmarshal_fn,
                       &_s);
}

static void _0RL_SDOPackage_mDeviceProfile_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::DeviceProfile* _p = (SDOPackage::DeviceProfile*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mDeviceProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::DeviceProfile* _p = new SDOPackage::DeviceProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mDeviceProfile_destructor_fn(void* _v)
{
  SDOPackage::DeviceProfile* _p = (SDOPackage::DeviceProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::DeviceProfile& _s)
{
  SDOPackage::DeviceProfile* _p = new SDOPackage::DeviceProfile(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mDeviceProfile,
               _0RL_SDOPackage_mDeviceProfile_marshal_fn,
               _0RL_SDOPackage_mDeviceProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::DeviceProfile* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mDeviceProfile,
               _0RL_SDOPackage_mDeviceProfile_marshal_fn,
               _0RL_SDOPackage_mDeviceProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::DeviceProfile*& _sp)
{
  return _a >>= (const SDOPackage::DeviceProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::DeviceProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mDeviceProfile,
                    _0RL_SDOPackage_mDeviceProfile_unmarshal_fn,
                    _0RL_SDOPackage_mDeviceProfile_marshal_fn,
                    _0RL_SDOPackage_mDeviceProfile_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::DeviceProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mServiceProfile_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::ServiceProfile* _p = (SDOPackage::ServiceProfile*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mServiceProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::ServiceProfile* _p = new SDOPackage::ServiceProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mServiceProfile_destructor_fn(void* _v)
{
  SDOPackage::ServiceProfile* _p = (SDOPackage::ServiceProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::ServiceProfile& _s)
{
  SDOPackage::ServiceProfile* _p = new SDOPackage::ServiceProfile(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mServiceProfile,
               _0RL_SDOPackage_mServiceProfile_marshal_fn,
               _0RL_SDOPackage_mServiceProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::ServiceProfile* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mServiceProfile,
               _0RL_SDOPackage_mServiceProfile_marshal_fn,
               _0RL_SDOPackage_mServiceProfile_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ServiceProfile*& _sp)
{
  return _a >>= (const SDOPackage::ServiceProfile*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ServiceProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mServiceProfile,
                    _0RL_SDOPackage_mServiceProfile_unmarshal_fn,
                    _0RL_SDOPackage_mServiceProfile_marshal_fn,
                    _0RL_SDOPackage_mServiceProfile_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::ServiceProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mServiceProfileList_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::ServiceProfileList* _p = (SDOPackage::ServiceProfileList*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mServiceProfileList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::ServiceProfileList* _p = new SDOPackage::ServiceProfileList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mServiceProfileList_destructor_fn(void* _v)
{
  SDOPackage::ServiceProfileList* _p = (SDOPackage::ServiceProfileList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::ServiceProfileList& _s)
{
  SDOPackage::ServiceProfileList* _p = new SDOPackage::ServiceProfileList(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mServiceProfileList,
               _0RL_SDOPackage_mServiceProfileList_marshal_fn,
               _0RL_SDOPackage_mServiceProfileList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::ServiceProfileList* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mServiceProfileList,
               _0RL_SDOPackage_mServiceProfileList_marshal_fn,
               _0RL_SDOPackage_mServiceProfileList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ServiceProfileList*& _sp)
{
  return _a >>= (const SDOPackage::ServiceProfileList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ServiceProfileList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mServiceProfileList,
                    _0RL_SDOPackage_mServiceProfileList_unmarshal_fn,
                    _0RL_SDOPackage_mServiceProfileList_marshal_fn,
                    _0RL_SDOPackage_mServiceProfileList_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::ServiceProfileList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mConfigurationSet_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::ConfigurationSet* _p = (SDOPackage::ConfigurationSet*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mConfigurationSet_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::ConfigurationSet* _p = new SDOPackage::ConfigurationSet;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mConfigurationSet_destructor_fn(void* _v)
{
  SDOPackage::ConfigurationSet* _p = (SDOPackage::ConfigurationSet*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::ConfigurationSet& _s)
{
  SDOPackage::ConfigurationSet* _p = new SDOPackage::ConfigurationSet(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mConfigurationSet,
               _0RL_SDOPackage_mConfigurationSet_marshal_fn,
               _0RL_SDOPackage_mConfigurationSet_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::ConfigurationSet* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mConfigurationSet,
               _0RL_SDOPackage_mConfigurationSet_marshal_fn,
               _0RL_SDOPackage_mConfigurationSet_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ConfigurationSet*& _sp)
{
  return _a >>= (const SDOPackage::ConfigurationSet*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ConfigurationSet*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mConfigurationSet,
                    _0RL_SDOPackage_mConfigurationSet_unmarshal_fn,
                    _0RL_SDOPackage_mConfigurationSet_marshal_fn,
                    _0RL_SDOPackage_mConfigurationSet_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::ConfigurationSet*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mConfigurationSetList_marshal_fn(cdrStream& _s, void* _v)
{
  SDOPackage::ConfigurationSetList* _p = (SDOPackage::ConfigurationSetList*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mConfigurationSetList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::ConfigurationSetList* _p = new SDOPackage::ConfigurationSetList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mConfigurationSetList_destructor_fn(void* _v)
{
  SDOPackage::ConfigurationSetList* _p = (SDOPackage::ConfigurationSetList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::ConfigurationSetList& _s)
{
  SDOPackage::ConfigurationSetList* _p = new SDOPackage::ConfigurationSetList(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mConfigurationSetList,
               _0RL_SDOPackage_mConfigurationSetList_marshal_fn,
               _0RL_SDOPackage_mConfigurationSetList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SDOPackage::ConfigurationSetList* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mConfigurationSetList,
               _0RL_SDOPackage_mConfigurationSetList_marshal_fn,
               _0RL_SDOPackage_mConfigurationSetList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::ConfigurationSetList*& _sp)
{
  return _a >>= (const SDOPackage::ConfigurationSetList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::ConfigurationSetList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mConfigurationSetList,
                    _0RL_SDOPackage_mConfigurationSetList_unmarshal_fn,
                    _0RL_SDOPackage_mConfigurationSetList_marshal_fn,
                    _0RL_SDOPackage_mConfigurationSetList_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::ConfigurationSetList*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_SDOPackage_mNotAvailable_marshal_fn(cdrStream& _s, void* _v)
{
  const SDOPackage::NotAvailable* _p = (const SDOPackage::NotAvailable*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mNotAvailable_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::NotAvailable* _p = new SDOPackage::NotAvailable;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mNotAvailable_destructor_fn(void* _v)
{
  SDOPackage::NotAvailable* _p = (SDOPackage::NotAvailable*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::NotAvailable& _s)
{
  SDOPackage::NotAvailable* _p = new SDOPackage::NotAvailable(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mNotAvailable,
               _0RL_SDOPackage_mNotAvailable_marshal_fn,
               _0RL_SDOPackage_mNotAvailable_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const SDOPackage::NotAvailable* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mNotAvailable,
               _0RL_SDOPackage_mNotAvailable_marshal_fn,
               _0RL_SDOPackage_mNotAvailable_destructor_fn,
               (SDOPackage::NotAvailable*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::NotAvailable*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mNotAvailable,
                    _0RL_SDOPackage_mNotAvailable_unmarshal_fn,
                    _0RL_SDOPackage_mNotAvailable_marshal_fn,
                    _0RL_SDOPackage_mNotAvailable_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::NotAvailable*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cSDOPackage_mNotAvailable(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const SDOPackage::NotAvailable & _ex = (const SDOPackage::NotAvailable &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cSDOPackage_mNotAvailable (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const SDOPackage::NotAvailable* _ex = (const SDOPackage::NotAvailable*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cSDOPackage_mNotAvailable {
public:
  _0RL_insertToAny_Singleton__cSDOPackage_mNotAvailable() {
    SDOPackage::NotAvailable::insertToAnyFn = _0RL_insertToAny__cSDOPackage_mNotAvailable;
    SDOPackage::NotAvailable::insertToAnyFnNCP = _0RL_insertToAnyNCP__cSDOPackage_mNotAvailable;
  }
};
static _0RL_insertToAny_Singleton__cSDOPackage_mNotAvailable _0RL_insertToAny_Singleton__cSDOPackage_mNotAvailable_;


static void _0RL_SDOPackage_mInterfaceNotImplemented_marshal_fn(cdrStream& _s, void* _v)
{
  const SDOPackage::InterfaceNotImplemented* _p = (const SDOPackage::InterfaceNotImplemented*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mInterfaceNotImplemented_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::InterfaceNotImplemented* _p = new SDOPackage::InterfaceNotImplemented;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mInterfaceNotImplemented_destructor_fn(void* _v)
{
  SDOPackage::InterfaceNotImplemented* _p = (SDOPackage::InterfaceNotImplemented*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::InterfaceNotImplemented& _s)
{
  SDOPackage::InterfaceNotImplemented* _p = new SDOPackage::InterfaceNotImplemented(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mInterfaceNotImplemented,
               _0RL_SDOPackage_mInterfaceNotImplemented_marshal_fn,
               _0RL_SDOPackage_mInterfaceNotImplemented_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const SDOPackage::InterfaceNotImplemented* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mInterfaceNotImplemented,
               _0RL_SDOPackage_mInterfaceNotImplemented_marshal_fn,
               _0RL_SDOPackage_mInterfaceNotImplemented_destructor_fn,
               (SDOPackage::InterfaceNotImplemented*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::InterfaceNotImplemented*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mInterfaceNotImplemented,
                    _0RL_SDOPackage_mInterfaceNotImplemented_unmarshal_fn,
                    _0RL_SDOPackage_mInterfaceNotImplemented_marshal_fn,
                    _0RL_SDOPackage_mInterfaceNotImplemented_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::InterfaceNotImplemented*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cSDOPackage_mInterfaceNotImplemented(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const SDOPackage::InterfaceNotImplemented & _ex = (const SDOPackage::InterfaceNotImplemented &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cSDOPackage_mInterfaceNotImplemented (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const SDOPackage::InterfaceNotImplemented* _ex = (const SDOPackage::InterfaceNotImplemented*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cSDOPackage_mInterfaceNotImplemented {
public:
  _0RL_insertToAny_Singleton__cSDOPackage_mInterfaceNotImplemented() {
    SDOPackage::InterfaceNotImplemented::insertToAnyFn = _0RL_insertToAny__cSDOPackage_mInterfaceNotImplemented;
    SDOPackage::InterfaceNotImplemented::insertToAnyFnNCP = _0RL_insertToAnyNCP__cSDOPackage_mInterfaceNotImplemented;
  }
};
static _0RL_insertToAny_Singleton__cSDOPackage_mInterfaceNotImplemented _0RL_insertToAny_Singleton__cSDOPackage_mInterfaceNotImplemented_;


static void _0RL_SDOPackage_mInvalidParameter_marshal_fn(cdrStream& _s, void* _v)
{
  const SDOPackage::InvalidParameter* _p = (const SDOPackage::InvalidParameter*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mInvalidParameter_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::InvalidParameter* _p = new SDOPackage::InvalidParameter;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mInvalidParameter_destructor_fn(void* _v)
{
  SDOPackage::InvalidParameter* _p = (SDOPackage::InvalidParameter*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::InvalidParameter& _s)
{
  SDOPackage::InvalidParameter* _p = new SDOPackage::InvalidParameter(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mInvalidParameter,
               _0RL_SDOPackage_mInvalidParameter_marshal_fn,
               _0RL_SDOPackage_mInvalidParameter_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const SDOPackage::InvalidParameter* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mInvalidParameter,
               _0RL_SDOPackage_mInvalidParameter_marshal_fn,
               _0RL_SDOPackage_mInvalidParameter_destructor_fn,
               (SDOPackage::InvalidParameter*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::InvalidParameter*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mInvalidParameter,
                    _0RL_SDOPackage_mInvalidParameter_unmarshal_fn,
                    _0RL_SDOPackage_mInvalidParameter_marshal_fn,
                    _0RL_SDOPackage_mInvalidParameter_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::InvalidParameter*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cSDOPackage_mInvalidParameter(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const SDOPackage::InvalidParameter & _ex = (const SDOPackage::InvalidParameter &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cSDOPackage_mInvalidParameter (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const SDOPackage::InvalidParameter* _ex = (const SDOPackage::InvalidParameter*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cSDOPackage_mInvalidParameter {
public:
  _0RL_insertToAny_Singleton__cSDOPackage_mInvalidParameter() {
    SDOPackage::InvalidParameter::insertToAnyFn = _0RL_insertToAny__cSDOPackage_mInvalidParameter;
    SDOPackage::InvalidParameter::insertToAnyFnNCP = _0RL_insertToAnyNCP__cSDOPackage_mInvalidParameter;
  }
};
static _0RL_insertToAny_Singleton__cSDOPackage_mInvalidParameter _0RL_insertToAny_Singleton__cSDOPackage_mInvalidParameter_;


static void _0RL_SDOPackage_mInternalError_marshal_fn(cdrStream& _s, void* _v)
{
  const SDOPackage::InternalError* _p = (const SDOPackage::InternalError*)_v;
  *_p >>= _s;
}
static void _0RL_SDOPackage_mInternalError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SDOPackage::InternalError* _p = new SDOPackage::InternalError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SDOPackage_mInternalError_destructor_fn(void* _v)
{
  SDOPackage::InternalError* _p = (SDOPackage::InternalError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SDOPackage::InternalError& _s)
{
  SDOPackage::InternalError* _p = new SDOPackage::InternalError(_s);
  _a.PR_insert(_0RL_tc_SDOPackage_mInternalError,
               _0RL_SDOPackage_mInternalError_marshal_fn,
               _0RL_SDOPackage_mInternalError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const SDOPackage::InternalError* _sp)
{
  _a.PR_insert(_0RL_tc_SDOPackage_mInternalError,
               _0RL_SDOPackage_mInternalError_marshal_fn,
               _0RL_SDOPackage_mInternalError_destructor_fn,
               (SDOPackage::InternalError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SDOPackage::InternalError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SDOPackage_mInternalError,
                    _0RL_SDOPackage_mInternalError_unmarshal_fn,
                    _0RL_SDOPackage_mInternalError_marshal_fn,
                    _0RL_SDOPackage_mInternalError_destructor_fn,
                    _v)) {
    _sp = (const SDOPackage::InternalError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cSDOPackage_mInternalError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const SDOPackage::InternalError & _ex = (const SDOPackage::InternalError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cSDOPackage_mInternalError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const SDOPackage::InternalError* _ex = (const SDOPackage::InternalError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cSDOPackage_mInternalError {
public:
  _0RL_insertToAny_Singleton__cSDOPackage_mInternalError() {
    SDOPackage::InternalError::insertToAnyFn = _0RL_insertToAny__cSDOPackage_mInternalError;
    SDOPackage::InternalError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cSDOPackage_mInternalError;
  }
};
static _0RL_insertToAny_Singleton__cSDOPackage_mInternalError _0RL_insertToAny_Singleton__cSDOPackage_mInternalError_;

static void _0RL_SDOPackage_mSDOSystemElement_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_SDOPackage_mSDOSystemElement_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(SDOPackage::SDOSystemElement::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_SDOPackage_mSDOSystemElement_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, SDOPackage::SDOSystemElement_ptr _o)
{
  SDOPackage::SDOSystemElement_ptr _no = SDOPackage::SDOSystemElement::_duplicate(_o);
  _a.PR_insert(SDOPackage::_tc_SDOSystemElement,
               _0RL_SDOPackage_mSDOSystemElement_marshal_fn,
               _0RL_SDOPackage_mSDOSystemElement_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, SDOPackage::SDOSystemElement_ptr* _op)
{
  _a.PR_insert(SDOPackage::_tc_SDOSystemElement,
               _0RL_SDOPackage_mSDOSystemElement_marshal_fn,
               _0RL_SDOPackage_mSDOSystemElement_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = SDOPackage::SDOSystemElement::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDOSystemElement_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(SDOPackage::_tc_SDOSystemElement,
                    _0RL_SDOPackage_mSDOSystemElement_unmarshal_fn,
                    _0RL_SDOPackage_mSDOSystemElement_marshal_fn,
                    _0RL_SDOPackage_mSDOSystemElement_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (SDOPackage::SDOSystemElement_ptr)_r->_ptrToObjRef(SDOPackage::SDOSystemElement::_PD_repoId);
    else
      _o = SDOPackage::SDOSystemElement::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mSDO_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_SDOPackage_mSDO_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(SDOPackage::SDO::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_SDOPackage_mSDO_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, SDOPackage::SDO_ptr _o)
{
  SDOPackage::SDO_ptr _no = SDOPackage::SDO::_duplicate(_o);
  _a.PR_insert(SDOPackage::_tc_SDO,
               _0RL_SDOPackage_mSDO_marshal_fn,
               _0RL_SDOPackage_mSDO_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, SDOPackage::SDO_ptr* _op)
{
  _a.PR_insert(SDOPackage::_tc_SDO,
               _0RL_SDOPackage_mSDO_marshal_fn,
               _0RL_SDOPackage_mSDO_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = SDOPackage::SDO::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDO_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(SDOPackage::_tc_SDO,
                    _0RL_SDOPackage_mSDO_unmarshal_fn,
                    _0RL_SDOPackage_mSDO_marshal_fn,
                    _0RL_SDOPackage_mSDO_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (SDOPackage::SDO_ptr)_r->_ptrToObjRef(SDOPackage::SDO::_PD_repoId);
    else
      _o = SDOPackage::SDO::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mConfiguration_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_SDOPackage_mConfiguration_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(SDOPackage::Configuration::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_SDOPackage_mConfiguration_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, SDOPackage::Configuration_ptr _o)
{
  SDOPackage::Configuration_ptr _no = SDOPackage::Configuration::_duplicate(_o);
  _a.PR_insert(SDOPackage::_tc_Configuration,
               _0RL_SDOPackage_mConfiguration_marshal_fn,
               _0RL_SDOPackage_mConfiguration_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, SDOPackage::Configuration_ptr* _op)
{
  _a.PR_insert(SDOPackage::_tc_Configuration,
               _0RL_SDOPackage_mConfiguration_marshal_fn,
               _0RL_SDOPackage_mConfiguration_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = SDOPackage::Configuration::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Configuration_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(SDOPackage::_tc_Configuration,
                    _0RL_SDOPackage_mConfiguration_unmarshal_fn,
                    _0RL_SDOPackage_mConfiguration_marshal_fn,
                    _0RL_SDOPackage_mConfiguration_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (SDOPackage::Configuration_ptr)_r->_ptrToObjRef(SDOPackage::Configuration::_PD_repoId);
    else
      _o = SDOPackage::Configuration::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mMonitoring_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_SDOPackage_mMonitoring_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(SDOPackage::Monitoring::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_SDOPackage_mMonitoring_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, SDOPackage::Monitoring_ptr _o)
{
  SDOPackage::Monitoring_ptr _no = SDOPackage::Monitoring::_duplicate(_o);
  _a.PR_insert(SDOPackage::_tc_Monitoring,
               _0RL_SDOPackage_mMonitoring_marshal_fn,
               _0RL_SDOPackage_mMonitoring_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, SDOPackage::Monitoring_ptr* _op)
{
  _a.PR_insert(SDOPackage::_tc_Monitoring,
               _0RL_SDOPackage_mMonitoring_marshal_fn,
               _0RL_SDOPackage_mMonitoring_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = SDOPackage::Monitoring::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Monitoring_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(SDOPackage::_tc_Monitoring,
                    _0RL_SDOPackage_mMonitoring_unmarshal_fn,
                    _0RL_SDOPackage_mMonitoring_marshal_fn,
                    _0RL_SDOPackage_mMonitoring_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (SDOPackage::Monitoring_ptr)_r->_ptrToObjRef(SDOPackage::Monitoring::_PD_repoId);
    else
      _o = SDOPackage::Monitoring::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mSDOService_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_SDOPackage_mSDOService_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(SDOPackage::SDOService::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_SDOPackage_mSDOService_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, SDOPackage::SDOService_ptr _o)
{
  SDOPackage::SDOService_ptr _no = SDOPackage::SDOService::_duplicate(_o);
  _a.PR_insert(SDOPackage::_tc_SDOService,
               _0RL_SDOPackage_mSDOService_marshal_fn,
               _0RL_SDOPackage_mSDOService_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, SDOPackage::SDOService_ptr* _op)
{
  _a.PR_insert(SDOPackage::_tc_SDOService,
               _0RL_SDOPackage_mSDOService_marshal_fn,
               _0RL_SDOPackage_mSDOService_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = SDOPackage::SDOService::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::SDOService_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(SDOPackage::_tc_SDOService,
                    _0RL_SDOPackage_mSDOService_unmarshal_fn,
                    _0RL_SDOPackage_mSDOService_marshal_fn,
                    _0RL_SDOPackage_mSDOService_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (SDOPackage::SDOService_ptr)_r->_ptrToObjRef(SDOPackage::SDOService::_PD_repoId);
    else
      _o = SDOPackage::SDOService::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_SDOPackage_mOrganization_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_SDOPackage_mOrganization_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(SDOPackage::Organization::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_SDOPackage_mOrganization_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, SDOPackage::Organization_ptr _o)
{
  SDOPackage::Organization_ptr _no = SDOPackage::Organization::_duplicate(_o);
  _a.PR_insert(SDOPackage::_tc_Organization,
               _0RL_SDOPackage_mOrganization_marshal_fn,
               _0RL_SDOPackage_mOrganization_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, SDOPackage::Organization_ptr* _op)
{
  _a.PR_insert(SDOPackage::_tc_Organization,
               _0RL_SDOPackage_mOrganization_marshal_fn,
               _0RL_SDOPackage_mOrganization_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = SDOPackage::Organization::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SDOPackage::Organization_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(SDOPackage::_tc_Organization,
                    _0RL_SDOPackage_mOrganization_unmarshal_fn,
                    _0RL_SDOPackage_mOrganization_marshal_fn,
                    _0RL_SDOPackage_mOrganization_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (SDOPackage::Organization_ptr)_r->_ptrToObjRef(SDOPackage::Organization::_PD_repoId);
    else
      _o = SDOPackage::Organization::_nil();
    return 1;
  }
  return 0;
}

