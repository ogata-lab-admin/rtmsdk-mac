// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __InterfaceDataTypes_hh__
#define __InterfaceDataTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
#endif



#ifndef __BasicDataType_hh_EXTERNAL_GUARD__
#define __BasicDataType_hh_EXTERNAL_GUARD__
#include <BasicDataType.hh>
#endif
#ifndef __ExtendedDataTypes_hh_EXTERNAL_GUARD__
#define __ExtendedDataTypes_hh_EXTERNAL_GUARD__
#include <ExtendedDataTypes.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE RTC

_CORBA_MODULE_BEG

  struct ActArrayActuatorPos {
    typedef _CORBA_ConstrType_Fix_Var<ActArrayActuatorPos> _var_type;

    
    Time tm;

    ::CORBA::UShort index;

    ::CORBA::Double position;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActArrayActuatorPos::_var_type ActArrayActuatorPos_var;

  typedef ActArrayActuatorPos& ActArrayActuatorPos_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorPos;

  struct ActArrayActuatorSpeed {
    typedef _CORBA_ConstrType_Fix_Var<ActArrayActuatorSpeed> _var_type;

    
    Time tm;

    ::CORBA::UShort index;

    ::CORBA::Double speed;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActArrayActuatorSpeed::_var_type ActArrayActuatorSpeed_var;

  typedef ActArrayActuatorSpeed& ActArrayActuatorSpeed_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorSpeed;

  struct ActArrayActuatorCurrent {
    typedef _CORBA_ConstrType_Fix_Var<ActArrayActuatorCurrent> _var_type;

    
    Time tm;

    ::CORBA::UShort index;

    ::CORBA::Double current;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActArrayActuatorCurrent::_var_type ActArrayActuatorCurrent_var;

  typedef ActArrayActuatorCurrent& ActArrayActuatorCurrent_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorCurrent;

  enum ActArrayActuatorStatus { ACTUATOR_STATUS_IDLE, ACTUATOR_STATUS_MOVING, ACTUATOR_STATUS_BRAKED, ACTUATOR_STATUS_STALLED /*, __max_ActArrayActuatorStatus=0xffffffff */ };
  typedef ActArrayActuatorStatus& ActArrayActuatorStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorStatus;

  struct Actuator {
    typedef _CORBA_ConstrType_Fix_Var<Actuator> _var_type;

    
    ::CORBA::Double position;

    ::CORBA::Double speed;

    ::CORBA::Double accel;

    ::CORBA::Double current;

    ActArrayActuatorStatus status;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Actuator::_var_type Actuator_var;

  typedef Actuator& Actuator_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Actuator;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActuatorList;

  class ActuatorList_var;

  class ActuatorList : public _CORBA_Unbounded_Sequence< Actuator >  {
  public:
    typedef ActuatorList_var _var_type;
    inline ActuatorList() {}
    inline ActuatorList(const ActuatorList& _s)
      : _CORBA_Unbounded_Sequence< Actuator > (_s) {}

    inline ActuatorList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Actuator > (_max) {}
    inline ActuatorList(_CORBA_ULong _max, _CORBA_ULong _len, Actuator* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Actuator > (_max, _len, _val, _rel) {}

  

    inline ActuatorList& operator = (const ActuatorList& _s) {
      _CORBA_Unbounded_Sequence< Actuator > ::operator=(_s);
      return *this;
    }
  };

  class ActuatorList_out;

  class ActuatorList_var {
  public:
    inline ActuatorList_var() : _pd_seq(0) {}
    inline ActuatorList_var(ActuatorList* _s) : _pd_seq(_s) {}
    inline ActuatorList_var(const ActuatorList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ActuatorList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ActuatorList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ActuatorList_var& operator = (ActuatorList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ActuatorList_var& operator = (const ActuatorList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ActuatorList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Actuator& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ActuatorList* operator -> () { return _pd_seq; }
    inline const ActuatorList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ActuatorList& () const { return *_pd_seq; }
#else
    inline operator const ActuatorList& () const { return *_pd_seq; }
    inline operator ActuatorList& () { return *_pd_seq; }
#endif
      
    inline const ActuatorList& in() const { return *_pd_seq; }
    inline ActuatorList&       inout()    { return *_pd_seq; }
    inline ActuatorList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ActuatorList* _retn() { ActuatorList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ActuatorList_out;
    
  private:
    ActuatorList* _pd_seq;
  };

  class ActuatorList_out {
  public:
    inline ActuatorList_out(ActuatorList*& _s) : _data(_s) { _data = 0; }
    inline ActuatorList_out(ActuatorList_var& _s)
      : _data(_s._pd_seq) { _s = (ActuatorList*) 0; }
    inline ActuatorList_out(const ActuatorList_out& _s) : _data(_s._data) {}
    inline ActuatorList_out& operator = (const ActuatorList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ActuatorList_out& operator = (ActuatorList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ActuatorList*&()  { return _data; }
    inline ActuatorList*& ptr()       { return _data; }
    inline ActuatorList* operator->() { return _data; }

    inline Actuator& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ActuatorList*& _data;

  private:
    ActuatorList_out();
    ActuatorList_out& operator=(const ActuatorList_var&);
  };

  struct ActArrayState {
    typedef _CORBA_ConstrType_Variable_Var<ActArrayState> _var_type;

    
    Time tm;

    ActuatorList actuators;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActArrayState::_var_type ActArrayState_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ActArrayState,ActArrayState_var > ActArrayState_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayState;

  enum ActArrayActuatorType { ACTARRAY_ACTUATORTYPE_LINEAR, ACTARRAY_ACTUATORTYPE_ROTARY /*, __max_ActArrayActuatorType=0xffffffff */ };
  typedef ActArrayActuatorType& ActArrayActuatorType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorType;

  struct ActArrayActuatorGeometry {
    typedef _CORBA_ConstrType_Fix_Var<ActArrayActuatorGeometry> _var_type;

    
    ActArrayActuatorType type;

    ::CORBA::Double length;

    Orientation3D orientation;

    Vector3D axis;

    ::CORBA::Double minRange;

    ::CORBA::Double centre;

    ::CORBA::Double maxRange;

    ::CORBA::Double homePosition;

    ::CORBA::Boolean hasBrakes;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActArrayActuatorGeometry::_var_type ActArrayActuatorGeometry_var;

  typedef ActArrayActuatorGeometry& ActArrayActuatorGeometry_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorGeometry;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayActuatorGeometryList;

  class ActArrayActuatorGeometryList_var;

  class ActArrayActuatorGeometryList : public _CORBA_Unbounded_Sequence< ActArrayActuatorGeometry >  {
  public:
    typedef ActArrayActuatorGeometryList_var _var_type;
    inline ActArrayActuatorGeometryList() {}
    inline ActArrayActuatorGeometryList(const ActArrayActuatorGeometryList& _s)
      : _CORBA_Unbounded_Sequence< ActArrayActuatorGeometry > (_s) {}

    inline ActArrayActuatorGeometryList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ActArrayActuatorGeometry > (_max) {}
    inline ActArrayActuatorGeometryList(_CORBA_ULong _max, _CORBA_ULong _len, ActArrayActuatorGeometry* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ActArrayActuatorGeometry > (_max, _len, _val, _rel) {}

  

    inline ActArrayActuatorGeometryList& operator = (const ActArrayActuatorGeometryList& _s) {
      _CORBA_Unbounded_Sequence< ActArrayActuatorGeometry > ::operator=(_s);
      return *this;
    }
  };

  class ActArrayActuatorGeometryList_out;

  class ActArrayActuatorGeometryList_var {
  public:
    inline ActArrayActuatorGeometryList_var() : _pd_seq(0) {}
    inline ActArrayActuatorGeometryList_var(ActArrayActuatorGeometryList* _s) : _pd_seq(_s) {}
    inline ActArrayActuatorGeometryList_var(const ActArrayActuatorGeometryList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ActArrayActuatorGeometryList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ActArrayActuatorGeometryList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ActArrayActuatorGeometryList_var& operator = (ActArrayActuatorGeometryList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ActArrayActuatorGeometryList_var& operator = (const ActArrayActuatorGeometryList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ActArrayActuatorGeometryList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ActArrayActuatorGeometry& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ActArrayActuatorGeometryList* operator -> () { return _pd_seq; }
    inline const ActArrayActuatorGeometryList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ActArrayActuatorGeometryList& () const { return *_pd_seq; }
#else
    inline operator const ActArrayActuatorGeometryList& () const { return *_pd_seq; }
    inline operator ActArrayActuatorGeometryList& () { return *_pd_seq; }
#endif
      
    inline const ActArrayActuatorGeometryList& in() const { return *_pd_seq; }
    inline ActArrayActuatorGeometryList&       inout()    { return *_pd_seq; }
    inline ActArrayActuatorGeometryList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ActArrayActuatorGeometryList* _retn() { ActArrayActuatorGeometryList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ActArrayActuatorGeometryList_out;
    
  private:
    ActArrayActuatorGeometryList* _pd_seq;
  };

  class ActArrayActuatorGeometryList_out {
  public:
    inline ActArrayActuatorGeometryList_out(ActArrayActuatorGeometryList*& _s) : _data(_s) { _data = 0; }
    inline ActArrayActuatorGeometryList_out(ActArrayActuatorGeometryList_var& _s)
      : _data(_s._pd_seq) { _s = (ActArrayActuatorGeometryList*) 0; }
    inline ActArrayActuatorGeometryList_out(const ActArrayActuatorGeometryList_out& _s) : _data(_s._data) {}
    inline ActArrayActuatorGeometryList_out& operator = (const ActArrayActuatorGeometryList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ActArrayActuatorGeometryList_out& operator = (ActArrayActuatorGeometryList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ActArrayActuatorGeometryList*&()  { return _data; }
    inline ActArrayActuatorGeometryList*& ptr()       { return _data; }
    inline ActArrayActuatorGeometryList* operator->() { return _data; }

    inline ActArrayActuatorGeometry& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ActArrayActuatorGeometryList*& _data;

  private:
    ActArrayActuatorGeometryList_out();
    ActArrayActuatorGeometryList_out& operator=(const ActArrayActuatorGeometryList_var&);
  };

  struct ActArrayGeometry {
    typedef _CORBA_ConstrType_Variable_Var<ActArrayGeometry> _var_type;

    
    Geometry3D arrayGeometry;

    ActArrayActuatorGeometryList actuatorGeometry;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActArrayGeometry::_var_type ActArrayGeometry_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ActArrayGeometry,ActArrayGeometry_var > ActArrayGeometry_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActArrayGeometry;

  struct BumperGeometry {
    typedef _CORBA_ConstrType_Fix_Var<BumperGeometry> _var_type;

    
    Pose3D pose;

    Size3D size;

    ::CORBA::Double roc;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef BumperGeometry::_var_type BumperGeometry_var;

  typedef BumperGeometry& BumperGeometry_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BumperGeometry;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BumperGeometryList;

  class BumperGeometryList_var;

  class BumperGeometryList : public _CORBA_Unbounded_Sequence< BumperGeometry >  {
  public:
    typedef BumperGeometryList_var _var_type;
    inline BumperGeometryList() {}
    inline BumperGeometryList(const BumperGeometryList& _s)
      : _CORBA_Unbounded_Sequence< BumperGeometry > (_s) {}

    inline BumperGeometryList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< BumperGeometry > (_max) {}
    inline BumperGeometryList(_CORBA_ULong _max, _CORBA_ULong _len, BumperGeometry* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< BumperGeometry > (_max, _len, _val, _rel) {}

  

    inline BumperGeometryList& operator = (const BumperGeometryList& _s) {
      _CORBA_Unbounded_Sequence< BumperGeometry > ::operator=(_s);
      return *this;
    }
  };

  class BumperGeometryList_out;

  class BumperGeometryList_var {
  public:
    inline BumperGeometryList_var() : _pd_seq(0) {}
    inline BumperGeometryList_var(BumperGeometryList* _s) : _pd_seq(_s) {}
    inline BumperGeometryList_var(const BumperGeometryList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new BumperGeometryList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~BumperGeometryList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline BumperGeometryList_var& operator = (BumperGeometryList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline BumperGeometryList_var& operator = (const BumperGeometryList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new BumperGeometryList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline BumperGeometry& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline BumperGeometryList* operator -> () { return _pd_seq; }
    inline const BumperGeometryList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator BumperGeometryList& () const { return *_pd_seq; }
#else
    inline operator const BumperGeometryList& () const { return *_pd_seq; }
    inline operator BumperGeometryList& () { return *_pd_seq; }
#endif
      
    inline const BumperGeometryList& in() const { return *_pd_seq; }
    inline BumperGeometryList&       inout()    { return *_pd_seq; }
    inline BumperGeometryList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline BumperGeometryList* _retn() { BumperGeometryList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class BumperGeometryList_out;
    
  private:
    BumperGeometryList* _pd_seq;
  };

  class BumperGeometryList_out {
  public:
    inline BumperGeometryList_out(BumperGeometryList*& _s) : _data(_s) { _data = 0; }
    inline BumperGeometryList_out(BumperGeometryList_var& _s)
      : _data(_s._pd_seq) { _s = (BumperGeometryList*) 0; }
    inline BumperGeometryList_out(const BumperGeometryList_out& _s) : _data(_s._data) {}
    inline BumperGeometryList_out& operator = (const BumperGeometryList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline BumperGeometryList_out& operator = (BumperGeometryList* _s) {
      _data = _s;
      return *this;
    }
    inline operator BumperGeometryList*&()  { return _data; }
    inline BumperGeometryList*& ptr()       { return _data; }
    inline BumperGeometryList* operator->() { return _data; }

    inline BumperGeometry& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    BumperGeometryList*& _data;

  private:
    BumperGeometryList_out();
    BumperGeometryList_out& operator=(const BumperGeometryList_var&);
  };

  struct BumperArrayGeometry {
    typedef _CORBA_ConstrType_Variable_Var<BumperArrayGeometry> _var_type;

    
    Geometry3D arrayGeometry;

    BumperGeometryList bumperGeometry;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef BumperArrayGeometry::_var_type BumperArrayGeometry_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< BumperArrayGeometry,BumperArrayGeometry_var > BumperArrayGeometry_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BumperArrayGeometry;

  struct CameraImage {
    typedef _CORBA_ConstrType_Variable_Var<CameraImage> _var_type;

    
    Time tm;

    ::CORBA::UShort width;

    ::CORBA::UShort height;

    ::CORBA::UShort bpp;

    ::CORBA::String_member format;

    ::CORBA::Double fDiv;

    typedef _CORBA_Unbounded_Sequence_Octet _pixels_seq;
    _pixels_seq pixels;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef CameraImage::_var_type CameraImage_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< CameraImage,CameraImage_var > CameraImage_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CameraImage;

  struct CameraInfo {
    typedef _CORBA_ConstrType_Fix_Var<CameraInfo> _var_type;

    
    Vector2D focalLength;

    Point2D principalPoint;

    ::CORBA::Double k1;

    ::CORBA::Double k2;

    ::CORBA::Double p1;

    ::CORBA::Double p2;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef CameraInfo::_var_type CameraInfo_var;

  typedef CameraInfo& CameraInfo_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CameraInfo;

  struct FiducialInfo {
    typedef _CORBA_ConstrType_Fix_Var<FiducialInfo> _var_type;

    
    ::CORBA::ULong id;

    Pose3D pose;

    Pose3D poseUncertainty;

    Size3D size;

    Size3D sizeUncertainty;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FiducialInfo::_var_type FiducialInfo_var;

  typedef FiducialInfo& FiducialInfo_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FiducialInfo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FiducialInfoList;

  class FiducialInfoList_var;

  class FiducialInfoList : public _CORBA_Unbounded_Sequence< FiducialInfo >  {
  public:
    typedef FiducialInfoList_var _var_type;
    inline FiducialInfoList() {}
    inline FiducialInfoList(const FiducialInfoList& _s)
      : _CORBA_Unbounded_Sequence< FiducialInfo > (_s) {}

    inline FiducialInfoList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< FiducialInfo > (_max) {}
    inline FiducialInfoList(_CORBA_ULong _max, _CORBA_ULong _len, FiducialInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< FiducialInfo > (_max, _len, _val, _rel) {}

  

    inline FiducialInfoList& operator = (const FiducialInfoList& _s) {
      _CORBA_Unbounded_Sequence< FiducialInfo > ::operator=(_s);
      return *this;
    }
  };

  class FiducialInfoList_out;

  class FiducialInfoList_var {
  public:
    inline FiducialInfoList_var() : _pd_seq(0) {}
    inline FiducialInfoList_var(FiducialInfoList* _s) : _pd_seq(_s) {}
    inline FiducialInfoList_var(const FiducialInfoList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new FiducialInfoList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~FiducialInfoList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline FiducialInfoList_var& operator = (FiducialInfoList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FiducialInfoList_var& operator = (const FiducialInfoList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new FiducialInfoList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline FiducialInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FiducialInfoList* operator -> () { return _pd_seq; }
    inline const FiducialInfoList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FiducialInfoList& () const { return *_pd_seq; }
#else
    inline operator const FiducialInfoList& () const { return *_pd_seq; }
    inline operator FiducialInfoList& () { return *_pd_seq; }
#endif
      
    inline const FiducialInfoList& in() const { return *_pd_seq; }
    inline FiducialInfoList&       inout()    { return *_pd_seq; }
    inline FiducialInfoList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FiducialInfoList* _retn() { FiducialInfoList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FiducialInfoList_out;
    
  private:
    FiducialInfoList* _pd_seq;
  };

  class FiducialInfoList_out {
  public:
    inline FiducialInfoList_out(FiducialInfoList*& _s) : _data(_s) { _data = 0; }
    inline FiducialInfoList_out(FiducialInfoList_var& _s)
      : _data(_s._pd_seq) { _s = (FiducialInfoList*) 0; }
    inline FiducialInfoList_out(const FiducialInfoList_out& _s) : _data(_s._data) {}
    inline FiducialInfoList_out& operator = (const FiducialInfoList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FiducialInfoList_out& operator = (FiducialInfoList* _s) {
      _data = _s;
      return *this;
    }
    inline operator FiducialInfoList*&()  { return _data; }
    inline FiducialInfoList*& ptr()       { return _data; }
    inline FiducialInfoList* operator->() { return _data; }

    inline FiducialInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FiducialInfoList*& _data;

  private:
    FiducialInfoList_out();
    FiducialInfoList_out& operator=(const FiducialInfoList_var&);
  };

  struct Fiducials {
    typedef _CORBA_ConstrType_Variable_Var<Fiducials> _var_type;

    
    Time tm;

    FiducialInfoList fiducialsList;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Fiducials::_var_type Fiducials_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Fiducials,Fiducials_var > Fiducials_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Fiducials;

  struct FiducialFOV {
    typedef _CORBA_ConstrType_Fix_Var<FiducialFOV> _var_type;

    
    ::CORBA::Double minRange;

    ::CORBA::Double maxRange;

    ::CORBA::Double viewAngle;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FiducialFOV::_var_type FiducialFOV_var;

  typedef FiducialFOV& FiducialFOV_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FiducialFOV;

  struct GPSTime {
    typedef _CORBA_ConstrType_Fix_Var<GPSTime> _var_type;

    
    ::CORBA::ULong sec;

    ::CORBA::ULong msec;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef GPSTime::_var_type GPSTime_var;

  typedef GPSTime& GPSTime_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_GPSTime;

  enum GPSFixType { GPS_FIX_NONE, GPS_FIX_NORMAL, GPS_FIX_DGPS /*, __max_GPSFixType=0xffffffff */ };
  typedef GPSFixType& GPSFixType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_GPSFixType;

  struct GPSData {
    typedef _CORBA_ConstrType_Fix_Var<GPSData> _var_type;

    
    Time tm;

    GPSTime timeFromGPS;

    ::CORBA::Double latitude;

    ::CORBA::Double longitude;

    ::CORBA::Double altitude;

    ::CORBA::Double horizontalError;

    ::CORBA::Double verticalError;

    ::CORBA::Double heading;

    ::CORBA::Double horizontalSpeed;

    ::CORBA::Double verticalSpeed;

    ::CORBA::UShort numSatellites;

    GPSFixType fixType;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef GPSData::_var_type GPSData_var;

  typedef GPSData& GPSData_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_GPSData;

  enum GripperStatus { GRIPPER_STATE_OPEN, GRIPPER_STATE_CLOSED, GRIPPER_STATE_MOVING, GRIPPER_STATE_UNKNOWN /*, __max_GripperStatus=0xffffffff */ };
  typedef GripperStatus& GripperStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_GripperStatus;

  struct GripperState {
    typedef _CORBA_ConstrType_Fix_Var<GripperState> _var_type;

    
    Time tm;

    GripperStatus status;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef GripperState::_var_type GripperState_var;

  typedef GripperState& GripperState_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_GripperState;

  struct GripperGeometry {
    typedef _CORBA_ConstrType_Fix_Var<GripperGeometry> _var_type;

    
    Geometry3D exterior;

    Geometry3D interior;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef GripperGeometry::_var_type GripperGeometry_var;

  typedef GripperGeometry& GripperGeometry_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_GripperGeometry;

  struct INSData {
    typedef _CORBA_ConstrType_Fix_Var<INSData> _var_type;

    
    Time tm;

    ::CORBA::Double latitude;

    ::CORBA::Double longitude;

    ::CORBA::Double altitude;

    ::CORBA::Double heightAMSL;

    Velocity3D velocityENU;

    Orientation3D orientation;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef INSData::_var_type INSData_var;

  typedef INSData& INSData_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_INSData;

  enum LimbStatus { LIMB_STATUS_IDLE, LIMB_STATUS_BRAKED, LIMB_STATUS_MOVING, LIMB_STATUS_OOR, LIMB_STATUS_COLLISION /*, __max_LimbStatus=0xffffffff */ };
  typedef LimbStatus& LimbStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LimbStatus;

  struct LimbState {
    typedef _CORBA_ConstrType_Fix_Var<LimbState> _var_type;

    
    Time tm;

    OAP oapMatrix;

    LimbStatus status;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LimbState::_var_type LimbState_var;

  typedef LimbState& LimbState_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LimbState;

  struct Hypothesis2D {
    typedef _CORBA_ConstrType_Fix_Var<Hypothesis2D> _var_type;

    
    Pose2D mean;

    Covariance2D covariance;

    ::CORBA::Double weight;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Hypothesis2D::_var_type Hypothesis2D_var;

  typedef Hypothesis2D& Hypothesis2D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Hypothesis2D;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Hypothesis2DList;

  class Hypothesis2DList_var;

  class Hypothesis2DList : public _CORBA_Unbounded_Sequence< Hypothesis2D >  {
  public:
    typedef Hypothesis2DList_var _var_type;
    inline Hypothesis2DList() {}
    inline Hypothesis2DList(const Hypothesis2DList& _s)
      : _CORBA_Unbounded_Sequence< Hypothesis2D > (_s) {}

    inline Hypothesis2DList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Hypothesis2D > (_max) {}
    inline Hypothesis2DList(_CORBA_ULong _max, _CORBA_ULong _len, Hypothesis2D* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Hypothesis2D > (_max, _len, _val, _rel) {}

  

    inline Hypothesis2DList& operator = (const Hypothesis2DList& _s) {
      _CORBA_Unbounded_Sequence< Hypothesis2D > ::operator=(_s);
      return *this;
    }
  };

  class Hypothesis2DList_out;

  class Hypothesis2DList_var {
  public:
    inline Hypothesis2DList_var() : _pd_seq(0) {}
    inline Hypothesis2DList_var(Hypothesis2DList* _s) : _pd_seq(_s) {}
    inline Hypothesis2DList_var(const Hypothesis2DList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Hypothesis2DList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Hypothesis2DList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Hypothesis2DList_var& operator = (Hypothesis2DList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Hypothesis2DList_var& operator = (const Hypothesis2DList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Hypothesis2DList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Hypothesis2D& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Hypothesis2DList* operator -> () { return _pd_seq; }
    inline const Hypothesis2DList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Hypothesis2DList& () const { return *_pd_seq; }
#else
    inline operator const Hypothesis2DList& () const { return *_pd_seq; }
    inline operator Hypothesis2DList& () { return *_pd_seq; }
#endif
      
    inline const Hypothesis2DList& in() const { return *_pd_seq; }
    inline Hypothesis2DList&       inout()    { return *_pd_seq; }
    inline Hypothesis2DList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Hypothesis2DList* _retn() { Hypothesis2DList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Hypothesis2DList_out;
    
  private:
    Hypothesis2DList* _pd_seq;
  };

  class Hypothesis2DList_out {
  public:
    inline Hypothesis2DList_out(Hypothesis2DList*& _s) : _data(_s) { _data = 0; }
    inline Hypothesis2DList_out(Hypothesis2DList_var& _s)
      : _data(_s._pd_seq) { _s = (Hypothesis2DList*) 0; }
    inline Hypothesis2DList_out(const Hypothesis2DList_out& _s) : _data(_s._data) {}
    inline Hypothesis2DList_out& operator = (const Hypothesis2DList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Hypothesis2DList_out& operator = (Hypothesis2DList* _s) {
      _data = _s;
      return *this;
    }
    inline operator Hypothesis2DList*&()  { return _data; }
    inline Hypothesis2DList*& ptr()       { return _data; }
    inline Hypothesis2DList* operator->() { return _data; }

    inline Hypothesis2D& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Hypothesis2DList*& _data;

  private:
    Hypothesis2DList_out();
    Hypothesis2DList_out& operator=(const Hypothesis2DList_var&);
  };

  struct Hypotheses2D {
    typedef _CORBA_ConstrType_Variable_Var<Hypotheses2D> _var_type;

    
    Time tm;

    Hypothesis2DList hypotheses;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Hypotheses2D::_var_type Hypotheses2D_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Hypotheses2D,Hypotheses2D_var > Hypotheses2D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Hypotheses2D;

  struct Hypothesis3D {
    typedef _CORBA_ConstrType_Fix_Var<Hypothesis3D> _var_type;

    
    Pose3D mean;

    Covariance3D covariance;

    ::CORBA::Double weight;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Hypothesis3D::_var_type Hypothesis3D_var;

  typedef Hypothesis3D& Hypothesis3D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Hypothesis3D;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Hypothesis3DList;

  class Hypothesis3DList_var;

  class Hypothesis3DList : public _CORBA_Unbounded_Sequence< Hypothesis3D >  {
  public:
    typedef Hypothesis3DList_var _var_type;
    inline Hypothesis3DList() {}
    inline Hypothesis3DList(const Hypothesis3DList& _s)
      : _CORBA_Unbounded_Sequence< Hypothesis3D > (_s) {}

    inline Hypothesis3DList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Hypothesis3D > (_max) {}
    inline Hypothesis3DList(_CORBA_ULong _max, _CORBA_ULong _len, Hypothesis3D* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Hypothesis3D > (_max, _len, _val, _rel) {}

  

    inline Hypothesis3DList& operator = (const Hypothesis3DList& _s) {
      _CORBA_Unbounded_Sequence< Hypothesis3D > ::operator=(_s);
      return *this;
    }
  };

  class Hypothesis3DList_out;

  class Hypothesis3DList_var {
  public:
    inline Hypothesis3DList_var() : _pd_seq(0) {}
    inline Hypothesis3DList_var(Hypothesis3DList* _s) : _pd_seq(_s) {}
    inline Hypothesis3DList_var(const Hypothesis3DList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Hypothesis3DList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Hypothesis3DList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Hypothesis3DList_var& operator = (Hypothesis3DList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Hypothesis3DList_var& operator = (const Hypothesis3DList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Hypothesis3DList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Hypothesis3D& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Hypothesis3DList* operator -> () { return _pd_seq; }
    inline const Hypothesis3DList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Hypothesis3DList& () const { return *_pd_seq; }
#else
    inline operator const Hypothesis3DList& () const { return *_pd_seq; }
    inline operator Hypothesis3DList& () { return *_pd_seq; }
#endif
      
    inline const Hypothesis3DList& in() const { return *_pd_seq; }
    inline Hypothesis3DList&       inout()    { return *_pd_seq; }
    inline Hypothesis3DList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Hypothesis3DList* _retn() { Hypothesis3DList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Hypothesis3DList_out;
    
  private:
    Hypothesis3DList* _pd_seq;
  };

  class Hypothesis3DList_out {
  public:
    inline Hypothesis3DList_out(Hypothesis3DList*& _s) : _data(_s) { _data = 0; }
    inline Hypothesis3DList_out(Hypothesis3DList_var& _s)
      : _data(_s._pd_seq) { _s = (Hypothesis3DList*) 0; }
    inline Hypothesis3DList_out(const Hypothesis3DList_out& _s) : _data(_s._data) {}
    inline Hypothesis3DList_out& operator = (const Hypothesis3DList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Hypothesis3DList_out& operator = (Hypothesis3DList* _s) {
      _data = _s;
      return *this;
    }
    inline operator Hypothesis3DList*&()  { return _data; }
    inline Hypothesis3DList*& ptr()       { return _data; }
    inline Hypothesis3DList* operator->() { return _data; }

    inline Hypothesis3D& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Hypothesis3DList*& _data;

  private:
    Hypothesis3DList_out();
    Hypothesis3DList_out& operator=(const Hypothesis3DList_var&);
  };

  struct Hypotheses3D {
    typedef _CORBA_ConstrType_Variable_Var<Hypotheses3D> _var_type;

    
    Time tm;

    Hypothesis3DList hypotheses;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Hypotheses3D::_var_type Hypotheses3D_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Hypotheses3D,Hypotheses3D_var > Hypotheses3D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Hypotheses3D;

  struct OGMapConfig {
    typedef _CORBA_ConstrType_Fix_Var<OGMapConfig> _var_type;

    
    ::CORBA::Double xScale;

    ::CORBA::Double yScale;

    ::CORBA::ULong width;

    ::CORBA::ULong height;

    Pose2D origin;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef OGMapConfig::_var_type OGMapConfig_var;

  typedef OGMapConfig& OGMapConfig_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OGMapConfig;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OGMapCells;

  class OGMapCells_var;

  class OGMapCells : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef OGMapCells_var _var_type;
    inline OGMapCells() {}
    inline OGMapCells(const OGMapCells& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline OGMapCells(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline OGMapCells(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline OGMapCells& operator = (const OGMapCells& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class OGMapCells_out;

  class OGMapCells_var {
  public:
    inline OGMapCells_var() : _pd_seq(0) {}
    inline OGMapCells_var(OGMapCells* _s) : _pd_seq(_s) {}
    inline OGMapCells_var(const OGMapCells_var& _s) {
      if( _s._pd_seq )  _pd_seq = new OGMapCells(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~OGMapCells_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline OGMapCells_var& operator = (OGMapCells* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline OGMapCells_var& operator = (const OGMapCells_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new OGMapCells;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline OGMapCells* operator -> () { return _pd_seq; }
    inline const OGMapCells* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator OGMapCells& () const { return *_pd_seq; }
#else
    inline operator const OGMapCells& () const { return *_pd_seq; }
    inline operator OGMapCells& () { return *_pd_seq; }
#endif
      
    inline const OGMapCells& in() const { return *_pd_seq; }
    inline OGMapCells&       inout()    { return *_pd_seq; }
    inline OGMapCells*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline OGMapCells* _retn() { OGMapCells* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class OGMapCells_out;
    
  private:
    OGMapCells* _pd_seq;
  };

  class OGMapCells_out {
  public:
    inline OGMapCells_out(OGMapCells*& _s) : _data(_s) { _data = 0; }
    inline OGMapCells_out(OGMapCells_var& _s)
      : _data(_s._pd_seq) { _s = (OGMapCells*) 0; }
    inline OGMapCells_out(const OGMapCells_out& _s) : _data(_s._data) {}
    inline OGMapCells_out& operator = (const OGMapCells_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline OGMapCells_out& operator = (OGMapCells* _s) {
      _data = _s;
      return *this;
    }
    inline operator OGMapCells*&()  { return _data; }
    inline OGMapCells*& ptr()       { return _data; }
    inline OGMapCells* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    OGMapCells*& _data;

  private:
    OGMapCells_out();
    OGMapCells_out& operator=(const OGMapCells_var&);
  };

  struct OGMapTile {
    typedef _CORBA_ConstrType_Variable_Var<OGMapTile> _var_type;

    
    ::CORBA::ULong column;

    ::CORBA::ULong row;

    ::CORBA::ULong width;

    ::CORBA::ULong height;

    OGMapCells cells;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef OGMapTile::_var_type OGMapTile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< OGMapTile,OGMapTile_var > OGMapTile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OGMapTile;

  struct PointFeature {
    typedef _CORBA_ConstrType_Fix_Var<PointFeature> _var_type;

    
    ::CORBA::Double probability;

    Point2D position;

    PointCovariance2D covariance;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PointFeature::_var_type PointFeature_var;

  typedef PointFeature& PointFeature_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PointFeature;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PointFeatureList;

  class PointFeatureList_var;

  class PointFeatureList : public _CORBA_Unbounded_Sequence< PointFeature >  {
  public:
    typedef PointFeatureList_var _var_type;
    inline PointFeatureList() {}
    inline PointFeatureList(const PointFeatureList& _s)
      : _CORBA_Unbounded_Sequence< PointFeature > (_s) {}

    inline PointFeatureList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PointFeature > (_max) {}
    inline PointFeatureList(_CORBA_ULong _max, _CORBA_ULong _len, PointFeature* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PointFeature > (_max, _len, _val, _rel) {}

  

    inline PointFeatureList& operator = (const PointFeatureList& _s) {
      _CORBA_Unbounded_Sequence< PointFeature > ::operator=(_s);
      return *this;
    }
  };

  class PointFeatureList_out;

  class PointFeatureList_var {
  public:
    inline PointFeatureList_var() : _pd_seq(0) {}
    inline PointFeatureList_var(PointFeatureList* _s) : _pd_seq(_s) {}
    inline PointFeatureList_var(const PointFeatureList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PointFeatureList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PointFeatureList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PointFeatureList_var& operator = (PointFeatureList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PointFeatureList_var& operator = (const PointFeatureList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PointFeatureList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline PointFeature& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PointFeatureList* operator -> () { return _pd_seq; }
    inline const PointFeatureList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PointFeatureList& () const { return *_pd_seq; }
#else
    inline operator const PointFeatureList& () const { return *_pd_seq; }
    inline operator PointFeatureList& () { return *_pd_seq; }
#endif
      
    inline const PointFeatureList& in() const { return *_pd_seq; }
    inline PointFeatureList&       inout()    { return *_pd_seq; }
    inline PointFeatureList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PointFeatureList* _retn() { PointFeatureList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PointFeatureList_out;
    
  private:
    PointFeatureList* _pd_seq;
  };

  class PointFeatureList_out {
  public:
    inline PointFeatureList_out(PointFeatureList*& _s) : _data(_s) { _data = 0; }
    inline PointFeatureList_out(PointFeatureList_var& _s)
      : _data(_s._pd_seq) { _s = (PointFeatureList*) 0; }
    inline PointFeatureList_out(const PointFeatureList_out& _s) : _data(_s._data) {}
    inline PointFeatureList_out& operator = (const PointFeatureList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PointFeatureList_out& operator = (PointFeatureList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PointFeatureList*&()  { return _data; }
    inline PointFeatureList*& ptr()       { return _data; }
    inline PointFeatureList* operator->() { return _data; }

    inline PointFeature& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PointFeatureList*& _data;

  private:
    PointFeatureList_out();
    PointFeatureList_out& operator=(const PointFeatureList_var&);
  };

  struct PoseFeature {
    typedef _CORBA_ConstrType_Fix_Var<PoseFeature> _var_type;

    
    ::CORBA::Double probability;

    Pose2D position;

    Covariance2D covariance;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PoseFeature::_var_type PoseFeature_var;

  typedef PoseFeature& PoseFeature_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PoseFeature;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PoseFeatureList;

  class PoseFeatureList_var;

  class PoseFeatureList : public _CORBA_Unbounded_Sequence< PoseFeature >  {
  public:
    typedef PoseFeatureList_var _var_type;
    inline PoseFeatureList() {}
    inline PoseFeatureList(const PoseFeatureList& _s)
      : _CORBA_Unbounded_Sequence< PoseFeature > (_s) {}

    inline PoseFeatureList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PoseFeature > (_max) {}
    inline PoseFeatureList(_CORBA_ULong _max, _CORBA_ULong _len, PoseFeature* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PoseFeature > (_max, _len, _val, _rel) {}

  

    inline PoseFeatureList& operator = (const PoseFeatureList& _s) {
      _CORBA_Unbounded_Sequence< PoseFeature > ::operator=(_s);
      return *this;
    }
  };

  class PoseFeatureList_out;

  class PoseFeatureList_var {
  public:
    inline PoseFeatureList_var() : _pd_seq(0) {}
    inline PoseFeatureList_var(PoseFeatureList* _s) : _pd_seq(_s) {}
    inline PoseFeatureList_var(const PoseFeatureList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PoseFeatureList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PoseFeatureList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PoseFeatureList_var& operator = (PoseFeatureList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PoseFeatureList_var& operator = (const PoseFeatureList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PoseFeatureList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline PoseFeature& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PoseFeatureList* operator -> () { return _pd_seq; }
    inline const PoseFeatureList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PoseFeatureList& () const { return *_pd_seq; }
#else
    inline operator const PoseFeatureList& () const { return *_pd_seq; }
    inline operator PoseFeatureList& () { return *_pd_seq; }
#endif
      
    inline const PoseFeatureList& in() const { return *_pd_seq; }
    inline PoseFeatureList&       inout()    { return *_pd_seq; }
    inline PoseFeatureList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PoseFeatureList* _retn() { PoseFeatureList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PoseFeatureList_out;
    
  private:
    PoseFeatureList* _pd_seq;
  };

  class PoseFeatureList_out {
  public:
    inline PoseFeatureList_out(PoseFeatureList*& _s) : _data(_s) { _data = 0; }
    inline PoseFeatureList_out(PoseFeatureList_var& _s)
      : _data(_s._pd_seq) { _s = (PoseFeatureList*) 0; }
    inline PoseFeatureList_out(const PoseFeatureList_out& _s) : _data(_s._data) {}
    inline PoseFeatureList_out& operator = (const PoseFeatureList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PoseFeatureList_out& operator = (PoseFeatureList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PoseFeatureList*&()  { return _data; }
    inline PoseFeatureList*& ptr()       { return _data; }
    inline PoseFeatureList* operator->() { return _data; }

    inline PoseFeature& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PoseFeatureList*& _data;

  private:
    PoseFeatureList_out();
    PoseFeatureList_out& operator=(const PoseFeatureList_var&);
  };

  struct LineFeature {
    typedef _CORBA_ConstrType_Fix_Var<LineFeature> _var_type;

    
    ::CORBA::Double probability;

    ::CORBA::Double rho;

    ::CORBA::Double alpha;

    PointCovariance2D covariance;

    Point2D start;

    Point2D end;

    ::CORBA::Boolean startSighted;

    ::CORBA::Boolean endSighted;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LineFeature::_var_type LineFeature_var;

  typedef LineFeature& LineFeature_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LineFeature;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LineFeatureList;

  class LineFeatureList_var;

  class LineFeatureList : public _CORBA_Unbounded_Sequence< LineFeature >  {
  public:
    typedef LineFeatureList_var _var_type;
    inline LineFeatureList() {}
    inline LineFeatureList(const LineFeatureList& _s)
      : _CORBA_Unbounded_Sequence< LineFeature > (_s) {}

    inline LineFeatureList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LineFeature > (_max) {}
    inline LineFeatureList(_CORBA_ULong _max, _CORBA_ULong _len, LineFeature* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LineFeature > (_max, _len, _val, _rel) {}

  

    inline LineFeatureList& operator = (const LineFeatureList& _s) {
      _CORBA_Unbounded_Sequence< LineFeature > ::operator=(_s);
      return *this;
    }
  };

  class LineFeatureList_out;

  class LineFeatureList_var {
  public:
    inline LineFeatureList_var() : _pd_seq(0) {}
    inline LineFeatureList_var(LineFeatureList* _s) : _pd_seq(_s) {}
    inline LineFeatureList_var(const LineFeatureList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LineFeatureList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LineFeatureList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LineFeatureList_var& operator = (LineFeatureList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LineFeatureList_var& operator = (const LineFeatureList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LineFeatureList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline LineFeature& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LineFeatureList* operator -> () { return _pd_seq; }
    inline const LineFeatureList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LineFeatureList& () const { return *_pd_seq; }
#else
    inline operator const LineFeatureList& () const { return *_pd_seq; }
    inline operator LineFeatureList& () { return *_pd_seq; }
#endif
      
    inline const LineFeatureList& in() const { return *_pd_seq; }
    inline LineFeatureList&       inout()    { return *_pd_seq; }
    inline LineFeatureList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LineFeatureList* _retn() { LineFeatureList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LineFeatureList_out;
    
  private:
    LineFeatureList* _pd_seq;
  };

  class LineFeatureList_out {
  public:
    inline LineFeatureList_out(LineFeatureList*& _s) : _data(_s) { _data = 0; }
    inline LineFeatureList_out(LineFeatureList_var& _s)
      : _data(_s._pd_seq) { _s = (LineFeatureList*) 0; }
    inline LineFeatureList_out(const LineFeatureList_out& _s) : _data(_s._data) {}
    inline LineFeatureList_out& operator = (const LineFeatureList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LineFeatureList_out& operator = (LineFeatureList* _s) {
      _data = _s;
      return *this;
    }
    inline operator LineFeatureList*&()  { return _data; }
    inline LineFeatureList*& ptr()       { return _data; }
    inline LineFeatureList* operator->() { return _data; }

    inline LineFeature& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LineFeatureList*& _data;

  private:
    LineFeatureList_out();
    LineFeatureList_out& operator=(const LineFeatureList_var&);
  };

  struct Features {
    typedef _CORBA_ConstrType_Variable_Var<Features> _var_type;

    
    Time tm;

    PointFeatureList pointFeatures;

    PoseFeatureList poseFeatures;

    LineFeatureList lineFeatures;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Features::_var_type Features_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Features,Features_var > Features_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Features;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MulticameraImageList;

  class MulticameraImageList_var;

  class MulticameraImageList : public _CORBA_Unbounded_Sequence< CameraImage >  {
  public:
    typedef MulticameraImageList_var _var_type;
    inline MulticameraImageList() {}
    inline MulticameraImageList(const MulticameraImageList& _s)
      : _CORBA_Unbounded_Sequence< CameraImage > (_s) {}

    inline MulticameraImageList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< CameraImage > (_max) {}
    inline MulticameraImageList(_CORBA_ULong _max, _CORBA_ULong _len, CameraImage* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< CameraImage > (_max, _len, _val, _rel) {}

  

    inline MulticameraImageList& operator = (const MulticameraImageList& _s) {
      _CORBA_Unbounded_Sequence< CameraImage > ::operator=(_s);
      return *this;
    }
  };

  class MulticameraImageList_out;

  class MulticameraImageList_var {
  public:
    inline MulticameraImageList_var() : _pd_seq(0) {}
    inline MulticameraImageList_var(MulticameraImageList* _s) : _pd_seq(_s) {}
    inline MulticameraImageList_var(const MulticameraImageList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new MulticameraImageList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~MulticameraImageList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline MulticameraImageList_var& operator = (MulticameraImageList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline MulticameraImageList_var& operator = (const MulticameraImageList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new MulticameraImageList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline CameraImage& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline MulticameraImageList* operator -> () { return _pd_seq; }
    inline const MulticameraImageList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator MulticameraImageList& () const { return *_pd_seq; }
#else
    inline operator const MulticameraImageList& () const { return *_pd_seq; }
    inline operator MulticameraImageList& () { return *_pd_seq; }
#endif
      
    inline const MulticameraImageList& in() const { return *_pd_seq; }
    inline MulticameraImageList&       inout()    { return *_pd_seq; }
    inline MulticameraImageList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline MulticameraImageList* _retn() { MulticameraImageList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class MulticameraImageList_out;
    
  private:
    MulticameraImageList* _pd_seq;
  };

  class MulticameraImageList_out {
  public:
    inline MulticameraImageList_out(MulticameraImageList*& _s) : _data(_s) { _data = 0; }
    inline MulticameraImageList_out(MulticameraImageList_var& _s)
      : _data(_s._pd_seq) { _s = (MulticameraImageList*) 0; }
    inline MulticameraImageList_out(const MulticameraImageList_out& _s) : _data(_s._data) {}
    inline MulticameraImageList_out& operator = (const MulticameraImageList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline MulticameraImageList_out& operator = (MulticameraImageList* _s) {
      _data = _s;
      return *this;
    }
    inline operator MulticameraImageList*&()  { return _data; }
    inline MulticameraImageList*& ptr()       { return _data; }
    inline MulticameraImageList* operator->() { return _data; }

    inline CameraImage& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    MulticameraImageList*& _data;

  private:
    MulticameraImageList_out();
    MulticameraImageList_out& operator=(const MulticameraImageList_var&);
  };

  struct MultiCameraImages {
    typedef _CORBA_ConstrType_Variable_Var<MultiCameraImages> _var_type;

    
    Time tm;

    MulticameraImageList images;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef MultiCameraImages::_var_type MultiCameraImages_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< MultiCameraImages,MultiCameraImages_var > MultiCameraImages_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MultiCameraImages;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MulticameraInfoList;

  class MulticameraInfoList_var;

  class MulticameraInfoList : public _CORBA_Unbounded_Sequence< CameraInfo >  {
  public:
    typedef MulticameraInfoList_var _var_type;
    inline MulticameraInfoList() {}
    inline MulticameraInfoList(const MulticameraInfoList& _s)
      : _CORBA_Unbounded_Sequence< CameraInfo > (_s) {}

    inline MulticameraInfoList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< CameraInfo > (_max) {}
    inline MulticameraInfoList(_CORBA_ULong _max, _CORBA_ULong _len, CameraInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< CameraInfo > (_max, _len, _val, _rel) {}

  

    inline MulticameraInfoList& operator = (const MulticameraInfoList& _s) {
      _CORBA_Unbounded_Sequence< CameraInfo > ::operator=(_s);
      return *this;
    }
  };

  class MulticameraInfoList_out;

  class MulticameraInfoList_var {
  public:
    inline MulticameraInfoList_var() : _pd_seq(0) {}
    inline MulticameraInfoList_var(MulticameraInfoList* _s) : _pd_seq(_s) {}
    inline MulticameraInfoList_var(const MulticameraInfoList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new MulticameraInfoList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~MulticameraInfoList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline MulticameraInfoList_var& operator = (MulticameraInfoList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline MulticameraInfoList_var& operator = (const MulticameraInfoList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new MulticameraInfoList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline CameraInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline MulticameraInfoList* operator -> () { return _pd_seq; }
    inline const MulticameraInfoList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator MulticameraInfoList& () const { return *_pd_seq; }
#else
    inline operator const MulticameraInfoList& () const { return *_pd_seq; }
    inline operator MulticameraInfoList& () { return *_pd_seq; }
#endif
      
    inline const MulticameraInfoList& in() const { return *_pd_seq; }
    inline MulticameraInfoList&       inout()    { return *_pd_seq; }
    inline MulticameraInfoList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline MulticameraInfoList* _retn() { MulticameraInfoList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class MulticameraInfoList_out;
    
  private:
    MulticameraInfoList* _pd_seq;
  };

  class MulticameraInfoList_out {
  public:
    inline MulticameraInfoList_out(MulticameraInfoList*& _s) : _data(_s) { _data = 0; }
    inline MulticameraInfoList_out(MulticameraInfoList_var& _s)
      : _data(_s._pd_seq) { _s = (MulticameraInfoList*) 0; }
    inline MulticameraInfoList_out(const MulticameraInfoList_out& _s) : _data(_s._data) {}
    inline MulticameraInfoList_out& operator = (const MulticameraInfoList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline MulticameraInfoList_out& operator = (MulticameraInfoList* _s) {
      _data = _s;
      return *this;
    }
    inline operator MulticameraInfoList*&()  { return _data; }
    inline MulticameraInfoList*& ptr()       { return _data; }
    inline MulticameraInfoList* operator->() { return _data; }

    inline CameraInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    MulticameraInfoList*& _data;

  private:
    MulticameraInfoList_out();
    MulticameraInfoList_out& operator=(const MulticameraInfoList_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MulticameraGeometryList;

  class MulticameraGeometryList_var;

  class MulticameraGeometryList : public _CORBA_Unbounded_Sequence< Geometry3D >  {
  public:
    typedef MulticameraGeometryList_var _var_type;
    inline MulticameraGeometryList() {}
    inline MulticameraGeometryList(const MulticameraGeometryList& _s)
      : _CORBA_Unbounded_Sequence< Geometry3D > (_s) {}

    inline MulticameraGeometryList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Geometry3D > (_max) {}
    inline MulticameraGeometryList(_CORBA_ULong _max, _CORBA_ULong _len, Geometry3D* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Geometry3D > (_max, _len, _val, _rel) {}

  

    inline MulticameraGeometryList& operator = (const MulticameraGeometryList& _s) {
      _CORBA_Unbounded_Sequence< Geometry3D > ::operator=(_s);
      return *this;
    }
  };

  class MulticameraGeometryList_out;

  class MulticameraGeometryList_var {
  public:
    inline MulticameraGeometryList_var() : _pd_seq(0) {}
    inline MulticameraGeometryList_var(MulticameraGeometryList* _s) : _pd_seq(_s) {}
    inline MulticameraGeometryList_var(const MulticameraGeometryList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new MulticameraGeometryList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~MulticameraGeometryList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline MulticameraGeometryList_var& operator = (MulticameraGeometryList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline MulticameraGeometryList_var& operator = (const MulticameraGeometryList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new MulticameraGeometryList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Geometry3D& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline MulticameraGeometryList* operator -> () { return _pd_seq; }
    inline const MulticameraGeometryList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator MulticameraGeometryList& () const { return *_pd_seq; }
#else
    inline operator const MulticameraGeometryList& () const { return *_pd_seq; }
    inline operator MulticameraGeometryList& () { return *_pd_seq; }
#endif
      
    inline const MulticameraGeometryList& in() const { return *_pd_seq; }
    inline MulticameraGeometryList&       inout()    { return *_pd_seq; }
    inline MulticameraGeometryList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline MulticameraGeometryList* _retn() { MulticameraGeometryList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class MulticameraGeometryList_out;
    
  private:
    MulticameraGeometryList* _pd_seq;
  };

  class MulticameraGeometryList_out {
  public:
    inline MulticameraGeometryList_out(MulticameraGeometryList*& _s) : _data(_s) { _data = 0; }
    inline MulticameraGeometryList_out(MulticameraGeometryList_var& _s)
      : _data(_s._pd_seq) { _s = (MulticameraGeometryList*) 0; }
    inline MulticameraGeometryList_out(const MulticameraGeometryList_out& _s) : _data(_s._data) {}
    inline MulticameraGeometryList_out& operator = (const MulticameraGeometryList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline MulticameraGeometryList_out& operator = (MulticameraGeometryList* _s) {
      _data = _s;
      return *this;
    }
    inline operator MulticameraGeometryList*&()  { return _data; }
    inline MulticameraGeometryList*& ptr()       { return _data; }
    inline MulticameraGeometryList* operator->() { return _data; }

    inline Geometry3D& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    MulticameraGeometryList*& _data;

  private:
    MulticameraGeometryList_out();
    MulticameraGeometryList_out& operator=(const MulticameraGeometryList_var&);
  };

  struct MulticameraGeometry {
    typedef _CORBA_ConstrType_Variable_Var<MulticameraGeometry> _var_type;

    
    Geometry3D geometry;

    MulticameraGeometryList cameraGeometries;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef MulticameraGeometry::_var_type MulticameraGeometry_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< MulticameraGeometry,MulticameraGeometry_var > MulticameraGeometry_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MulticameraGeometry;

  struct Waypoint2D {
    typedef _CORBA_ConstrType_Fix_Var<Waypoint2D> _var_type;

    
    Pose2D target;

    ::CORBA::Double distanceTolerance;

    ::CORBA::Double headingTolerance;

    Time timeLimit;

    Velocity2D maxSpeed;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Waypoint2D::_var_type Waypoint2D_var;

  typedef Waypoint2D& Waypoint2D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Waypoint2D;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Waypoint2DList;

  class Waypoint2DList_var;

  class Waypoint2DList : public _CORBA_Unbounded_Sequence< Waypoint2D >  {
  public:
    typedef Waypoint2DList_var _var_type;
    inline Waypoint2DList() {}
    inline Waypoint2DList(const Waypoint2DList& _s)
      : _CORBA_Unbounded_Sequence< Waypoint2D > (_s) {}

    inline Waypoint2DList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Waypoint2D > (_max) {}
    inline Waypoint2DList(_CORBA_ULong _max, _CORBA_ULong _len, Waypoint2D* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Waypoint2D > (_max, _len, _val, _rel) {}

  

    inline Waypoint2DList& operator = (const Waypoint2DList& _s) {
      _CORBA_Unbounded_Sequence< Waypoint2D > ::operator=(_s);
      return *this;
    }
  };

  class Waypoint2DList_out;

  class Waypoint2DList_var {
  public:
    inline Waypoint2DList_var() : _pd_seq(0) {}
    inline Waypoint2DList_var(Waypoint2DList* _s) : _pd_seq(_s) {}
    inline Waypoint2DList_var(const Waypoint2DList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Waypoint2DList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Waypoint2DList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Waypoint2DList_var& operator = (Waypoint2DList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Waypoint2DList_var& operator = (const Waypoint2DList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Waypoint2DList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Waypoint2D& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Waypoint2DList* operator -> () { return _pd_seq; }
    inline const Waypoint2DList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Waypoint2DList& () const { return *_pd_seq; }
#else
    inline operator const Waypoint2DList& () const { return *_pd_seq; }
    inline operator Waypoint2DList& () { return *_pd_seq; }
#endif
      
    inline const Waypoint2DList& in() const { return *_pd_seq; }
    inline Waypoint2DList&       inout()    { return *_pd_seq; }
    inline Waypoint2DList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Waypoint2DList* _retn() { Waypoint2DList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Waypoint2DList_out;
    
  private:
    Waypoint2DList* _pd_seq;
  };

  class Waypoint2DList_out {
  public:
    inline Waypoint2DList_out(Waypoint2DList*& _s) : _data(_s) { _data = 0; }
    inline Waypoint2DList_out(Waypoint2DList_var& _s)
      : _data(_s._pd_seq) { _s = (Waypoint2DList*) 0; }
    inline Waypoint2DList_out(const Waypoint2DList_out& _s) : _data(_s._data) {}
    inline Waypoint2DList_out& operator = (const Waypoint2DList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Waypoint2DList_out& operator = (Waypoint2DList* _s) {
      _data = _s;
      return *this;
    }
    inline operator Waypoint2DList*&()  { return _data; }
    inline Waypoint2DList*& ptr()       { return _data; }
    inline Waypoint2DList* operator->() { return _data; }

    inline Waypoint2D& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Waypoint2DList*& _data;

  private:
    Waypoint2DList_out();
    Waypoint2DList_out& operator=(const Waypoint2DList_var&);
  };

  struct Path2D {
    typedef _CORBA_ConstrType_Variable_Var<Path2D> _var_type;

    
    Time tm;

    Waypoint2DList waypoints;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Path2D::_var_type Path2D_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Path2D,Path2D_var > Path2D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Path2D;

  struct Waypoint3D {
    typedef _CORBA_ConstrType_Fix_Var<Waypoint3D> _var_type;

    
    Pose3D target;

    ::CORBA::Double distanceTolerance;

    ::CORBA::Double headingTolerance;

    Time timeLimit;

    Velocity3D maxSpeed;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Waypoint3D::_var_type Waypoint3D_var;

  typedef Waypoint3D& Waypoint3D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Waypoint3D;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Waypoint3DList;

  class Waypoint3DList_var;

  class Waypoint3DList : public _CORBA_Unbounded_Sequence< Waypoint3D >  {
  public:
    typedef Waypoint3DList_var _var_type;
    inline Waypoint3DList() {}
    inline Waypoint3DList(const Waypoint3DList& _s)
      : _CORBA_Unbounded_Sequence< Waypoint3D > (_s) {}

    inline Waypoint3DList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Waypoint3D > (_max) {}
    inline Waypoint3DList(_CORBA_ULong _max, _CORBA_ULong _len, Waypoint3D* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Waypoint3D > (_max, _len, _val, _rel) {}

  

    inline Waypoint3DList& operator = (const Waypoint3DList& _s) {
      _CORBA_Unbounded_Sequence< Waypoint3D > ::operator=(_s);
      return *this;
    }
  };

  class Waypoint3DList_out;

  class Waypoint3DList_var {
  public:
    inline Waypoint3DList_var() : _pd_seq(0) {}
    inline Waypoint3DList_var(Waypoint3DList* _s) : _pd_seq(_s) {}
    inline Waypoint3DList_var(const Waypoint3DList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Waypoint3DList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Waypoint3DList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Waypoint3DList_var& operator = (Waypoint3DList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Waypoint3DList_var& operator = (const Waypoint3DList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Waypoint3DList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Waypoint3D& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Waypoint3DList* operator -> () { return _pd_seq; }
    inline const Waypoint3DList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Waypoint3DList& () const { return *_pd_seq; }
#else
    inline operator const Waypoint3DList& () const { return *_pd_seq; }
    inline operator Waypoint3DList& () { return *_pd_seq; }
#endif
      
    inline const Waypoint3DList& in() const { return *_pd_seq; }
    inline Waypoint3DList&       inout()    { return *_pd_seq; }
    inline Waypoint3DList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Waypoint3DList* _retn() { Waypoint3DList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Waypoint3DList_out;
    
  private:
    Waypoint3DList* _pd_seq;
  };

  class Waypoint3DList_out {
  public:
    inline Waypoint3DList_out(Waypoint3DList*& _s) : _data(_s) { _data = 0; }
    inline Waypoint3DList_out(Waypoint3DList_var& _s)
      : _data(_s._pd_seq) { _s = (Waypoint3DList*) 0; }
    inline Waypoint3DList_out(const Waypoint3DList_out& _s) : _data(_s._data) {}
    inline Waypoint3DList_out& operator = (const Waypoint3DList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Waypoint3DList_out& operator = (Waypoint3DList* _s) {
      _data = _s;
      return *this;
    }
    inline operator Waypoint3DList*&()  { return _data; }
    inline Waypoint3DList*& ptr()       { return _data; }
    inline Waypoint3DList* operator->() { return _data; }

    inline Waypoint3D& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Waypoint3DList*& _data;

  private:
    Waypoint3DList_out();
    Waypoint3DList_out& operator=(const Waypoint3DList_var&);
  };

  struct Path3D {
    typedef _CORBA_ConstrType_Variable_Var<Path3D> _var_type;

    
    Time tm;

    Waypoint3DList waypoints;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Path3D::_var_type Path3D_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Path3D,Path3D_var > Path3D_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Path3D;

  struct PointCloudPoint {
    typedef _CORBA_ConstrType_Fix_Var<PointCloudPoint> _var_type;

    
    Point3D point;

    RGBColour colour;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PointCloudPoint::_var_type PointCloudPoint_var;

  typedef PointCloudPoint& PointCloudPoint_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PointCloudPoint;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PointCloudPointList;

  class PointCloudPointList_var;

  class PointCloudPointList : public _CORBA_Unbounded_Sequence< PointCloudPoint >  {
  public:
    typedef PointCloudPointList_var _var_type;
    inline PointCloudPointList() {}
    inline PointCloudPointList(const PointCloudPointList& _s)
      : _CORBA_Unbounded_Sequence< PointCloudPoint > (_s) {}

    inline PointCloudPointList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PointCloudPoint > (_max) {}
    inline PointCloudPointList(_CORBA_ULong _max, _CORBA_ULong _len, PointCloudPoint* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PointCloudPoint > (_max, _len, _val, _rel) {}

  

    inline PointCloudPointList& operator = (const PointCloudPointList& _s) {
      _CORBA_Unbounded_Sequence< PointCloudPoint > ::operator=(_s);
      return *this;
    }
  };

  class PointCloudPointList_out;

  class PointCloudPointList_var {
  public:
    inline PointCloudPointList_var() : _pd_seq(0) {}
    inline PointCloudPointList_var(PointCloudPointList* _s) : _pd_seq(_s) {}
    inline PointCloudPointList_var(const PointCloudPointList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PointCloudPointList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PointCloudPointList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PointCloudPointList_var& operator = (PointCloudPointList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PointCloudPointList_var& operator = (const PointCloudPointList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PointCloudPointList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline PointCloudPoint& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PointCloudPointList* operator -> () { return _pd_seq; }
    inline const PointCloudPointList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PointCloudPointList& () const { return *_pd_seq; }
#else
    inline operator const PointCloudPointList& () const { return *_pd_seq; }
    inline operator PointCloudPointList& () { return *_pd_seq; }
#endif
      
    inline const PointCloudPointList& in() const { return *_pd_seq; }
    inline PointCloudPointList&       inout()    { return *_pd_seq; }
    inline PointCloudPointList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PointCloudPointList* _retn() { PointCloudPointList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PointCloudPointList_out;
    
  private:
    PointCloudPointList* _pd_seq;
  };

  class PointCloudPointList_out {
  public:
    inline PointCloudPointList_out(PointCloudPointList*& _s) : _data(_s) { _data = 0; }
    inline PointCloudPointList_out(PointCloudPointList_var& _s)
      : _data(_s._pd_seq) { _s = (PointCloudPointList*) 0; }
    inline PointCloudPointList_out(const PointCloudPointList_out& _s) : _data(_s._data) {}
    inline PointCloudPointList_out& operator = (const PointCloudPointList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PointCloudPointList_out& operator = (PointCloudPointList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PointCloudPointList*&()  { return _data; }
    inline PointCloudPointList*& ptr()       { return _data; }
    inline PointCloudPointList* operator->() { return _data; }

    inline PointCloudPoint& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PointCloudPointList*& _data;

  private:
    PointCloudPointList_out();
    PointCloudPointList_out& operator=(const PointCloudPointList_var&);
  };

  struct PointCloud {
    typedef _CORBA_ConstrType_Variable_Var<PointCloud> _var_type;

    
    Time tm;

    PointCloudPointList points;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PointCloud::_var_type PointCloud_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PointCloud,PointCloud_var > PointCloud_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PointCloud;

  struct PanTiltAngles {
    typedef _CORBA_ConstrType_Fix_Var<PanTiltAngles> _var_type;

    
    Time tm;

    ::CORBA::Double pan;

    ::CORBA::Double tilt;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PanTiltAngles::_var_type PanTiltAngles_var;

  typedef PanTiltAngles& PanTiltAngles_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PanTiltAngles;

  struct PanTiltState {
    typedef _CORBA_ConstrType_Fix_Var<PanTiltState> _var_type;

    
    Time tm;

    PanTiltAngles angles;

    ::CORBA::Double panSpeed;

    ::CORBA::Double tiltSpeed;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PanTiltState::_var_type PanTiltState_var;

  typedef PanTiltState& PanTiltState_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PanTiltState;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ElementGeometryList;

  class ElementGeometryList_var;

  class ElementGeometryList : public _CORBA_Unbounded_Sequence< Geometry3D >  {
  public:
    typedef ElementGeometryList_var _var_type;
    inline ElementGeometryList() {}
    inline ElementGeometryList(const ElementGeometryList& _s)
      : _CORBA_Unbounded_Sequence< Geometry3D > (_s) {}

    inline ElementGeometryList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Geometry3D > (_max) {}
    inline ElementGeometryList(_CORBA_ULong _max, _CORBA_ULong _len, Geometry3D* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Geometry3D > (_max, _len, _val, _rel) {}

  

    inline ElementGeometryList& operator = (const ElementGeometryList& _s) {
      _CORBA_Unbounded_Sequence< Geometry3D > ::operator=(_s);
      return *this;
    }
  };

  class ElementGeometryList_out;

  class ElementGeometryList_var {
  public:
    inline ElementGeometryList_var() : _pd_seq(0) {}
    inline ElementGeometryList_var(ElementGeometryList* _s) : _pd_seq(_s) {}
    inline ElementGeometryList_var(const ElementGeometryList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ElementGeometryList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ElementGeometryList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ElementGeometryList_var& operator = (ElementGeometryList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ElementGeometryList_var& operator = (const ElementGeometryList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ElementGeometryList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Geometry3D& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ElementGeometryList* operator -> () { return _pd_seq; }
    inline const ElementGeometryList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ElementGeometryList& () const { return *_pd_seq; }
#else
    inline operator const ElementGeometryList& () const { return *_pd_seq; }
    inline operator ElementGeometryList& () { return *_pd_seq; }
#endif
      
    inline const ElementGeometryList& in() const { return *_pd_seq; }
    inline ElementGeometryList&       inout()    { return *_pd_seq; }
    inline ElementGeometryList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ElementGeometryList* _retn() { ElementGeometryList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ElementGeometryList_out;
    
  private:
    ElementGeometryList* _pd_seq;
  };

  class ElementGeometryList_out {
  public:
    inline ElementGeometryList_out(ElementGeometryList*& _s) : _data(_s) { _data = 0; }
    inline ElementGeometryList_out(ElementGeometryList_var& _s)
      : _data(_s._pd_seq) { _s = (ElementGeometryList*) 0; }
    inline ElementGeometryList_out(const ElementGeometryList_out& _s) : _data(_s._data) {}
    inline ElementGeometryList_out& operator = (const ElementGeometryList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ElementGeometryList_out& operator = (ElementGeometryList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ElementGeometryList*&()  { return _data; }
    inline ElementGeometryList*& ptr()       { return _data; }
    inline ElementGeometryList* operator->() { return _data; }

    inline Geometry3D& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ElementGeometryList*& _data;

  private:
    ElementGeometryList_out();
    ElementGeometryList_out& operator=(const ElementGeometryList_var&);
  };

  struct RangerGeometry {
    typedef _CORBA_ConstrType_Variable_Var<RangerGeometry> _var_type;

    
    Geometry3D geometry;

    ElementGeometryList elementGeometries;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RangerGeometry::_var_type RangerGeometry_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< RangerGeometry,RangerGeometry_var > RangerGeometry_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RangerGeometry;

  struct RangerConfig {
    typedef _CORBA_ConstrType_Fix_Var<RangerConfig> _var_type;

    
    ::CORBA::Double minAngle;

    ::CORBA::Double maxAngle;

    ::CORBA::Double angularRes;

    ::CORBA::Double minRange;

    ::CORBA::Double maxRange;

    ::CORBA::Double rangeRes;

    ::CORBA::Double frequency;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RangerConfig::_var_type RangerConfig_var;

  typedef RangerConfig& RangerConfig_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RangerConfig;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RangeList;

  class RangeList_var;

  class RangeList : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef RangeList_var _var_type;
    inline RangeList() {}
    inline RangeList(const RangeList& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline RangeList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline RangeList(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline RangeList& operator = (const RangeList& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class RangeList_out;

  class RangeList_var {
  public:
    inline RangeList_var() : _pd_seq(0) {}
    inline RangeList_var(RangeList* _s) : _pd_seq(_s) {}
    inline RangeList_var(const RangeList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new RangeList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~RangeList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline RangeList_var& operator = (RangeList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline RangeList_var& operator = (const RangeList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new RangeList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline RangeList* operator -> () { return _pd_seq; }
    inline const RangeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator RangeList& () const { return *_pd_seq; }
#else
    inline operator const RangeList& () const { return *_pd_seq; }
    inline operator RangeList& () { return *_pd_seq; }
#endif
      
    inline const RangeList& in() const { return *_pd_seq; }
    inline RangeList&       inout()    { return *_pd_seq; }
    inline RangeList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline RangeList* _retn() { RangeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class RangeList_out;
    
  private:
    RangeList* _pd_seq;
  };

  class RangeList_out {
  public:
    inline RangeList_out(RangeList*& _s) : _data(_s) { _data = 0; }
    inline RangeList_out(RangeList_var& _s)
      : _data(_s._pd_seq) { _s = (RangeList*) 0; }
    inline RangeList_out(const RangeList_out& _s) : _data(_s._data) {}
    inline RangeList_out& operator = (const RangeList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline RangeList_out& operator = (RangeList* _s) {
      _data = _s;
      return *this;
    }
    inline operator RangeList*&()  { return _data; }
    inline RangeList*& ptr()       { return _data; }
    inline RangeList* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    RangeList*& _data;

  private:
    RangeList_out();
    RangeList_out& operator=(const RangeList_var&);
  };

  struct RangeData {
    typedef _CORBA_ConstrType_Variable_Var<RangeData> _var_type;

    
    Time tm;

    RangeList ranges;

    RangerGeometry geometry;

    RangerConfig config;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RangeData::_var_type RangeData_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< RangeData,RangeData_var > RangeData_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RangeData;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IntensityList;

  class IntensityList_var;

  class IntensityList : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef IntensityList_var _var_type;
    inline IntensityList() {}
    inline IntensityList(const IntensityList& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline IntensityList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline IntensityList(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline IntensityList& operator = (const IntensityList& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class IntensityList_out;

  class IntensityList_var {
  public:
    inline IntensityList_var() : _pd_seq(0) {}
    inline IntensityList_var(IntensityList* _s) : _pd_seq(_s) {}
    inline IntensityList_var(const IntensityList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new IntensityList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~IntensityList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline IntensityList_var& operator = (IntensityList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline IntensityList_var& operator = (const IntensityList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new IntensityList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline IntensityList* operator -> () { return _pd_seq; }
    inline const IntensityList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator IntensityList& () const { return *_pd_seq; }
#else
    inline operator const IntensityList& () const { return *_pd_seq; }
    inline operator IntensityList& () { return *_pd_seq; }
#endif
      
    inline const IntensityList& in() const { return *_pd_seq; }
    inline IntensityList&       inout()    { return *_pd_seq; }
    inline IntensityList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline IntensityList* _retn() { IntensityList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class IntensityList_out;
    
  private:
    IntensityList* _pd_seq;
  };

  class IntensityList_out {
  public:
    inline IntensityList_out(IntensityList*& _s) : _data(_s) { _data = 0; }
    inline IntensityList_out(IntensityList_var& _s)
      : _data(_s._pd_seq) { _s = (IntensityList*) 0; }
    inline IntensityList_out(const IntensityList_out& _s) : _data(_s._data) {}
    inline IntensityList_out& operator = (const IntensityList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline IntensityList_out& operator = (IntensityList* _s) {
      _data = _s;
      return *this;
    }
    inline operator IntensityList*&()  { return _data; }
    inline IntensityList*& ptr()       { return _data; }
    inline IntensityList* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    IntensityList*& _data;

  private:
    IntensityList_out();
    IntensityList_out& operator=(const IntensityList_var&);
  };

  struct IntensityData {
    typedef _CORBA_ConstrType_Variable_Var<IntensityData> _var_type;

    
    Time tm;

    IntensityList intensities;

    RangerGeometry geometry;

    RangerConfig config;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef IntensityData::_var_type IntensityData_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< IntensityData,IntensityData_var > IntensityData_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IntensityData;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RFIDTagData;

  class RFIDTagData_var;

  class RFIDTagData : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef RFIDTagData_var _var_type;
    inline RFIDTagData() {}
    inline RFIDTagData(const RFIDTagData& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline RFIDTagData(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline RFIDTagData(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline RFIDTagData& operator = (const RFIDTagData& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class RFIDTagData_out;

  class RFIDTagData_var {
  public:
    inline RFIDTagData_var() : _pd_seq(0) {}
    inline RFIDTagData_var(RFIDTagData* _s) : _pd_seq(_s) {}
    inline RFIDTagData_var(const RFIDTagData_var& _s) {
      if( _s._pd_seq )  _pd_seq = new RFIDTagData(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~RFIDTagData_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline RFIDTagData_var& operator = (RFIDTagData* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline RFIDTagData_var& operator = (const RFIDTagData_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new RFIDTagData;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline RFIDTagData* operator -> () { return _pd_seq; }
    inline const RFIDTagData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator RFIDTagData& () const { return *_pd_seq; }
#else
    inline operator const RFIDTagData& () const { return *_pd_seq; }
    inline operator RFIDTagData& () { return *_pd_seq; }
#endif
      
    inline const RFIDTagData& in() const { return *_pd_seq; }
    inline RFIDTagData&       inout()    { return *_pd_seq; }
    inline RFIDTagData*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline RFIDTagData* _retn() { RFIDTagData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class RFIDTagData_out;
    
  private:
    RFIDTagData* _pd_seq;
  };

  class RFIDTagData_out {
  public:
    inline RFIDTagData_out(RFIDTagData*& _s) : _data(_s) { _data = 0; }
    inline RFIDTagData_out(RFIDTagData_var& _s)
      : _data(_s._pd_seq) { _s = (RFIDTagData*) 0; }
    inline RFIDTagData_out(const RFIDTagData_out& _s) : _data(_s._data) {}
    inline RFIDTagData_out& operator = (const RFIDTagData_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline RFIDTagData_out& operator = (RFIDTagData* _s) {
      _data = _s;
      return *this;
    }
    inline operator RFIDTagData*&()  { return _data; }
    inline RFIDTagData*& ptr()       { return _data; }
    inline RFIDTagData* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    RFIDTagData*& _data;

  private:
    RFIDTagData_out();
    RFIDTagData_out& operator=(const RFIDTagData_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_RTC
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_RTC
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorPos& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorPos* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorPos*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorPos*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorSpeed& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorSpeed* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorSpeed*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorSpeed*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorCurrent& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorCurrent* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorCurrent*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorCurrent*& _sp);

inline void operator >>=(RTC::ActArrayActuatorStatus _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::ActArrayActuatorStatus& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::ACTUATOR_STATUS_STALLED) {
    _e = (RTC::ActArrayActuatorStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorStatus _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorStatus& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::Actuator& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Actuator* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Actuator*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Actuator*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::ActuatorList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ActuatorList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActuatorList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActuatorList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::ActArrayState& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ActArrayState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayState*& _sp);

inline void operator >>=(RTC::ActArrayActuatorType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::ActArrayActuatorType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::ACTARRAY_ACTUATORTYPE_ROTARY) {
    _e = (RTC::ActArrayActuatorType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorType& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorGeometry& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorGeometry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorGeometry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorGeometry*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::ActArrayActuatorGeometryList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ActArrayActuatorGeometryList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayActuatorGeometryList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayActuatorGeometryList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::ActArrayGeometry& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ActArrayGeometry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ActArrayGeometry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ActArrayGeometry*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::BumperGeometry& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::BumperGeometry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::BumperGeometry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::BumperGeometry*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::BumperGeometryList& _s);
void operator<<=(::CORBA::Any& _a, RTC::BumperGeometryList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::BumperGeometryList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::BumperGeometryList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::BumperArrayGeometry& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::BumperArrayGeometry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::BumperArrayGeometry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::BumperArrayGeometry*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::CameraImage& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::CameraImage* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::CameraImage*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::CameraImage*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::CameraInfo& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::CameraInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::CameraInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::CameraInfo*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::FiducialInfo& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::FiducialInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FiducialInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FiducialInfo*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::FiducialInfoList& _s);
void operator<<=(::CORBA::Any& _a, RTC::FiducialInfoList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FiducialInfoList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FiducialInfoList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Fiducials& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Fiducials* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Fiducials*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Fiducials*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::FiducialFOV& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::FiducialFOV* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FiducialFOV*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FiducialFOV*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::GPSTime& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::GPSTime* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::GPSTime*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GPSTime*& _sp);

inline void operator >>=(RTC::GPSFixType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::GPSFixType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::GPS_FIX_DGPS) {
    _e = (RTC::GPSFixType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::GPSFixType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::GPSFixType& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::GPSData& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::GPSData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::GPSData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GPSData*& _sp);

inline void operator >>=(RTC::GripperStatus _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::GripperStatus& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::GRIPPER_STATE_UNKNOWN) {
    _e = (RTC::GripperStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::GripperStatus _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::GripperStatus& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::GripperState& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::GripperState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::GripperState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GripperState*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::GripperGeometry& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::GripperGeometry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::GripperGeometry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::GripperGeometry*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::INSData& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::INSData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::INSData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::INSData*& _sp);

inline void operator >>=(RTC::LimbStatus _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::LimbStatus& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::LIMB_STATUS_COLLISION) {
    _e = (RTC::LimbStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::LimbStatus _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::LimbStatus& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::LimbState& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::LimbState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::LimbState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::LimbState*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis2D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Hypothesis2D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis2D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis2D*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis2DList& _s);
void operator<<=(::CORBA::Any& _a, RTC::Hypothesis2DList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis2DList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis2DList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Hypotheses2D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Hypotheses2D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypotheses2D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypotheses2D*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis3D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Hypothesis3D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis3D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis3D*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::Hypothesis3DList& _s);
void operator<<=(::CORBA::Any& _a, RTC::Hypothesis3DList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypothesis3DList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypothesis3DList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Hypotheses3D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Hypotheses3D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hypotheses3D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hypotheses3D*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::OGMapConfig& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::OGMapConfig* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapConfig*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OGMapConfig*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::OGMapCells& _s);
void operator<<=(::CORBA::Any& _a, RTC::OGMapCells* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapCells*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OGMapCells*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::OGMapTile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::OGMapTile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapTile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OGMapTile*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::PointFeature& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PointFeature* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointFeature*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointFeature*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::PointFeatureList& _s);
void operator<<=(::CORBA::Any& _a, RTC::PointFeatureList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointFeatureList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointFeatureList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::PoseFeature& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PoseFeature* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PoseFeature*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PoseFeature*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::PoseFeatureList& _s);
void operator<<=(::CORBA::Any& _a, RTC::PoseFeatureList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PoseFeatureList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PoseFeatureList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::LineFeature& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::LineFeature* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::LineFeature*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::LineFeature*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::LineFeatureList& _s);
void operator<<=(::CORBA::Any& _a, RTC::LineFeatureList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::LineFeatureList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::LineFeatureList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Features& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Features* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Features*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Features*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::MulticameraImageList& _s);
void operator<<=(::CORBA::Any& _a, RTC::MulticameraImageList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraImageList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraImageList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::MultiCameraImages& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::MultiCameraImages* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::MultiCameraImages*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MultiCameraImages*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::MulticameraInfoList& _s);
void operator<<=(::CORBA::Any& _a, RTC::MulticameraInfoList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraInfoList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraInfoList*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::MulticameraGeometryList& _s);
void operator<<=(::CORBA::Any& _a, RTC::MulticameraGeometryList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraGeometryList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraGeometryList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::MulticameraGeometry& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::MulticameraGeometry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::MulticameraGeometry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::MulticameraGeometry*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Waypoint2D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Waypoint2D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint2D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint2D*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::Waypoint2DList& _s);
void operator<<=(::CORBA::Any& _a, RTC::Waypoint2DList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint2DList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint2DList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Path2D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Path2D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Path2D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Path2D*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Waypoint3D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Waypoint3D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint3D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint3D*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::Waypoint3DList& _s);
void operator<<=(::CORBA::Any& _a, RTC::Waypoint3DList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Waypoint3DList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Waypoint3DList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::Path3D& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::Path3D* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Path3D*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Path3D*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::PointCloudPoint& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PointCloudPoint* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointCloudPoint*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointCloudPoint*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::PointCloudPointList& _s);
void operator<<=(::CORBA::Any& _a, RTC::PointCloudPointList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointCloudPointList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointCloudPointList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::PointCloud& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PointCloud* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointCloud*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointCloud*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::PanTiltAngles& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PanTiltAngles* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PanTiltAngles*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PanTiltAngles*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::PanTiltState& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PanTiltState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PanTiltState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PanTiltState*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::ElementGeometryList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ElementGeometryList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ElementGeometryList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ElementGeometryList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::RangerGeometry& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::RangerGeometry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangerGeometry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangerGeometry*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::RangerConfig& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::RangerConfig* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangerConfig*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangerConfig*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::RangeList& _s);
void operator<<=(::CORBA::Any& _a, RTC::RangeList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangeList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangeList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::RangeData& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::RangeData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::RangeData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RangeData*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::IntensityList& _s);
void operator<<=(::CORBA::Any& _a, RTC::IntensityList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::IntensityList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::IntensityList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::IntensityData& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::IntensityData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::IntensityData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::IntensityData*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::RFIDTagData& _s);
void operator<<=(::CORBA::Any& _a, RTC::RFIDTagData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::RFIDTagData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RFIDTagData*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_InterfaceDataTypes
#endif

#endif  // __InterfaceDataTypes_hh__

