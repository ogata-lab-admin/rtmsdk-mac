// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __RTC_hh__
#define __RTC_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_RTC
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_RTC
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_RTC
#endif



#ifndef __SDOPackage_hh_EXTERNAL_GUARD__
#define __SDOPackage_hh_EXTERNAL_GUARD__
#include <SDOPackage.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE RTC

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionContextHandle_t;

  typedef ::CORBA::Long ExecutionContextHandle_t;
  typedef ::CORBA::Long_out ExecutionContextHandle_t_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UniqueIdentifier;

  typedef char* UniqueIdentifier;
  typedef ::CORBA::String_var UniqueIdentifier_var;
  typedef ::CORBA::String_out UniqueIdentifier_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NVList;

  typedef SDOPackage::NVList NVList;
  typedef SDOPackage::NVList_var NVList_var;
  typedef SDOPackage::NVList_out NVList_out;

  enum ReturnCode_t { RTC_OK, RTC_ERROR, BAD_PARAMETER, UNSUPPORTED, OUT_OF_RESOURCES, PRECONDITION_NOT_MET /*, __max_ReturnCode_t=0xffffffff */ };
  typedef ReturnCode_t& ReturnCode_t_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ReturnCode_t;

  enum LifeCycleState { CREATED_STATE, INACTIVE_STATE, ACTIVE_STATE, ERROR_STATE /*, __max_LifeCycleState=0xffffffff */ };
  typedef LifeCycleState& LifeCycleState_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LifeCycleState;

#ifndef __RTC_mExecutionContext__
#define __RTC_mExecutionContext__

  class ExecutionContext;
  class _objref_ExecutionContext;
  class _impl_ExecutionContext;
  
  typedef _objref_ExecutionContext* ExecutionContext_ptr;
  typedef ExecutionContext_ptr ExecutionContextRef;

  class ExecutionContext_Helper {
  public:
    typedef ExecutionContext_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ExecutionContext, ExecutionContext_Helper> ExecutionContext_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ExecutionContext,ExecutionContext_Helper > ExecutionContext_out;

#endif

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionContextList;

  class ExecutionContextList_var;

  class ExecutionContextList : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContext, _CORBA_ObjRef_Element< _objref_ExecutionContext, ExecutionContext_Helper> , ExecutionContext_Helper >  {
  public:
    typedef ExecutionContextList_var _var_type;
    inline ExecutionContextList() {}
    inline ExecutionContextList(const ExecutionContextList& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContext, _CORBA_ObjRef_Element< _objref_ExecutionContext, ExecutionContext_Helper> , ExecutionContext_Helper > (_s) {}

    inline ExecutionContextList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContext, _CORBA_ObjRef_Element< _objref_ExecutionContext, ExecutionContext_Helper> , ExecutionContext_Helper > (_max) {}
    inline ExecutionContextList(_CORBA_ULong _max, _CORBA_ULong _len, ExecutionContext_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContext, _CORBA_ObjRef_Element< _objref_ExecutionContext, ExecutionContext_Helper> , ExecutionContext_Helper > (_max, _len, _val, _rel) {}

  

    inline ExecutionContextList& operator = (const ExecutionContextList& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContext, _CORBA_ObjRef_Element< _objref_ExecutionContext, ExecutionContext_Helper> , ExecutionContext_Helper > ::operator=(_s);
      return *this;
    }
  };

  class ExecutionContextList_out;

  class ExecutionContextList_var {
  public:
    inline ExecutionContextList_var() : _pd_seq(0) {}
    inline ExecutionContextList_var(ExecutionContextList* _s) : _pd_seq(_s) {}
    inline ExecutionContextList_var(const ExecutionContextList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ExecutionContextList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ExecutionContextList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ExecutionContextList_var& operator = (ExecutionContextList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ExecutionContextList_var& operator = (const ExecutionContextList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ExecutionContextList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_ExecutionContext, ExecutionContext_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ExecutionContextList* operator -> () { return _pd_seq; }
    inline const ExecutionContextList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ExecutionContextList& () const { return *_pd_seq; }
#else
    inline operator const ExecutionContextList& () const { return *_pd_seq; }
    inline operator ExecutionContextList& () { return *_pd_seq; }
#endif
      
    inline const ExecutionContextList& in() const { return *_pd_seq; }
    inline ExecutionContextList&       inout()    { return *_pd_seq; }
    inline ExecutionContextList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ExecutionContextList* _retn() { ExecutionContextList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ExecutionContextList_out;
    
  private:
    ExecutionContextList* _pd_seq;
  };

  class ExecutionContextList_out {
  public:
    inline ExecutionContextList_out(ExecutionContextList*& _s) : _data(_s) { _data = 0; }
    inline ExecutionContextList_out(ExecutionContextList_var& _s)
      : _data(_s._pd_seq) { _s = (ExecutionContextList*) 0; }
    inline ExecutionContextList_out(const ExecutionContextList_out& _s) : _data(_s._data) {}
    inline ExecutionContextList_out& operator = (const ExecutionContextList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ExecutionContextList_out& operator = (ExecutionContextList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ExecutionContextList*&()  { return _data; }
    inline ExecutionContextList*& ptr()       { return _data; }
    inline ExecutionContextList* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_ExecutionContext, ExecutionContext_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ExecutionContextList*& _data;

  private:
    ExecutionContextList_out();
    ExecutionContextList_out& operator=(const ExecutionContextList_var&);
  };

#ifndef __RTC_mComponentAction__
#define __RTC_mComponentAction__

  class ComponentAction;
  class _objref_ComponentAction;
  class _impl_ComponentAction;
  
  typedef _objref_ComponentAction* ComponentAction_ptr;
  typedef ComponentAction_ptr ComponentActionRef;

  class ComponentAction_Helper {
  public:
    typedef ComponentAction_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ComponentAction, ComponentAction_Helper> ComponentAction_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ComponentAction,ComponentAction_Helper > ComponentAction_out;

#endif

  // interface ComponentAction
  class ComponentAction {
  public:
    // Declarations for this interface type.
    typedef ComponentAction_ptr _ptr_type;
    typedef ComponentAction_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ComponentAction :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ReturnCode_t on_initialize();
    ReturnCode_t on_finalize();
    ReturnCode_t on_startup(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_shutdown(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_activated(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_deactivated(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_aborting(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_error(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_reset(::RTC::ExecutionContextHandle_t exec_handle);

    inline _objref_ComponentAction()  { _PR_setobj(0); }  // nil
    _objref_ComponentAction(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ComponentAction();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ComponentAction(const _objref_ComponentAction&);
    _objref_ComponentAction& operator = (const _objref_ComponentAction&);
    // not implemented

    friend class ComponentAction;
  };

  class _pof_ComponentAction : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ComponentAction() : _OMNI_NS(proxyObjectFactory)(ComponentAction::_PD_repoId) {}
    virtual ~_pof_ComponentAction();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ComponentAction :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ComponentAction();

    virtual ReturnCode_t on_initialize() = 0;
    virtual ReturnCode_t on_finalize() = 0;
    virtual ReturnCode_t on_startup(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_shutdown(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_activated(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_deactivated(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_aborting(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_error(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_reset(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentAction;

#ifndef __RTC_mLightweightRTObject__
#define __RTC_mLightweightRTObject__

  class LightweightRTObject;
  class _objref_LightweightRTObject;
  class _impl_LightweightRTObject;
  
  typedef _objref_LightweightRTObject* LightweightRTObject_ptr;
  typedef LightweightRTObject_ptr LightweightRTObjectRef;

  class LightweightRTObject_Helper {
  public:
    typedef LightweightRTObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LightweightRTObject, LightweightRTObject_Helper> LightweightRTObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LightweightRTObject,LightweightRTObject_Helper > LightweightRTObject_out;

#endif

  // interface LightweightRTObject
  class LightweightRTObject {
  public:
    // Declarations for this interface type.
    typedef LightweightRTObject_ptr _ptr_type;
    typedef LightweightRTObject_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_LightweightRTObject :
    public virtual _objref_ComponentAction
  {
  public:
    ReturnCode_t initialize();
    ReturnCode_t finalize();
    ::CORBA::Boolean is_alive(::RTC::ExecutionContext_ptr exec_context);
    ReturnCode_t exit();
    ExecutionContextHandle_t attach_context(::RTC::ExecutionContext_ptr exec_context);
    ReturnCode_t detach_context(::RTC::ExecutionContextHandle_t exec_handle);
    ExecutionContext_ptr get_context(::RTC::ExecutionContextHandle_t exec_handle);
    ExecutionContextList* get_owned_contexts();
    ExecutionContextList* get_participating_contexts();
    ExecutionContextHandle_t get_context_handle(::RTC::ExecutionContext_ptr cxt);

    inline _objref_LightweightRTObject()  { _PR_setobj(0); }  // nil
    _objref_LightweightRTObject(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LightweightRTObject();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LightweightRTObject(const _objref_LightweightRTObject&);
    _objref_LightweightRTObject& operator = (const _objref_LightweightRTObject&);
    // not implemented

    friend class LightweightRTObject;
  };

  class _pof_LightweightRTObject : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LightweightRTObject() : _OMNI_NS(proxyObjectFactory)(LightweightRTObject::_PD_repoId) {}
    virtual ~_pof_LightweightRTObject();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LightweightRTObject :
    public virtual _impl_ComponentAction
  {
  public:
    virtual ~_impl_LightweightRTObject();

    virtual ReturnCode_t initialize() = 0;
    virtual ReturnCode_t finalize() = 0;
    virtual ::CORBA::Boolean is_alive(::RTC::ExecutionContext_ptr exec_context) = 0;
    virtual ReturnCode_t exit() = 0;
    virtual ExecutionContextHandle_t attach_context(::RTC::ExecutionContext_ptr exec_context) = 0;
    virtual ReturnCode_t detach_context(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ExecutionContext_ptr get_context(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ExecutionContextList* get_owned_contexts() = 0;
    virtual ExecutionContextList* get_participating_contexts() = 0;
    virtual ExecutionContextHandle_t get_context_handle(::RTC::ExecutionContext_ptr cxt) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LightweightRTObject;

  enum ExecutionKind { PERIODIC, EVENT_DRIVEN, OTHER /*, __max_ExecutionKind=0xffffffff */ };
  typedef ExecutionKind& ExecutionKind_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionKind;

#ifndef __RTC_mExecutionContext__
#define __RTC_mExecutionContext__

  class ExecutionContext;
  class _objref_ExecutionContext;
  class _impl_ExecutionContext;
  
  typedef _objref_ExecutionContext* ExecutionContext_ptr;
  typedef ExecutionContext_ptr ExecutionContextRef;

  class ExecutionContext_Helper {
  public:
    typedef ExecutionContext_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ExecutionContext, ExecutionContext_Helper> ExecutionContext_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ExecutionContext,ExecutionContext_Helper > ExecutionContext_out;

#endif

  // interface ExecutionContext
  class ExecutionContext {
  public:
    // Declarations for this interface type.
    typedef ExecutionContext_ptr _ptr_type;
    typedef ExecutionContext_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ExecutionContext :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean is_running();
    ReturnCode_t start();
    ReturnCode_t stop();
    ::CORBA::Double get_rate();
    ReturnCode_t set_rate(::CORBA::Double rate);
    ReturnCode_t add_component(::RTC::LightweightRTObject_ptr comp);
    ReturnCode_t remove_component(::RTC::LightweightRTObject_ptr comp);
    ReturnCode_t activate_component(::RTC::LightweightRTObject_ptr comp);
    ReturnCode_t deactivate_component(::RTC::LightweightRTObject_ptr comp);
    ReturnCode_t reset_component(::RTC::LightweightRTObject_ptr comp);
    LifeCycleState get_component_state(::RTC::LightweightRTObject_ptr comp);
    ExecutionKind get_kind();

    inline _objref_ExecutionContext()  { _PR_setobj(0); }  // nil
    _objref_ExecutionContext(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ExecutionContext();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ExecutionContext(const _objref_ExecutionContext&);
    _objref_ExecutionContext& operator = (const _objref_ExecutionContext&);
    // not implemented

    friend class ExecutionContext;
  };

  class _pof_ExecutionContext : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ExecutionContext() : _OMNI_NS(proxyObjectFactory)(ExecutionContext::_PD_repoId) {}
    virtual ~_pof_ExecutionContext();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ExecutionContext :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ExecutionContext();

    virtual ::CORBA::Boolean is_running() = 0;
    virtual ReturnCode_t start() = 0;
    virtual ReturnCode_t stop() = 0;
    virtual ::CORBA::Double get_rate() = 0;
    virtual ReturnCode_t set_rate(::CORBA::Double rate) = 0;
    virtual ReturnCode_t add_component(::RTC::LightweightRTObject_ptr comp) = 0;
    virtual ReturnCode_t remove_component(::RTC::LightweightRTObject_ptr comp) = 0;
    virtual ReturnCode_t activate_component(::RTC::LightweightRTObject_ptr comp) = 0;
    virtual ReturnCode_t deactivate_component(::RTC::LightweightRTObject_ptr comp) = 0;
    virtual ReturnCode_t reset_component(::RTC::LightweightRTObject_ptr comp) = 0;
    virtual LifeCycleState get_component_state(::RTC::LightweightRTObject_ptr comp) = 0;
    virtual ExecutionKind get_kind() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionContext;

#ifndef __RTC_mDataFlowComponentAction__
#define __RTC_mDataFlowComponentAction__

  class DataFlowComponentAction;
  class _objref_DataFlowComponentAction;
  class _impl_DataFlowComponentAction;
  
  typedef _objref_DataFlowComponentAction* DataFlowComponentAction_ptr;
  typedef DataFlowComponentAction_ptr DataFlowComponentActionRef;

  class DataFlowComponentAction_Helper {
  public:
    typedef DataFlowComponentAction_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DataFlowComponentAction, DataFlowComponentAction_Helper> DataFlowComponentAction_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DataFlowComponentAction,DataFlowComponentAction_Helper > DataFlowComponentAction_out;

#endif

  // interface DataFlowComponentAction
  class DataFlowComponentAction {
  public:
    // Declarations for this interface type.
    typedef DataFlowComponentAction_ptr _ptr_type;
    typedef DataFlowComponentAction_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DataFlowComponentAction :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ReturnCode_t on_execute(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_state_update(::RTC::ExecutionContextHandle_t exec_handle);
    ReturnCode_t on_rate_changed(::RTC::ExecutionContextHandle_t exec_handle);

    inline _objref_DataFlowComponentAction()  { _PR_setobj(0); }  // nil
    _objref_DataFlowComponentAction(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DataFlowComponentAction();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DataFlowComponentAction(const _objref_DataFlowComponentAction&);
    _objref_DataFlowComponentAction& operator = (const _objref_DataFlowComponentAction&);
    // not implemented

    friend class DataFlowComponentAction;
  };

  class _pof_DataFlowComponentAction : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DataFlowComponentAction() : _OMNI_NS(proxyObjectFactory)(DataFlowComponentAction::_PD_repoId) {}
    virtual ~_pof_DataFlowComponentAction();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DataFlowComponentAction :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DataFlowComponentAction();

    virtual ReturnCode_t on_execute(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_state_update(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    virtual ReturnCode_t on_rate_changed(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DataFlowComponentAction;

#ifndef __RTC_mDataFlowComponent__
#define __RTC_mDataFlowComponent__

  class DataFlowComponent;
  class _objref_DataFlowComponent;
  class _impl_DataFlowComponent;
  
  typedef _objref_DataFlowComponent* DataFlowComponent_ptr;
  typedef DataFlowComponent_ptr DataFlowComponentRef;

  class DataFlowComponent_Helper {
  public:
    typedef DataFlowComponent_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DataFlowComponent, DataFlowComponent_Helper> DataFlowComponent_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DataFlowComponent,DataFlowComponent_Helper > DataFlowComponent_out;

#endif

  // interface DataFlowComponent
  class DataFlowComponent {
  public:
    // Declarations for this interface type.
    typedef DataFlowComponent_ptr _ptr_type;
    typedef DataFlowComponent_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DataFlowComponent :
    public virtual _objref_LightweightRTObject,
    public virtual _objref_DataFlowComponentAction
  {
  public:
    

    inline _objref_DataFlowComponent()  { _PR_setobj(0); }  // nil
    _objref_DataFlowComponent(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DataFlowComponent();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DataFlowComponent(const _objref_DataFlowComponent&);
    _objref_DataFlowComponent& operator = (const _objref_DataFlowComponent&);
    // not implemented

    friend class DataFlowComponent;
  };

  class _pof_DataFlowComponent : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DataFlowComponent() : _OMNI_NS(proxyObjectFactory)(DataFlowComponent::_PD_repoId) {}
    virtual ~_pof_DataFlowComponent();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DataFlowComponent :
    public virtual _impl_LightweightRTObject,
    public virtual _impl_DataFlowComponentAction
  {
  public:
    virtual ~_impl_DataFlowComponent();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DataFlowComponent;

#ifndef __RTC_mFsm__
#define __RTC_mFsm__

  class Fsm;
  class _objref_Fsm;
  class _impl_Fsm;
  
  typedef _objref_Fsm* Fsm_ptr;
  typedef Fsm_ptr FsmRef;

  class Fsm_Helper {
  public:
    typedef Fsm_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Fsm, Fsm_Helper> Fsm_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Fsm,Fsm_Helper > Fsm_out;

#endif

  // interface Fsm
  class Fsm {
  public:
    // Declarations for this interface type.
    typedef Fsm_ptr _ptr_type;
    typedef Fsm_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Fsm :
    public virtual _objref_LightweightRTObject
  {
  public:
    

    inline _objref_Fsm()  { _PR_setobj(0); }  // nil
    _objref_Fsm(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Fsm();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Fsm(const _objref_Fsm&);
    _objref_Fsm& operator = (const _objref_Fsm&);
    // not implemented

    friend class Fsm;
  };

  class _pof_Fsm : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Fsm() : _OMNI_NS(proxyObjectFactory)(Fsm::_PD_repoId) {}
    virtual ~_pof_Fsm();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Fsm :
    public virtual _impl_LightweightRTObject
  {
  public:
    virtual ~_impl_Fsm();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Fsm;

#ifndef __RTC_mFsmParticipantAction__
#define __RTC_mFsmParticipantAction__

  class FsmParticipantAction;
  class _objref_FsmParticipantAction;
  class _impl_FsmParticipantAction;
  
  typedef _objref_FsmParticipantAction* FsmParticipantAction_ptr;
  typedef FsmParticipantAction_ptr FsmParticipantActionRef;

  class FsmParticipantAction_Helper {
  public:
    typedef FsmParticipantAction_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FsmParticipantAction, FsmParticipantAction_Helper> FsmParticipantAction_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FsmParticipantAction,FsmParticipantAction_Helper > FsmParticipantAction_out;

#endif

  // interface FsmParticipantAction
  class FsmParticipantAction {
  public:
    // Declarations for this interface type.
    typedef FsmParticipantAction_ptr _ptr_type;
    typedef FsmParticipantAction_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_FsmParticipantAction :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ReturnCode_t on_action(::RTC::ExecutionContextHandle_t exec_handle);

    inline _objref_FsmParticipantAction()  { _PR_setobj(0); }  // nil
    _objref_FsmParticipantAction(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FsmParticipantAction();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FsmParticipantAction(const _objref_FsmParticipantAction&);
    _objref_FsmParticipantAction& operator = (const _objref_FsmParticipantAction&);
    // not implemented

    friend class FsmParticipantAction;
  };

  class _pof_FsmParticipantAction : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FsmParticipantAction() : _OMNI_NS(proxyObjectFactory)(FsmParticipantAction::_PD_repoId) {}
    virtual ~_pof_FsmParticipantAction();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FsmParticipantAction :
    public virtual omniServant
  {
  public:
    virtual ~_impl_FsmParticipantAction();

    virtual ReturnCode_t on_action(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FsmParticipantAction;

#ifndef __RTC_mFsmParticipant__
#define __RTC_mFsmParticipant__

  class FsmParticipant;
  class _objref_FsmParticipant;
  class _impl_FsmParticipant;
  
  typedef _objref_FsmParticipant* FsmParticipant_ptr;
  typedef FsmParticipant_ptr FsmParticipantRef;

  class FsmParticipant_Helper {
  public:
    typedef FsmParticipant_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FsmParticipant, FsmParticipant_Helper> FsmParticipant_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FsmParticipant,FsmParticipant_Helper > FsmParticipant_out;

#endif

  // interface FsmParticipant
  class FsmParticipant {
  public:
    // Declarations for this interface type.
    typedef FsmParticipant_ptr _ptr_type;
    typedef FsmParticipant_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_FsmParticipant :
    public virtual _objref_LightweightRTObject,
    public virtual _objref_FsmParticipantAction
  {
  public:
    

    inline _objref_FsmParticipant()  { _PR_setobj(0); }  // nil
    _objref_FsmParticipant(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FsmParticipant();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FsmParticipant(const _objref_FsmParticipant&);
    _objref_FsmParticipant& operator = (const _objref_FsmParticipant&);
    // not implemented

    friend class FsmParticipant;
  };

  class _pof_FsmParticipant : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FsmParticipant() : _OMNI_NS(proxyObjectFactory)(FsmParticipant::_PD_repoId) {}
    virtual ~_pof_FsmParticipant();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FsmParticipant :
    public virtual _impl_LightweightRTObject,
    public virtual _impl_FsmParticipantAction
  {
  public:
    virtual ~_impl_FsmParticipant();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FsmParticipant;

#ifndef __RTC_mMode__
#define __RTC_mMode__

  class Mode;
  class _objref_Mode;
  class _impl_Mode;
  
  typedef _objref_Mode* Mode_ptr;
  typedef Mode_ptr ModeRef;

  class Mode_Helper {
  public:
    typedef Mode_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Mode, Mode_Helper> Mode_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Mode,Mode_Helper > Mode_out;

#endif

  // interface Mode
  class Mode {
  public:
    // Declarations for this interface type.
    typedef Mode_ptr _ptr_type;
    typedef Mode_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Mode :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    

    inline _objref_Mode()  { _PR_setobj(0); }  // nil
    _objref_Mode(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Mode();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Mode(const _objref_Mode&);
    _objref_Mode& operator = (const _objref_Mode&);
    // not implemented

    friend class Mode;
  };

  class _pof_Mode : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Mode() : _OMNI_NS(proxyObjectFactory)(Mode::_PD_repoId) {}
    virtual ~_pof_Mode();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Mode :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Mode();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Mode;

#ifndef __RTC_mModeCapable__
#define __RTC_mModeCapable__

  class ModeCapable;
  class _objref_ModeCapable;
  class _impl_ModeCapable;
  
  typedef _objref_ModeCapable* ModeCapable_ptr;
  typedef ModeCapable_ptr ModeCapableRef;

  class ModeCapable_Helper {
  public:
    typedef ModeCapable_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ModeCapable, ModeCapable_Helper> ModeCapable_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ModeCapable,ModeCapable_Helper > ModeCapable_out;

#endif

  // interface ModeCapable
  class ModeCapable {
  public:
    // Declarations for this interface type.
    typedef ModeCapable_ptr _ptr_type;
    typedef ModeCapable_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ModeCapable :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    Mode_ptr get_default_mode();
    Mode_ptr get_current_mode();
    Mode_ptr get_current_mode_in_context(::RTC::ExecutionContext_ptr exec_context);
    Mode_ptr get_pending_mode();
    Mode_ptr get_pending_mode_in_context(::RTC::ExecutionContext_ptr exec_context);
    ReturnCode_t set_mode(::RTC::Mode_ptr new_mode, ::CORBA::Boolean immediate);

    inline _objref_ModeCapable()  { _PR_setobj(0); }  // nil
    _objref_ModeCapable(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ModeCapable();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ModeCapable(const _objref_ModeCapable&);
    _objref_ModeCapable& operator = (const _objref_ModeCapable&);
    // not implemented

    friend class ModeCapable;
  };

  class _pof_ModeCapable : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ModeCapable() : _OMNI_NS(proxyObjectFactory)(ModeCapable::_PD_repoId) {}
    virtual ~_pof_ModeCapable();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ModeCapable :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ModeCapable();

    virtual Mode_ptr get_default_mode() = 0;
    virtual Mode_ptr get_current_mode() = 0;
    virtual Mode_ptr get_current_mode_in_context(::RTC::ExecutionContext_ptr exec_context) = 0;
    virtual Mode_ptr get_pending_mode() = 0;
    virtual Mode_ptr get_pending_mode_in_context(::RTC::ExecutionContext_ptr exec_context) = 0;
    virtual ReturnCode_t set_mode(::RTC::Mode_ptr new_mode, ::CORBA::Boolean immediate) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ModeCapable;

#ifndef __RTC_mMultiModeComponentAction__
#define __RTC_mMultiModeComponentAction__

  class MultiModeComponentAction;
  class _objref_MultiModeComponentAction;
  class _impl_MultiModeComponentAction;
  
  typedef _objref_MultiModeComponentAction* MultiModeComponentAction_ptr;
  typedef MultiModeComponentAction_ptr MultiModeComponentActionRef;

  class MultiModeComponentAction_Helper {
  public:
    typedef MultiModeComponentAction_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_MultiModeComponentAction, MultiModeComponentAction_Helper> MultiModeComponentAction_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_MultiModeComponentAction,MultiModeComponentAction_Helper > MultiModeComponentAction_out;

#endif

  // interface MultiModeComponentAction
  class MultiModeComponentAction {
  public:
    // Declarations for this interface type.
    typedef MultiModeComponentAction_ptr _ptr_type;
    typedef MultiModeComponentAction_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_MultiModeComponentAction :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ReturnCode_t on_mode_changed(::RTC::ExecutionContextHandle_t exec_handle);

    inline _objref_MultiModeComponentAction()  { _PR_setobj(0); }  // nil
    _objref_MultiModeComponentAction(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_MultiModeComponentAction();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_MultiModeComponentAction(const _objref_MultiModeComponentAction&);
    _objref_MultiModeComponentAction& operator = (const _objref_MultiModeComponentAction&);
    // not implemented

    friend class MultiModeComponentAction;
  };

  class _pof_MultiModeComponentAction : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_MultiModeComponentAction() : _OMNI_NS(proxyObjectFactory)(MultiModeComponentAction::_PD_repoId) {}
    virtual ~_pof_MultiModeComponentAction();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_MultiModeComponentAction :
    public virtual omniServant
  {
  public:
    virtual ~_impl_MultiModeComponentAction();

    virtual ReturnCode_t on_mode_changed(::RTC::ExecutionContextHandle_t exec_handle) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MultiModeComponentAction;

#ifndef __RTC_mMultiModeObject__
#define __RTC_mMultiModeObject__

  class MultiModeObject;
  class _objref_MultiModeObject;
  class _impl_MultiModeObject;
  
  typedef _objref_MultiModeObject* MultiModeObject_ptr;
  typedef MultiModeObject_ptr MultiModeObjectRef;

  class MultiModeObject_Helper {
  public:
    typedef MultiModeObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_MultiModeObject, MultiModeObject_Helper> MultiModeObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_MultiModeObject,MultiModeObject_Helper > MultiModeObject_out;

#endif

  // interface MultiModeObject
  class MultiModeObject {
  public:
    // Declarations for this interface type.
    typedef MultiModeObject_ptr _ptr_type;
    typedef MultiModeObject_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_MultiModeObject :
    public virtual _objref_LightweightRTObject,
    public virtual _objref_ModeCapable,
    public virtual _objref_MultiModeComponentAction
  {
  public:
    

    inline _objref_MultiModeObject()  { _PR_setobj(0); }  // nil
    _objref_MultiModeObject(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_MultiModeObject();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_MultiModeObject(const _objref_MultiModeObject&);
    _objref_MultiModeObject& operator = (const _objref_MultiModeObject&);
    // not implemented

    friend class MultiModeObject;
  };

  class _pof_MultiModeObject : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_MultiModeObject() : _OMNI_NS(proxyObjectFactory)(MultiModeObject::_PD_repoId) {}
    virtual ~_pof_MultiModeObject();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_MultiModeObject :
    public virtual _impl_LightweightRTObject,
    public virtual _impl_ModeCapable,
    public virtual _impl_MultiModeComponentAction
  {
  public:
    virtual ~_impl_MultiModeObject();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MultiModeObject;

#ifndef __RTC_mRTObject__
#define __RTC_mRTObject__

  class RTObject;
  class _objref_RTObject;
  class _impl_RTObject;
  
  typedef _objref_RTObject* RTObject_ptr;
  typedef RTObject_ptr RTObjectRef;

  class RTObject_Helper {
  public:
    typedef RTObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_RTObject, RTObject_Helper> RTObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_RTObject,RTObject_Helper > RTObject_out;

#endif

  enum PortInterfacePolarity { PROVIDED, REQUIRED /*, __max_PortInterfacePolarity=0xffffffff */ };
  typedef PortInterfacePolarity& PortInterfacePolarity_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortInterfacePolarity;

  struct PortInterfaceProfile {
    typedef _CORBA_ConstrType_Variable_Var<PortInterfaceProfile> _var_type;

    
    ::CORBA::String_member instance_name;

    ::CORBA::String_member type_name;

    PortInterfacePolarity polarity;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PortInterfaceProfile::_var_type PortInterfaceProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PortInterfaceProfile,PortInterfaceProfile_var > PortInterfaceProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortInterfaceProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortInterfaceProfileList;

  class PortInterfaceProfileList_var;

  class PortInterfaceProfileList : public _CORBA_Unbounded_Sequence< PortInterfaceProfile >  {
  public:
    typedef PortInterfaceProfileList_var _var_type;
    inline PortInterfaceProfileList() {}
    inline PortInterfaceProfileList(const PortInterfaceProfileList& _s)
      : _CORBA_Unbounded_Sequence< PortInterfaceProfile > (_s) {}

    inline PortInterfaceProfileList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PortInterfaceProfile > (_max) {}
    inline PortInterfaceProfileList(_CORBA_ULong _max, _CORBA_ULong _len, PortInterfaceProfile* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PortInterfaceProfile > (_max, _len, _val, _rel) {}

  

    inline PortInterfaceProfileList& operator = (const PortInterfaceProfileList& _s) {
      _CORBA_Unbounded_Sequence< PortInterfaceProfile > ::operator=(_s);
      return *this;
    }
  };

  class PortInterfaceProfileList_out;

  class PortInterfaceProfileList_var {
  public:
    inline PortInterfaceProfileList_var() : _pd_seq(0) {}
    inline PortInterfaceProfileList_var(PortInterfaceProfileList* _s) : _pd_seq(_s) {}
    inline PortInterfaceProfileList_var(const PortInterfaceProfileList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PortInterfaceProfileList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PortInterfaceProfileList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PortInterfaceProfileList_var& operator = (PortInterfaceProfileList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PortInterfaceProfileList_var& operator = (const PortInterfaceProfileList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PortInterfaceProfileList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline PortInterfaceProfile& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PortInterfaceProfileList* operator -> () { return _pd_seq; }
    inline const PortInterfaceProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PortInterfaceProfileList& () const { return *_pd_seq; }
#else
    inline operator const PortInterfaceProfileList& () const { return *_pd_seq; }
    inline operator PortInterfaceProfileList& () { return *_pd_seq; }
#endif
      
    inline const PortInterfaceProfileList& in() const { return *_pd_seq; }
    inline PortInterfaceProfileList&       inout()    { return *_pd_seq; }
    inline PortInterfaceProfileList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PortInterfaceProfileList* _retn() { PortInterfaceProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PortInterfaceProfileList_out;
    
  private:
    PortInterfaceProfileList* _pd_seq;
  };

  class PortInterfaceProfileList_out {
  public:
    inline PortInterfaceProfileList_out(PortInterfaceProfileList*& _s) : _data(_s) { _data = 0; }
    inline PortInterfaceProfileList_out(PortInterfaceProfileList_var& _s)
      : _data(_s._pd_seq) { _s = (PortInterfaceProfileList*) 0; }
    inline PortInterfaceProfileList_out(const PortInterfaceProfileList_out& _s) : _data(_s._data) {}
    inline PortInterfaceProfileList_out& operator = (const PortInterfaceProfileList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PortInterfaceProfileList_out& operator = (PortInterfaceProfileList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PortInterfaceProfileList*&()  { return _data; }
    inline PortInterfaceProfileList*& ptr()       { return _data; }
    inline PortInterfaceProfileList* operator->() { return _data; }

    inline PortInterfaceProfile& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PortInterfaceProfileList*& _data;

  private:
    PortInterfaceProfileList_out();
    PortInterfaceProfileList_out& operator=(const PortInterfaceProfileList_var&);
  };

#ifndef __RTC_mPortService__
#define __RTC_mPortService__

  class PortService;
  class _objref_PortService;
  class _impl_PortService;
  
  typedef _objref_PortService* PortService_ptr;
  typedef PortService_ptr PortServiceRef;

  class PortService_Helper {
  public:
    typedef PortService_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PortService, PortService_Helper> PortService_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PortService,PortService_Helper > PortService_out;

#endif

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortServiceList;

  class PortServiceList_var;

  class PortServiceList : public _CORBA_Unbounded_Sequence_ObjRef< _objref_PortService, _CORBA_ObjRef_Element< _objref_PortService, PortService_Helper> , PortService_Helper >  {
  public:
    typedef PortServiceList_var _var_type;
    inline PortServiceList() {}
    inline PortServiceList(const PortServiceList& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_PortService, _CORBA_ObjRef_Element< _objref_PortService, PortService_Helper> , PortService_Helper > (_s) {}

    inline PortServiceList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_PortService, _CORBA_ObjRef_Element< _objref_PortService, PortService_Helper> , PortService_Helper > (_max) {}
    inline PortServiceList(_CORBA_ULong _max, _CORBA_ULong _len, PortService_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_PortService, _CORBA_ObjRef_Element< _objref_PortService, PortService_Helper> , PortService_Helper > (_max, _len, _val, _rel) {}

  

    inline PortServiceList& operator = (const PortServiceList& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_PortService, _CORBA_ObjRef_Element< _objref_PortService, PortService_Helper> , PortService_Helper > ::operator=(_s);
      return *this;
    }
  };

  class PortServiceList_out;

  class PortServiceList_var {
  public:
    inline PortServiceList_var() : _pd_seq(0) {}
    inline PortServiceList_var(PortServiceList* _s) : _pd_seq(_s) {}
    inline PortServiceList_var(const PortServiceList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PortServiceList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PortServiceList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PortServiceList_var& operator = (PortServiceList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PortServiceList_var& operator = (const PortServiceList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PortServiceList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_PortService, PortService_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PortServiceList* operator -> () { return _pd_seq; }
    inline const PortServiceList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PortServiceList& () const { return *_pd_seq; }
#else
    inline operator const PortServiceList& () const { return *_pd_seq; }
    inline operator PortServiceList& () { return *_pd_seq; }
#endif
      
    inline const PortServiceList& in() const { return *_pd_seq; }
    inline PortServiceList&       inout()    { return *_pd_seq; }
    inline PortServiceList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PortServiceList* _retn() { PortServiceList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PortServiceList_out;
    
  private:
    PortServiceList* _pd_seq;
  };

  class PortServiceList_out {
  public:
    inline PortServiceList_out(PortServiceList*& _s) : _data(_s) { _data = 0; }
    inline PortServiceList_out(PortServiceList_var& _s)
      : _data(_s._pd_seq) { _s = (PortServiceList*) 0; }
    inline PortServiceList_out(const PortServiceList_out& _s) : _data(_s._data) {}
    inline PortServiceList_out& operator = (const PortServiceList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PortServiceList_out& operator = (PortServiceList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PortServiceList*&()  { return _data; }
    inline PortServiceList*& ptr()       { return _data; }
    inline PortServiceList* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_PortService, PortService_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PortServiceList*& _data;

  private:
    PortServiceList_out();
    PortServiceList_out& operator=(const PortServiceList_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RTCList;

  class RTCList_var;

  class RTCList : public _CORBA_Unbounded_Sequence_ObjRef< _objref_RTObject, _CORBA_ObjRef_Element< _objref_RTObject, RTObject_Helper> , RTObject_Helper >  {
  public:
    typedef RTCList_var _var_type;
    inline RTCList() {}
    inline RTCList(const RTCList& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_RTObject, _CORBA_ObjRef_Element< _objref_RTObject, RTObject_Helper> , RTObject_Helper > (_s) {}

    inline RTCList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_RTObject, _CORBA_ObjRef_Element< _objref_RTObject, RTObject_Helper> , RTObject_Helper > (_max) {}
    inline RTCList(_CORBA_ULong _max, _CORBA_ULong _len, RTObject_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_RTObject, _CORBA_ObjRef_Element< _objref_RTObject, RTObject_Helper> , RTObject_Helper > (_max, _len, _val, _rel) {}

  

    inline RTCList& operator = (const RTCList& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_RTObject, _CORBA_ObjRef_Element< _objref_RTObject, RTObject_Helper> , RTObject_Helper > ::operator=(_s);
      return *this;
    }
  };

  class RTCList_out;

  class RTCList_var {
  public:
    inline RTCList_var() : _pd_seq(0) {}
    inline RTCList_var(RTCList* _s) : _pd_seq(_s) {}
    inline RTCList_var(const RTCList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new RTCList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~RTCList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline RTCList_var& operator = (RTCList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline RTCList_var& operator = (const RTCList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new RTCList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_RTObject, RTObject_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline RTCList* operator -> () { return _pd_seq; }
    inline const RTCList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator RTCList& () const { return *_pd_seq; }
#else
    inline operator const RTCList& () const { return *_pd_seq; }
    inline operator RTCList& () { return *_pd_seq; }
#endif
      
    inline const RTCList& in() const { return *_pd_seq; }
    inline RTCList&       inout()    { return *_pd_seq; }
    inline RTCList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline RTCList* _retn() { RTCList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class RTCList_out;
    
  private:
    RTCList* _pd_seq;
  };

  class RTCList_out {
  public:
    inline RTCList_out(RTCList*& _s) : _data(_s) { _data = 0; }
    inline RTCList_out(RTCList_var& _s)
      : _data(_s._pd_seq) { _s = (RTCList*) 0; }
    inline RTCList_out(const RTCList_out& _s) : _data(_s._data) {}
    inline RTCList_out& operator = (const RTCList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline RTCList_out& operator = (RTCList* _s) {
      _data = _s;
      return *this;
    }
    inline operator RTCList*&()  { return _data; }
    inline RTCList*& ptr()       { return _data; }
    inline RTCList* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_RTObject, RTObject_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    RTCList*& _data;

  private:
    RTCList_out();
    RTCList_out& operator=(const RTCList_var&);
  };

  struct ConnectorProfile {
    typedef _CORBA_ConstrType_Variable_Var<ConnectorProfile> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::String_member connector_id;

    PortServiceList ports;

    NVList properties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ConnectorProfile::_var_type ConnectorProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ConnectorProfile,ConnectorProfile_var > ConnectorProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectorProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectorProfileList;

  class ConnectorProfileList_var;

  class ConnectorProfileList : public _CORBA_Unbounded_Sequence< ConnectorProfile >  {
  public:
    typedef ConnectorProfileList_var _var_type;
    inline ConnectorProfileList() {}
    inline ConnectorProfileList(const ConnectorProfileList& _s)
      : _CORBA_Unbounded_Sequence< ConnectorProfile > (_s) {}

    inline ConnectorProfileList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ConnectorProfile > (_max) {}
    inline ConnectorProfileList(_CORBA_ULong _max, _CORBA_ULong _len, ConnectorProfile* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ConnectorProfile > (_max, _len, _val, _rel) {}

  

    inline ConnectorProfileList& operator = (const ConnectorProfileList& _s) {
      _CORBA_Unbounded_Sequence< ConnectorProfile > ::operator=(_s);
      return *this;
    }
  };

  class ConnectorProfileList_out;

  class ConnectorProfileList_var {
  public:
    inline ConnectorProfileList_var() : _pd_seq(0) {}
    inline ConnectorProfileList_var(ConnectorProfileList* _s) : _pd_seq(_s) {}
    inline ConnectorProfileList_var(const ConnectorProfileList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ConnectorProfileList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ConnectorProfileList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ConnectorProfileList_var& operator = (ConnectorProfileList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ConnectorProfileList_var& operator = (const ConnectorProfileList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ConnectorProfileList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ConnectorProfile& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ConnectorProfileList* operator -> () { return _pd_seq; }
    inline const ConnectorProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ConnectorProfileList& () const { return *_pd_seq; }
#else
    inline operator const ConnectorProfileList& () const { return *_pd_seq; }
    inline operator ConnectorProfileList& () { return *_pd_seq; }
#endif
      
    inline const ConnectorProfileList& in() const { return *_pd_seq; }
    inline ConnectorProfileList&       inout()    { return *_pd_seq; }
    inline ConnectorProfileList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ConnectorProfileList* _retn() { ConnectorProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ConnectorProfileList_out;
    
  private:
    ConnectorProfileList* _pd_seq;
  };

  class ConnectorProfileList_out {
  public:
    inline ConnectorProfileList_out(ConnectorProfileList*& _s) : _data(_s) { _data = 0; }
    inline ConnectorProfileList_out(ConnectorProfileList_var& _s)
      : _data(_s._pd_seq) { _s = (ConnectorProfileList*) 0; }
    inline ConnectorProfileList_out(const ConnectorProfileList_out& _s) : _data(_s._data) {}
    inline ConnectorProfileList_out& operator = (const ConnectorProfileList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ConnectorProfileList_out& operator = (ConnectorProfileList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ConnectorProfileList*&()  { return _data; }
    inline ConnectorProfileList*& ptr()       { return _data; }
    inline ConnectorProfileList* operator->() { return _data; }

    inline ConnectorProfile& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ConnectorProfileList*& _data;

  private:
    ConnectorProfileList_out();
    ConnectorProfileList_out& operator=(const ConnectorProfileList_var&);
  };

  struct PortProfile {
    typedef _CORBA_ConstrType_Variable_Var<PortProfile> _var_type;

    
    ::CORBA::String_member name;

    PortInterfaceProfileList interfaces;

    _CORBA_ObjRef_Member< _objref_PortService, PortService_Helper>  port_ref;

    ConnectorProfileList connector_profiles;

    _CORBA_ObjRef_Member< _objref_RTObject, RTObject_Helper>  owner;

    NVList properties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PortProfile::_var_type PortProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PortProfile,PortProfile_var > PortProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortProfileList;

  class PortProfileList_var;

  class PortProfileList : public _CORBA_Unbounded_Sequence< PortProfile >  {
  public:
    typedef PortProfileList_var _var_type;
    inline PortProfileList() {}
    inline PortProfileList(const PortProfileList& _s)
      : _CORBA_Unbounded_Sequence< PortProfile > (_s) {}

    inline PortProfileList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PortProfile > (_max) {}
    inline PortProfileList(_CORBA_ULong _max, _CORBA_ULong _len, PortProfile* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PortProfile > (_max, _len, _val, _rel) {}

  

    inline PortProfileList& operator = (const PortProfileList& _s) {
      _CORBA_Unbounded_Sequence< PortProfile > ::operator=(_s);
      return *this;
    }
  };

  class PortProfileList_out;

  class PortProfileList_var {
  public:
    inline PortProfileList_var() : _pd_seq(0) {}
    inline PortProfileList_var(PortProfileList* _s) : _pd_seq(_s) {}
    inline PortProfileList_var(const PortProfileList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PortProfileList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PortProfileList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PortProfileList_var& operator = (PortProfileList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PortProfileList_var& operator = (const PortProfileList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PortProfileList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline PortProfile& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PortProfileList* operator -> () { return _pd_seq; }
    inline const PortProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PortProfileList& () const { return *_pd_seq; }
#else
    inline operator const PortProfileList& () const { return *_pd_seq; }
    inline operator PortProfileList& () { return *_pd_seq; }
#endif
      
    inline const PortProfileList& in() const { return *_pd_seq; }
    inline PortProfileList&       inout()    { return *_pd_seq; }
    inline PortProfileList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PortProfileList* _retn() { PortProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PortProfileList_out;
    
  private:
    PortProfileList* _pd_seq;
  };

  class PortProfileList_out {
  public:
    inline PortProfileList_out(PortProfileList*& _s) : _data(_s) { _data = 0; }
    inline PortProfileList_out(PortProfileList_var& _s)
      : _data(_s._pd_seq) { _s = (PortProfileList*) 0; }
    inline PortProfileList_out(const PortProfileList_out& _s) : _data(_s._data) {}
    inline PortProfileList_out& operator = (const PortProfileList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PortProfileList_out& operator = (PortProfileList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PortProfileList*&()  { return _data; }
    inline PortProfileList*& ptr()       { return _data; }
    inline PortProfileList* operator->() { return _data; }

    inline PortProfile& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PortProfileList*& _data;

  private:
    PortProfileList_out();
    PortProfileList_out& operator=(const PortProfileList_var&);
  };

  struct ExecutionContextProfile {
    typedef _CORBA_ConstrType_Variable_Var<ExecutionContextProfile> _var_type;

    
    ExecutionKind kind;

    ::CORBA::Double rate;

    _CORBA_ObjRef_Member< _objref_RTObject, RTObject_Helper>  owner;

    RTCList participants;

    NVList properties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ExecutionContextProfile::_var_type ExecutionContextProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ExecutionContextProfile,ExecutionContextProfile_var > ExecutionContextProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionContextProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionContextProfileList;

  class ExecutionContextProfileList_var;

  class ExecutionContextProfileList : public _CORBA_Unbounded_Sequence< ExecutionContextProfile >  {
  public:
    typedef ExecutionContextProfileList_var _var_type;
    inline ExecutionContextProfileList() {}
    inline ExecutionContextProfileList(const ExecutionContextProfileList& _s)
      : _CORBA_Unbounded_Sequence< ExecutionContextProfile > (_s) {}

    inline ExecutionContextProfileList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ExecutionContextProfile > (_max) {}
    inline ExecutionContextProfileList(_CORBA_ULong _max, _CORBA_ULong _len, ExecutionContextProfile* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ExecutionContextProfile > (_max, _len, _val, _rel) {}

  

    inline ExecutionContextProfileList& operator = (const ExecutionContextProfileList& _s) {
      _CORBA_Unbounded_Sequence< ExecutionContextProfile > ::operator=(_s);
      return *this;
    }
  };

  class ExecutionContextProfileList_out;

  class ExecutionContextProfileList_var {
  public:
    inline ExecutionContextProfileList_var() : _pd_seq(0) {}
    inline ExecutionContextProfileList_var(ExecutionContextProfileList* _s) : _pd_seq(_s) {}
    inline ExecutionContextProfileList_var(const ExecutionContextProfileList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ExecutionContextProfileList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ExecutionContextProfileList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ExecutionContextProfileList_var& operator = (ExecutionContextProfileList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ExecutionContextProfileList_var& operator = (const ExecutionContextProfileList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ExecutionContextProfileList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ExecutionContextProfile& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ExecutionContextProfileList* operator -> () { return _pd_seq; }
    inline const ExecutionContextProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ExecutionContextProfileList& () const { return *_pd_seq; }
#else
    inline operator const ExecutionContextProfileList& () const { return *_pd_seq; }
    inline operator ExecutionContextProfileList& () { return *_pd_seq; }
#endif
      
    inline const ExecutionContextProfileList& in() const { return *_pd_seq; }
    inline ExecutionContextProfileList&       inout()    { return *_pd_seq; }
    inline ExecutionContextProfileList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ExecutionContextProfileList* _retn() { ExecutionContextProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ExecutionContextProfileList_out;
    
  private:
    ExecutionContextProfileList* _pd_seq;
  };

  class ExecutionContextProfileList_out {
  public:
    inline ExecutionContextProfileList_out(ExecutionContextProfileList*& _s) : _data(_s) { _data = 0; }
    inline ExecutionContextProfileList_out(ExecutionContextProfileList_var& _s)
      : _data(_s._pd_seq) { _s = (ExecutionContextProfileList*) 0; }
    inline ExecutionContextProfileList_out(const ExecutionContextProfileList_out& _s) : _data(_s._data) {}
    inline ExecutionContextProfileList_out& operator = (const ExecutionContextProfileList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ExecutionContextProfileList_out& operator = (ExecutionContextProfileList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ExecutionContextProfileList*&()  { return _data; }
    inline ExecutionContextProfileList*& ptr()       { return _data; }
    inline ExecutionContextProfileList* operator->() { return _data; }

    inline ExecutionContextProfile& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ExecutionContextProfileList*& _data;

  private:
    ExecutionContextProfileList_out();
    ExecutionContextProfileList_out& operator=(const ExecutionContextProfileList_var&);
  };

#ifndef __RTC_mFsmObject__
#define __RTC_mFsmObject__

  class FsmObject;
  class _objref_FsmObject;
  class _impl_FsmObject;
  
  typedef _objref_FsmObject* FsmObject_ptr;
  typedef FsmObject_ptr FsmObjectRef;

  class FsmObject_Helper {
  public:
    typedef FsmObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FsmObject, FsmObject_Helper> FsmObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FsmObject,FsmObject_Helper > FsmObject_out;

#endif

  // interface FsmObject
  class FsmObject {
  public:
    // Declarations for this interface type.
    typedef FsmObject_ptr _ptr_type;
    typedef FsmObject_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_FsmObject :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ReturnCode_t send_stimulus(const char* message, ::RTC::ExecutionContextHandle_t exec_handle);

    inline _objref_FsmObject()  { _PR_setobj(0); }  // nil
    _objref_FsmObject(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FsmObject();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FsmObject(const _objref_FsmObject&);
    _objref_FsmObject& operator = (const _objref_FsmObject&);
    // not implemented

    friend class FsmObject;
  };

  class _pof_FsmObject : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FsmObject() : _OMNI_NS(proxyObjectFactory)(FsmObject::_PD_repoId) {}
    virtual ~_pof_FsmObject();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FsmObject :
    public virtual omniServant
  {
  public:
    virtual ~_impl_FsmObject();

    virtual ReturnCode_t send_stimulus(const char* message, ::RTC::ExecutionContextHandle_t exec_handle) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FsmObject;

  struct FsmBehaviorProfile {
    typedef _CORBA_ConstrType_Variable_Var<FsmBehaviorProfile> _var_type;

    
    _CORBA_ObjRef_Member< _objref_FsmParticipantAction, FsmParticipantAction_Helper>  action_component;

    ::CORBA::String_member id;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FsmBehaviorProfile::_var_type FsmBehaviorProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FsmBehaviorProfile,FsmBehaviorProfile_var > FsmBehaviorProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FsmBehaviorProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FsmBehaviorProfileList;

  class FsmBehaviorProfileList_var;

  class FsmBehaviorProfileList : public _CORBA_Unbounded_Sequence< FsmBehaviorProfile >  {
  public:
    typedef FsmBehaviorProfileList_var _var_type;
    inline FsmBehaviorProfileList() {}
    inline FsmBehaviorProfileList(const FsmBehaviorProfileList& _s)
      : _CORBA_Unbounded_Sequence< FsmBehaviorProfile > (_s) {}

    inline FsmBehaviorProfileList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< FsmBehaviorProfile > (_max) {}
    inline FsmBehaviorProfileList(_CORBA_ULong _max, _CORBA_ULong _len, FsmBehaviorProfile* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< FsmBehaviorProfile > (_max, _len, _val, _rel) {}

  

    inline FsmBehaviorProfileList& operator = (const FsmBehaviorProfileList& _s) {
      _CORBA_Unbounded_Sequence< FsmBehaviorProfile > ::operator=(_s);
      return *this;
    }
  };

  class FsmBehaviorProfileList_out;

  class FsmBehaviorProfileList_var {
  public:
    inline FsmBehaviorProfileList_var() : _pd_seq(0) {}
    inline FsmBehaviorProfileList_var(FsmBehaviorProfileList* _s) : _pd_seq(_s) {}
    inline FsmBehaviorProfileList_var(const FsmBehaviorProfileList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new FsmBehaviorProfileList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~FsmBehaviorProfileList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline FsmBehaviorProfileList_var& operator = (FsmBehaviorProfileList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FsmBehaviorProfileList_var& operator = (const FsmBehaviorProfileList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new FsmBehaviorProfileList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline FsmBehaviorProfile& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FsmBehaviorProfileList* operator -> () { return _pd_seq; }
    inline const FsmBehaviorProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FsmBehaviorProfileList& () const { return *_pd_seq; }
#else
    inline operator const FsmBehaviorProfileList& () const { return *_pd_seq; }
    inline operator FsmBehaviorProfileList& () { return *_pd_seq; }
#endif
      
    inline const FsmBehaviorProfileList& in() const { return *_pd_seq; }
    inline FsmBehaviorProfileList&       inout()    { return *_pd_seq; }
    inline FsmBehaviorProfileList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FsmBehaviorProfileList* _retn() { FsmBehaviorProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FsmBehaviorProfileList_out;
    
  private:
    FsmBehaviorProfileList* _pd_seq;
  };

  class FsmBehaviorProfileList_out {
  public:
    inline FsmBehaviorProfileList_out(FsmBehaviorProfileList*& _s) : _data(_s) { _data = 0; }
    inline FsmBehaviorProfileList_out(FsmBehaviorProfileList_var& _s)
      : _data(_s._pd_seq) { _s = (FsmBehaviorProfileList*) 0; }
    inline FsmBehaviorProfileList_out(const FsmBehaviorProfileList_out& _s) : _data(_s._data) {}
    inline FsmBehaviorProfileList_out& operator = (const FsmBehaviorProfileList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FsmBehaviorProfileList_out& operator = (FsmBehaviorProfileList* _s) {
      _data = _s;
      return *this;
    }
    inline operator FsmBehaviorProfileList*&()  { return _data; }
    inline FsmBehaviorProfileList*& ptr()       { return _data; }
    inline FsmBehaviorProfileList* operator->() { return _data; }

    inline FsmBehaviorProfile& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FsmBehaviorProfileList*& _data;

  private:
    FsmBehaviorProfileList_out();
    FsmBehaviorProfileList_out& operator=(const FsmBehaviorProfileList_var&);
  };

  struct FsmProfile {
    typedef _CORBA_ConstrType_Variable_Var<FsmProfile> _var_type;

    
    FsmBehaviorProfileList behavior_profiles;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FsmProfile::_var_type FsmProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FsmProfile,FsmProfile_var > FsmProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FsmProfile;

#ifndef __RTC_mFsmService__
#define __RTC_mFsmService__

  class FsmService;
  class _objref_FsmService;
  class _impl_FsmService;
  
  typedef _objref_FsmService* FsmService_ptr;
  typedef FsmService_ptr FsmServiceRef;

  class FsmService_Helper {
  public:
    typedef FsmService_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FsmService, FsmService_Helper> FsmService_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FsmService,FsmService_Helper > FsmService_out;

#endif

  // interface FsmService
  class FsmService {
  public:
    // Declarations for this interface type.
    typedef FsmService_ptr _ptr_type;
    typedef FsmService_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_FsmService :
    public virtual SDOPackage::_objref_SDOService
  {
  public:
    FsmProfile* get_fsm_profile();
    ReturnCode_t set_fsm_profile(const ::RTC::FsmProfile& fsm_profile);

    inline _objref_FsmService()  { _PR_setobj(0); }  // nil
    _objref_FsmService(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FsmService();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FsmService(const _objref_FsmService&);
    _objref_FsmService& operator = (const _objref_FsmService&);
    // not implemented

    friend class FsmService;
  };

  class _pof_FsmService : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FsmService() : _OMNI_NS(proxyObjectFactory)(FsmService::_PD_repoId) {}
    virtual ~_pof_FsmService();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FsmService :
    public virtual SDOPackage::_impl_SDOService
  {
  public:
    virtual ~_impl_FsmService();

    virtual FsmProfile* get_fsm_profile() = 0;
    virtual ReturnCode_t set_fsm_profile(const ::RTC::FsmProfile& fsm_profile) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FsmService;

  struct ComponentProfile {
    typedef _CORBA_ConstrType_Variable_Var<ComponentProfile> _var_type;

    
    ::CORBA::String_member instance_name;

    ::CORBA::String_member type_name;

    ::CORBA::String_member description;

    ::CORBA::String_member version;

    ::CORBA::String_member vendor;

    ::CORBA::String_member category;

    PortProfileList port_profiles;

    _CORBA_ObjRef_Member< _objref_RTObject, RTObject_Helper>  parent;

    NVList properties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ComponentProfile::_var_type ComponentProfile_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentProfile,ComponentProfile_var > ComponentProfile_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentProfileList;

  class ComponentProfileList_var;

  class ComponentProfileList : public _CORBA_Unbounded_Sequence< ComponentProfile >  {
  public:
    typedef ComponentProfileList_var _var_type;
    inline ComponentProfileList() {}
    inline ComponentProfileList(const ComponentProfileList& _s)
      : _CORBA_Unbounded_Sequence< ComponentProfile > (_s) {}

    inline ComponentProfileList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ComponentProfile > (_max) {}
    inline ComponentProfileList(_CORBA_ULong _max, _CORBA_ULong _len, ComponentProfile* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ComponentProfile > (_max, _len, _val, _rel) {}

  

    inline ComponentProfileList& operator = (const ComponentProfileList& _s) {
      _CORBA_Unbounded_Sequence< ComponentProfile > ::operator=(_s);
      return *this;
    }
  };

  class ComponentProfileList_out;

  class ComponentProfileList_var {
  public:
    inline ComponentProfileList_var() : _pd_seq(0) {}
    inline ComponentProfileList_var(ComponentProfileList* _s) : _pd_seq(_s) {}
    inline ComponentProfileList_var(const ComponentProfileList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ComponentProfileList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ComponentProfileList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ComponentProfileList_var& operator = (ComponentProfileList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ComponentProfileList_var& operator = (const ComponentProfileList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ComponentProfileList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ComponentProfile& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ComponentProfileList* operator -> () { return _pd_seq; }
    inline const ComponentProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ComponentProfileList& () const { return *_pd_seq; }
#else
    inline operator const ComponentProfileList& () const { return *_pd_seq; }
    inline operator ComponentProfileList& () { return *_pd_seq; }
#endif
      
    inline const ComponentProfileList& in() const { return *_pd_seq; }
    inline ComponentProfileList&       inout()    { return *_pd_seq; }
    inline ComponentProfileList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ComponentProfileList* _retn() { ComponentProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ComponentProfileList_out;
    
  private:
    ComponentProfileList* _pd_seq;
  };

  class ComponentProfileList_out {
  public:
    inline ComponentProfileList_out(ComponentProfileList*& _s) : _data(_s) { _data = 0; }
    inline ComponentProfileList_out(ComponentProfileList_var& _s)
      : _data(_s._pd_seq) { _s = (ComponentProfileList*) 0; }
    inline ComponentProfileList_out(const ComponentProfileList_out& _s) : _data(_s._data) {}
    inline ComponentProfileList_out& operator = (const ComponentProfileList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ComponentProfileList_out& operator = (ComponentProfileList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ComponentProfileList*&()  { return _data; }
    inline ComponentProfileList*& ptr()       { return _data; }
    inline ComponentProfileList* operator->() { return _data; }

    inline ComponentProfile& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ComponentProfileList*& _data;

  private:
    ComponentProfileList_out();
    ComponentProfileList_out& operator=(const ComponentProfileList_var&);
  };

#ifndef __RTC_mPortService__
#define __RTC_mPortService__

  class PortService;
  class _objref_PortService;
  class _impl_PortService;
  
  typedef _objref_PortService* PortService_ptr;
  typedef PortService_ptr PortServiceRef;

  class PortService_Helper {
  public:
    typedef PortService_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PortService, PortService_Helper> PortService_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PortService,PortService_Helper > PortService_out;

#endif

  // interface PortService
  class PortService {
  public:
    // Declarations for this interface type.
    typedef PortService_ptr _ptr_type;
    typedef PortService_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_PortService :
    public virtual SDOPackage::_objref_SDOService
  {
  public:
    PortProfile* get_port_profile();
    ConnectorProfileList* get_connector_profiles();
    ConnectorProfile* get_connector_profile(const char* connector_id);
    ReturnCode_t connect(::RTC::ConnectorProfile& connector_profile);
    ReturnCode_t disconnect(const char* connector_id);
    ReturnCode_t disconnect_all();
    ReturnCode_t notify_connect(::RTC::ConnectorProfile& connector_profile);
    ReturnCode_t notify_disconnect(const char* connector_id);

    inline _objref_PortService()  { _PR_setobj(0); }  // nil
    _objref_PortService(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PortService();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PortService(const _objref_PortService&);
    _objref_PortService& operator = (const _objref_PortService&);
    // not implemented

    friend class PortService;
  };

  class _pof_PortService : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PortService() : _OMNI_NS(proxyObjectFactory)(PortService::_PD_repoId) {}
    virtual ~_pof_PortService();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PortService :
    public virtual SDOPackage::_impl_SDOService
  {
  public:
    virtual ~_impl_PortService();

    virtual PortProfile* get_port_profile() = 0;
    virtual ConnectorProfileList* get_connector_profiles() = 0;
    virtual ConnectorProfile* get_connector_profile(const char* connector_id) = 0;
    virtual ReturnCode_t connect(::RTC::ConnectorProfile& connector_profile) = 0;
    virtual ReturnCode_t disconnect(const char* connector_id) = 0;
    virtual ReturnCode_t disconnect_all() = 0;
    virtual ReturnCode_t notify_connect(::RTC::ConnectorProfile& connector_profile) = 0;
    virtual ReturnCode_t notify_disconnect(const char* connector_id) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortService;

#ifndef __RTC_mExecutionContextService__
#define __RTC_mExecutionContextService__

  class ExecutionContextService;
  class _objref_ExecutionContextService;
  class _impl_ExecutionContextService;
  
  typedef _objref_ExecutionContextService* ExecutionContextService_ptr;
  typedef ExecutionContextService_ptr ExecutionContextServiceRef;

  class ExecutionContextService_Helper {
  public:
    typedef ExecutionContextService_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ExecutionContextService, ExecutionContextService_Helper> ExecutionContextService_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ExecutionContextService,ExecutionContextService_Helper > ExecutionContextService_out;

#endif

  // interface ExecutionContextService
  class ExecutionContextService {
  public:
    // Declarations for this interface type.
    typedef ExecutionContextService_ptr _ptr_type;
    typedef ExecutionContextService_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ExecutionContextService :
    public virtual _objref_ExecutionContext,
    public virtual SDOPackage::_objref_SDOService
  {
  public:
    ExecutionContextProfile* get_profile();

    inline _objref_ExecutionContextService()  { _PR_setobj(0); }  // nil
    _objref_ExecutionContextService(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ExecutionContextService();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ExecutionContextService(const _objref_ExecutionContextService&);
    _objref_ExecutionContextService& operator = (const _objref_ExecutionContextService&);
    // not implemented

    friend class ExecutionContextService;
  };

  class _pof_ExecutionContextService : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ExecutionContextService() : _OMNI_NS(proxyObjectFactory)(ExecutionContextService::_PD_repoId) {}
    virtual ~_pof_ExecutionContextService();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ExecutionContextService :
    public virtual _impl_ExecutionContext,
    public virtual SDOPackage::_impl_SDOService
  {
  public:
    virtual ~_impl_ExecutionContextService();

    virtual ExecutionContextProfile* get_profile() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionContextService;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutionContextServiceList;

  class ExecutionContextServiceList_var;

  class ExecutionContextServiceList : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContextService, _CORBA_ObjRef_Element< _objref_ExecutionContextService, ExecutionContextService_Helper> , ExecutionContextService_Helper >  {
  public:
    typedef ExecutionContextServiceList_var _var_type;
    inline ExecutionContextServiceList() {}
    inline ExecutionContextServiceList(const ExecutionContextServiceList& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContextService, _CORBA_ObjRef_Element< _objref_ExecutionContextService, ExecutionContextService_Helper> , ExecutionContextService_Helper > (_s) {}

    inline ExecutionContextServiceList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContextService, _CORBA_ObjRef_Element< _objref_ExecutionContextService, ExecutionContextService_Helper> , ExecutionContextService_Helper > (_max) {}
    inline ExecutionContextServiceList(_CORBA_ULong _max, _CORBA_ULong _len, ExecutionContextService_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContextService, _CORBA_ObjRef_Element< _objref_ExecutionContextService, ExecutionContextService_Helper> , ExecutionContextService_Helper > (_max, _len, _val, _rel) {}

  

    inline ExecutionContextServiceList& operator = (const ExecutionContextServiceList& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_ExecutionContextService, _CORBA_ObjRef_Element< _objref_ExecutionContextService, ExecutionContextService_Helper> , ExecutionContextService_Helper > ::operator=(_s);
      return *this;
    }
  };

  class ExecutionContextServiceList_out;

  class ExecutionContextServiceList_var {
  public:
    inline ExecutionContextServiceList_var() : _pd_seq(0) {}
    inline ExecutionContextServiceList_var(ExecutionContextServiceList* _s) : _pd_seq(_s) {}
    inline ExecutionContextServiceList_var(const ExecutionContextServiceList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ExecutionContextServiceList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ExecutionContextServiceList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ExecutionContextServiceList_var& operator = (ExecutionContextServiceList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ExecutionContextServiceList_var& operator = (const ExecutionContextServiceList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ExecutionContextServiceList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_ExecutionContextService, ExecutionContextService_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ExecutionContextServiceList* operator -> () { return _pd_seq; }
    inline const ExecutionContextServiceList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ExecutionContextServiceList& () const { return *_pd_seq; }
#else
    inline operator const ExecutionContextServiceList& () const { return *_pd_seq; }
    inline operator ExecutionContextServiceList& () { return *_pd_seq; }
#endif
      
    inline const ExecutionContextServiceList& in() const { return *_pd_seq; }
    inline ExecutionContextServiceList&       inout()    { return *_pd_seq; }
    inline ExecutionContextServiceList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ExecutionContextServiceList* _retn() { ExecutionContextServiceList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ExecutionContextServiceList_out;
    
  private:
    ExecutionContextServiceList* _pd_seq;
  };

  class ExecutionContextServiceList_out {
  public:
    inline ExecutionContextServiceList_out(ExecutionContextServiceList*& _s) : _data(_s) { _data = 0; }
    inline ExecutionContextServiceList_out(ExecutionContextServiceList_var& _s)
      : _data(_s._pd_seq) { _s = (ExecutionContextServiceList*) 0; }
    inline ExecutionContextServiceList_out(const ExecutionContextServiceList_out& _s) : _data(_s._data) {}
    inline ExecutionContextServiceList_out& operator = (const ExecutionContextServiceList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ExecutionContextServiceList_out& operator = (ExecutionContextServiceList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ExecutionContextServiceList*&()  { return _data; }
    inline ExecutionContextServiceList*& ptr()       { return _data; }
    inline ExecutionContextServiceList* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_ExecutionContextService, ExecutionContextService_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ExecutionContextServiceList*& _data;

  private:
    ExecutionContextServiceList_out();
    ExecutionContextServiceList_out& operator=(const ExecutionContextServiceList_var&);
  };

#ifndef __RTC_mRTObject__
#define __RTC_mRTObject__

  class RTObject;
  class _objref_RTObject;
  class _impl_RTObject;
  
  typedef _objref_RTObject* RTObject_ptr;
  typedef RTObject_ptr RTObjectRef;

  class RTObject_Helper {
  public:
    typedef RTObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_RTObject, RTObject_Helper> RTObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_RTObject,RTObject_Helper > RTObject_out;

#endif

  // interface RTObject
  class RTObject {
  public:
    // Declarations for this interface type.
    typedef RTObject_ptr _ptr_type;
    typedef RTObject_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_RTObject :
    public virtual _objref_LightweightRTObject,
    public virtual SDOPackage::_objref_SDO
  {
  public:
    ComponentProfile* get_component_profile();
    PortServiceList* get_ports();

    inline _objref_RTObject()  { _PR_setobj(0); }  // nil
    _objref_RTObject(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_RTObject();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_RTObject(const _objref_RTObject&);
    _objref_RTObject& operator = (const _objref_RTObject&);
    // not implemented

    friend class RTObject;
  };

  class _pof_RTObject : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_RTObject() : _OMNI_NS(proxyObjectFactory)(RTObject::_PD_repoId) {}
    virtual ~_pof_RTObject();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_RTObject :
    public virtual _impl_LightweightRTObject,
    public virtual SDOPackage::_impl_SDO
  {
  public:
    virtual ~_impl_RTObject();

    virtual ComponentProfile* get_component_profile() = 0;
    virtual PortServiceList* get_ports() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RTObject;

_CORBA_MODULE_END



_CORBA_MODULE POA_RTC
_CORBA_MODULE_BEG

  class ComponentAction :
    public virtual RTC::_impl_ComponentAction,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ComponentAction();

    inline ::RTC::ComponentAction_ptr _this() {
      return (::RTC::ComponentAction_ptr) _do_this(::RTC::ComponentAction::_PD_repoId);
    }
  };

  class LightweightRTObject :
    public virtual RTC::_impl_LightweightRTObject,
    public virtual ComponentAction
  {
  public:
    virtual ~LightweightRTObject();

    inline ::RTC::LightweightRTObject_ptr _this() {
      return (::RTC::LightweightRTObject_ptr) _do_this(::RTC::LightweightRTObject::_PD_repoId);
    }
  };

  class ExecutionContext :
    public virtual RTC::_impl_ExecutionContext,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ExecutionContext();

    inline ::RTC::ExecutionContext_ptr _this() {
      return (::RTC::ExecutionContext_ptr) _do_this(::RTC::ExecutionContext::_PD_repoId);
    }
  };

  class DataFlowComponentAction :
    public virtual RTC::_impl_DataFlowComponentAction,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DataFlowComponentAction();

    inline ::RTC::DataFlowComponentAction_ptr _this() {
      return (::RTC::DataFlowComponentAction_ptr) _do_this(::RTC::DataFlowComponentAction::_PD_repoId);
    }
  };

  class DataFlowComponent :
    public virtual RTC::_impl_DataFlowComponent,
    public virtual LightweightRTObject,
      public virtual DataFlowComponentAction
  {
  public:
    virtual ~DataFlowComponent();

    inline ::RTC::DataFlowComponent_ptr _this() {
      return (::RTC::DataFlowComponent_ptr) _do_this(::RTC::DataFlowComponent::_PD_repoId);
    }
  };

  class Fsm :
    public virtual RTC::_impl_Fsm,
    public virtual LightweightRTObject
  {
  public:
    virtual ~Fsm();

    inline ::RTC::Fsm_ptr _this() {
      return (::RTC::Fsm_ptr) _do_this(::RTC::Fsm::_PD_repoId);
    }
  };

  class FsmParticipantAction :
    public virtual RTC::_impl_FsmParticipantAction,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~FsmParticipantAction();

    inline ::RTC::FsmParticipantAction_ptr _this() {
      return (::RTC::FsmParticipantAction_ptr) _do_this(::RTC::FsmParticipantAction::_PD_repoId);
    }
  };

  class FsmParticipant :
    public virtual RTC::_impl_FsmParticipant,
    public virtual LightweightRTObject,
      public virtual FsmParticipantAction
  {
  public:
    virtual ~FsmParticipant();

    inline ::RTC::FsmParticipant_ptr _this() {
      return (::RTC::FsmParticipant_ptr) _do_this(::RTC::FsmParticipant::_PD_repoId);
    }
  };

  class Mode :
    public virtual RTC::_impl_Mode,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Mode();

    inline ::RTC::Mode_ptr _this() {
      return (::RTC::Mode_ptr) _do_this(::RTC::Mode::_PD_repoId);
    }
  };

  class ModeCapable :
    public virtual RTC::_impl_ModeCapable,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ModeCapable();

    inline ::RTC::ModeCapable_ptr _this() {
      return (::RTC::ModeCapable_ptr) _do_this(::RTC::ModeCapable::_PD_repoId);
    }
  };

  class MultiModeComponentAction :
    public virtual RTC::_impl_MultiModeComponentAction,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~MultiModeComponentAction();

    inline ::RTC::MultiModeComponentAction_ptr _this() {
      return (::RTC::MultiModeComponentAction_ptr) _do_this(::RTC::MultiModeComponentAction::_PD_repoId);
    }
  };

  class MultiModeObject :
    public virtual RTC::_impl_MultiModeObject,
    public virtual LightweightRTObject,
      public virtual ModeCapable,
      public virtual MultiModeComponentAction
  {
  public:
    virtual ~MultiModeObject();

    inline ::RTC::MultiModeObject_ptr _this() {
      return (::RTC::MultiModeObject_ptr) _do_this(::RTC::MultiModeObject::_PD_repoId);
    }
  };

  class FsmObject :
    public virtual RTC::_impl_FsmObject,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~FsmObject();

    inline ::RTC::FsmObject_ptr _this() {
      return (::RTC::FsmObject_ptr) _do_this(::RTC::FsmObject::_PD_repoId);
    }
  };

  class FsmService :
    public virtual RTC::_impl_FsmService,
    public virtual POA_SDOPackage::SDOService
  {
  public:
    virtual ~FsmService();

    inline ::RTC::FsmService_ptr _this() {
      return (::RTC::FsmService_ptr) _do_this(::RTC::FsmService::_PD_repoId);
    }
  };

  class PortService :
    public virtual RTC::_impl_PortService,
    public virtual POA_SDOPackage::SDOService
  {
  public:
    virtual ~PortService();

    inline ::RTC::PortService_ptr _this() {
      return (::RTC::PortService_ptr) _do_this(::RTC::PortService::_PD_repoId);
    }
  };

  class ExecutionContextService :
    public virtual RTC::_impl_ExecutionContextService,
    public virtual ExecutionContext,
      public virtual POA_SDOPackage::SDOService
  {
  public:
    virtual ~ExecutionContextService();

    inline ::RTC::ExecutionContextService_ptr _this() {
      return (::RTC::ExecutionContextService_ptr) _do_this(::RTC::ExecutionContextService::_PD_repoId);
    }
  };

  class RTObject :
    public virtual RTC::_impl_RTObject,
    public virtual LightweightRTObject,
      public virtual POA_SDOPackage::SDO
  {
  public:
    virtual ~RTObject();

    inline ::RTC::RTObject_ptr _this() {
      return (::RTC::RTObject_ptr) _do_this(::RTC::RTObject::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_RTC
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(RTC::ReturnCode_t _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::ReturnCode_t& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::PRECONDITION_NOT_MET) {
    _e = (RTC::ReturnCode_t) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::ReturnCode_t _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ReturnCode_t& _s);

inline void operator >>=(RTC::LifeCycleState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::LifeCycleState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::ERROR_STATE) {
    _e = (RTC::LifeCycleState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::LifeCycleState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::LifeCycleState& _s);

void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextList*& _sp);

void operator<<=(::CORBA::Any& _a, RTC::ComponentAction_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::ComponentAction_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ComponentAction_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::LightweightRTObject_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::LightweightRTObject_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::LightweightRTObject_ptr& _s);

inline void operator >>=(RTC::ExecutionKind _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::ExecutionKind& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::OTHER) {
    _e = (RTC::ExecutionKind) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::ExecutionKind _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionKind& _s);

void operator<<=(::CORBA::Any& _a, RTC::ExecutionContext_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContext_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContext_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponentAction_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponentAction_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::DataFlowComponentAction_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponent_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::DataFlowComponent_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::DataFlowComponent_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::Fsm_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::Fsm_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Fsm_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::FsmParticipantAction_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::FsmParticipantAction_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmParticipantAction_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::FsmParticipant_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::FsmParticipant_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmParticipant_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::Mode_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::Mode_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::Mode_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::ModeCapable_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::ModeCapable_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ModeCapable_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::MultiModeComponentAction_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::MultiModeComponentAction_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::MultiModeComponentAction_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::MultiModeObject_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::MultiModeObject_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::MultiModeObject_ptr& _s);

inline void operator >>=(RTC::PortInterfacePolarity _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (RTC::PortInterfacePolarity& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= RTC::REQUIRED) {
    _e = (RTC::PortInterfacePolarity) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, RTC::PortInterfacePolarity _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortInterfacePolarity& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::PortInterfaceProfile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PortInterfaceProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortInterfaceProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortInterfaceProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::PortInterfaceProfileList& _s);
void operator<<=(::CORBA::Any& _a, RTC::PortInterfaceProfileList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortInterfaceProfileList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortInterfaceProfileList*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::PortServiceList& _s);
void operator<<=(::CORBA::Any& _a, RTC::PortServiceList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortServiceList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortServiceList*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::RTCList& _s);
void operator<<=(::CORBA::Any& _a, RTC::RTCList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::RTCList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RTCList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::ConnectorProfile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ConnectorProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ConnectorProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ConnectorProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::ConnectorProfileList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ConnectorProfileList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ConnectorProfileList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ConnectorProfileList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::PortProfile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::PortProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::PortProfileList& _s);
void operator<<=(::CORBA::Any& _a, RTC::PortProfileList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortProfileList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PortProfileList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextProfile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextProfileList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextProfileList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextProfileList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextProfileList*& _sp);

void operator<<=(::CORBA::Any& _a, RTC::FsmObject_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::FsmObject_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmObject_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::FsmBehaviorProfile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::FsmBehaviorProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmBehaviorProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FsmBehaviorProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::FsmBehaviorProfileList& _s);
void operator<<=(::CORBA::Any& _a, RTC::FsmBehaviorProfileList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmBehaviorProfileList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FsmBehaviorProfileList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const RTC::FsmProfile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::FsmProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FsmProfile*& _sp);

void operator<<=(::CORBA::Any& _a, RTC::FsmService_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::FsmService_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::FsmService_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const RTC::ComponentProfile& _s);
extern void operator<<=(::CORBA::Any& _a, RTC::ComponentProfile* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ComponentProfile*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ComponentProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const RTC::ComponentProfileList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ComponentProfileList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ComponentProfileList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ComponentProfileList*& _sp);

void operator<<=(::CORBA::Any& _a, RTC::PortService_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::PortService_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::PortService_ptr& _s);

void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextService_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextService_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextService_ptr& _s);

void operator<<=(::CORBA::Any& _a, const RTC::ExecutionContextServiceList& _s);
void operator<<=(::CORBA::Any& _a, RTC::ExecutionContextServiceList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::ExecutionContextServiceList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const RTC::ExecutionContextServiceList*& _sp);

void operator<<=(::CORBA::Any& _a, RTC::RTObject_ptr _s);
void operator<<=(::CORBA::Any& _a, RTC::RTObject_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, RTC::RTObject_ptr& _s);



inline void
RTC::ComponentAction::_marshalObjRef(::RTC::ComponentAction_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::LightweightRTObject::_marshalObjRef(::RTC::LightweightRTObject_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::ExecutionContext::_marshalObjRef(::RTC::ExecutionContext_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::DataFlowComponentAction::_marshalObjRef(::RTC::DataFlowComponentAction_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::DataFlowComponent::_marshalObjRef(::RTC::DataFlowComponent_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::Fsm::_marshalObjRef(::RTC::Fsm_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::FsmParticipantAction::_marshalObjRef(::RTC::FsmParticipantAction_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::FsmParticipant::_marshalObjRef(::RTC::FsmParticipant_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::Mode::_marshalObjRef(::RTC::Mode_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::ModeCapable::_marshalObjRef(::RTC::ModeCapable_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::MultiModeComponentAction::_marshalObjRef(::RTC::MultiModeComponentAction_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::MultiModeObject::_marshalObjRef(::RTC::MultiModeObject_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::FsmObject::_marshalObjRef(::RTC::FsmObject_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::FsmService::_marshalObjRef(::RTC::FsmService_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::PortService::_marshalObjRef(::RTC::PortService_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::ExecutionContextService::_marshalObjRef(::RTC::ExecutionContextService_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
RTC::RTObject::_marshalObjRef(::RTC::RTObject_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_RTC
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_RTC
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_RTC
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_RTC
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_RTC
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_RTC
#endif

#endif  // __RTC_hh__

